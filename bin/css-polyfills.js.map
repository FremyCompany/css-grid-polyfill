{"version":3,"sources":["../src/core/polyfill-dom-console.js","../src/core/polyfill-dom-requestAnimationFrame.js","../src/core/css-syntax.js","../src/core/dom-events.js","../src/core/dom-experimental-event-streams.js","../src/core/dom-query-selector-live.js","../src/core/css-cascade.js","../src/core/css-style.js","../src/core/css-virtual-stylesheet-factory.js","../src/core/polyfill-dom-uniqueID.js","../src/core/css-sizing.js","../src/core/css-box.js","../src/core/css-units.js","../src/css-grid/lib/grid-layout.js","../src/css-grid/polyfill.js","../src/requirements.js"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mD;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iE;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;ACxzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6D;;;;ACnXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sD;;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;AC3yBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6D;;;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oD;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kD;;;;AC7wFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;AC9JA;AACA;AACA;AACA,sC","file":"css-polyfills.js","sourcesContent":["!(function(window, document) { \"use strict\";\n\n\t//\n\t// some code for console polyfilling\n\t//\n\tif(!window.console) {\n\t\t\t\n\t\twindow.console = {\n\t\t\tbacklog: '',\n\t\t\t\n\t\t\tlog: function(x) { this.backlog+=x+'\\n'; if(window.debug) alert(x); },\n\t\t\t\n\t\t\tdir: function(x) { try { \n\t\t\t\t\n\t\t\t\tvar elm = function(e) {\n\t\t\t\t\tif(e.innerHTML) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttagName: e.tagName,\n\t\t\t\t\t\t\tclassName: e.className,\n\t\t\t\t\t\t\tid: e.id,\n\t\t\t\t\t\t\tinnerHTML: e.innerHTML.substr(0,100)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tnodeName: e.nodeName,\n\t\t\t\t\t\t\tnodeValue: e.nodeValue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tvar jsonify = function(o) {\n\t\t\t\t\tvar seen=[];\n\t\t\t\t\tvar jso=JSON.stringify(o, function(k,v){\n\t\t\t\t\t\tif (typeof v =='object') {\n\t\t\t\t\t\t\tif ( !seen.indexOf(v) ) { return '__cycle__'; }\n\t\t\t\t\t\t\tif ( v instanceof window.Node) { return elm(v); }\n\t\t\t\t\t\t\tseen.push(v);\n\t\t\t\t\t\t} return v;\n\t\t\t\t\t});\n\t\t\t\t\treturn jso;\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tthis.log(jsonify(x)); \n\t\t\t\t\n\t\t\t} catch(ex) { this.log(x) } },\n\t\t\t\n\t\t\twarn: function(x) { this.log(x) },\n\t\t\t\n\t\t\terror: function(x) { this.log(\"ERROR:\"); this.log(x); }\n\t\t\t\n\t\t};\n\t\t\n\t\tif(!window.onerror) {\n\t\t\twindow.onerror = function() {\n\t\t\t\tconsole.log([].slice.call(arguments,0).join(\"\\n\"))\n\t\t\t};\n\t\t}\n\t\t\n\t}\n\n\t//\n\t// this special console is used as a proxy emulating the CSS console of browsers\n\t//\n\twindow.cssConsole = {\n\t\tenabled: (!!window.debug), warnEnabled: (true),\n\t\tlog: function(x) { if(this.enabled) console.log(x) },\n\t\tdir: function(x) { if(this.enabled) console.dir(x) },\n\t\twarn: function(x) { if(this.warnEnabled) console.warn(x) },\n\t\terror: function(x) { console.error(x); }\n\t}\n\n})(window, document);\nrequire.define('src/core/polyfill-dom-console.js');","void function() {\n\t\n\t// request animation frame\n    var vendors = ['webkit', 'moz', 'ms', 'o'];\n    for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {\n        var vp = vendors[i];\n        window.requestAnimationFrame = window[vp+'RequestAnimationFrame'];\n        window.cancelAnimationFrame = (window[vp+'CancelAnimationFrame'] || window[vp+'CancelRequestAnimationFrame']);\n    }\n    if (!window.requestAnimationFrame || !window.cancelAnimationFrame) {\n\t\t\n\t\t// tick every 16ms\n        var listener_index = 0; var listeners = []; var tmp = []; var tick = function() {\n\t\t\tvar now = +(new Date()); var callbacks = listeners; listeners = tmp;\n\t\t\tfor(var i = 0; i<callbacks.length; i++) { callbacks[i](now); }\n\t\t\tlistener_index += callbacks.length; callbacks.length = 0; tmp = callbacks;\n\t\t\tsetTimeout(tick, 16);\n\t\t}; tick();\n\t\t\n\t\t// add a listener\n        window.requestAnimationFrame = function(callback) {\n            return listener_index + listeners.push(callback);\n        };\n\t\t\n\t\t// remove a listener\n        window.cancelAnimationFrame = function(index) {\n\t\t\tindex -= listener_index; if(index >= 0 && index < listeners.length) {\n\t\t\t\tlisteners[index] = function() {};\n\t\t\t}\n\t\t};\n\t\t\n    }\n\t\n\t// setImmediate\n\tif(!window.setImmediate) {\n\t\twindow.setImmediate = function(f) { return setTimeout(f, 0) };\n\t\twindow.cancelImmediate = clearTimeout;\n\t}\n\t\n}();\n\nrequire.define('src/core/polyfill-dom-requestAnimationFrame.js');","//\n// note: this file is based on Tab Atkins's CSS Parser\n// please include him (@tabatkins) if you open any issue for this file\n// \nmodule.exports = (function(window, document) { \"use strict\";\n\n// \n// exports\n//\nvar cssSyntax = { \n\ttokenize: function(string) {/*filled later*/}, \n\tparse: function(tokens) {/*filled later*/}\n};\n\n//\n// css tokenizer\n//\n\n// Add support for token lists (superclass of array)\nfunction TokenList() {\n\tvar array = []; \n\tarray.toCSSString=TokenListToCSSString;\n\treturn array;\n}\nfunction TokenListToCSSString(sep) {\n\tif(sep) {\n\t\treturn this.map(function(o) { return o.toCSSString(); }).join(sep);\n\t} else {\n\t\treturn this.asCSSString || (this.asCSSString = (\n\t\t\tthis.map(function(o) { return o.toCSSString(); }).join(\"/**/\")\n\t\t\t\t.replace(/( +\\/\\*\\*\\/ *| * | *\\/\\*\\*\\/ +)/g,\" \")\n\t\t\t\t.replace(/( +\\/\\*\\*\\/ *| * | *\\/\\*\\*\\/ +)/g,\" \")\n\t\t\t\t.replace(/(\\!|\\:|\\;|\\@|\\.|\\,|\\*|\\=|\\&|\\\\|\\/|\\<|\\>|\\[|\\{|\\(|\\]|\\}|\\)|\\|)\\/\\*\\*\\//g,\"$1\")\n\t\t\t\t.replace(/\\/\\*\\*\\/(\\!|\\:|\\;|\\@|\\.|\\,|\\*|\\=|\\&|\\\\|\\/|\\<|\\>|\\[|\\{|\\(|\\]|\\}|\\)|\\|)/g,\"$1\")\n\t\t));\n\t}\n}\ncssSyntax.TokenList = TokenList;\ncssSyntax.TokenListToCSSString = TokenListToCSSString;\n\nfunction between(num, first, last) { return num >= first && num <= last; }\nfunction digit(code) { return between(code, 0x30,0x39); }\nfunction hexdigit(code) { return digit(code) || between(code, 0x41,0x46) || between(code, 0x61,0x66); }\nfunction uppercaseletter(code) { return between(code, 0x41,0x5a); }\nfunction lowercaseletter(code) { return between(code, 0x61,0x7a); }\nfunction letter(code) { return uppercaseletter(code) || lowercaseletter(code); }\nfunction nonascii(code) { return code >= 0x80; }\nfunction namestartchar(code) { return letter(code) || nonascii(code) || code == 0x5f; }\nfunction namechar(code) { return namestartchar(code) || digit(code) || code == 0x2d; }\nfunction nonprintable(code) { return between(code, 0,8) || code == 0xb || between(code, 0xe,0x1f) || code == 0x7f; }\nfunction newline(code) { return code == 0xa; }\nfunction whitespace(code) { return newline(code) || code == 9 || code == 0x20; }\nfunction badescape(code) { return newline(code) || isNaN(code); }\n\nvar maximumallowedcodepoint = 0x10ffff;\n\nfunction InvalidCharacterError(message) {\n\tthis.message = message;\n};\nInvalidCharacterError.prototype = new Error;\nInvalidCharacterError.prototype.name = 'InvalidCharacterError';\n\nfunction preprocess(str) {\n\t// Turn a string into an array of code points,\n\t// following the preprocessing cleanup rules.\n\tvar codepoints = [];\n\tfor(var i = 0; i < str.length; i++) {\n\t\tvar code = str.charCodeAt(i);\n\t\tif(code == 0xd && str.charCodeAt(i+1) == 0xa) {\n\t\t\tcode = 0xa; i++;\n\t\t}\n\t\tif(code == 0xd || code == 0xc) code = 0xa;\n\t\tif(code == 0x0) code = 0xfffd;\n\t\tif(between(code, 0xd800, 0xdbff) && between(str.charCodeAt(i+1), 0xdc00, 0xdfff)) {\n\t\t\t// Decode a surrogate pair into an astral codepoint.\n\t\t\tvar lead = code - 0xd800;\n\t\t\tvar trail = str.charCodeAt(i+1) - 0xdc00;\n\t\t\tcode = Math.pow(2, 21) + lead * Math.pow(2, 10) + trail;\n\t\t}\n\t\tcodepoints.push(code);\n\t}\n\treturn codepoints;\n}\n\nfunction stringFromCode(code) {\n\tif(code <= 0xffff) return String.fromCharCode(code);\n\t// Otherwise, encode astral char as surrogate pair.\n\tcode -= Math.pow(2, 21);\n\tvar lead = Math.floor(code/Math.pow(2, 10)) + 0xd800;\n\tvar trail = code % Math.pow(2, 10); + 0xdc00;\n\treturn String.fromCharCode(lead) + String.fromCharCode(trail);\n}\n\nfunction tokenize(str) {\n\tstr = preprocess(str);\n\tvar i = -1;\n\tvar tokens = new TokenList();\n\tvar code;\n\n\t// Line number information.\n\tvar line = 0;\n\tvar column = 0;\n\t// The only use of lastLineLength is in reconsume().\n\tvar lastLineLength = 0;\n\tvar incrLineno = function() {\n\t\tline += 1;\n\t\tlastLineLength = column;\n\t\tcolumn = 0;\n\t};\n\tvar locStart = {line:line, column:column};\n\n\tvar codepoint = function(i) {\n\t\tif(i >= str.length) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn str[i];\n\t}\n\tvar next = function(num) {\n\t\tif(num === undefined) { num = 1; }\n\t\tif(num > 3) { throw \"Spec Error: no more than three codepoints of lookahead.\"; }\n\t\treturn codepoint(i+num);\n\t};\n\tvar consume = function(num) {\n\t\tif(num === undefined)\n\t\t\tnum = 1;\n\t\ti += num;\n\t\tcode = codepoint(i);\n\t\tif(newline(code)) incrLineno();\n\t\telse column += num;\n\t\t//console.log('Consume '+i+' '+String.fromCharCode(code) + ' 0x' + code.toString(16));\n\t\treturn true;\n\t};\n\tvar reconsume = function() {\n\t\ti -= 1;\n\t\tif (newline(code)) {\n\t\t\tline -= 1;\n\t\t\tcolumn = lastLineLength;\n\t\t} else {\n\t\t\tcolumn -= 1;\n\t\t}\n\t\tlocStart.line = line;\n\t\tlocStart.column = column;\n\t\treturn true;\n\t};\n\tvar eof = function(codepoint) {\n\t\tif(codepoint === undefined) codepoint = code;\n\t\treturn codepoint == -1;\n\t};\n\tvar donothing = function() {};\n\tvar tokenizeerror = function() { console.log(\"Parse error at index \" + i + \", processing codepoint 0x\" + code.toString(16) + \".\");return true; };\n\n\tvar consumeAToken = function() {\n\t\tconsumeComments();\n\t\tconsume();\n\t\tif(whitespace(code)) {\n\t\t\twhile(whitespace(next())) consume();\n\t\t\treturn new WhitespaceToken;\n\t\t}\n\t\telse if(code == 0x22) return consumeAStringToken();\n\t\telse if(code == 0x23) {\n\t\t\tif(namechar(next()) || areAValidEscape(next(1), next(2))) {\n\t\t\t\tvar token = new HashToken();\n\t\t\t\tif(wouldStartAnIdentifier(next(1), next(2), next(3))) token.type = \"id\";\n\t\t\t\ttoken.value = consumeAName();\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x24) {\n\t\t\tif(next() == 0x3d) {\n\t\t\t\tconsume();\n\t\t\t\treturn new SuffixMatchToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x27) return consumeAStringToken();\n\t\telse if(code == 0x28) return new OpenParenToken();\n\t\telse if(code == 0x29) return new CloseParenToken();\n\t\telse if(code == 0x2a) {\n\t\t\tif(next() == 0x3d) {\n\t\t\t\tconsume();\n\t\t\t\treturn new SubstringMatchToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x2b) {\n\t\t\tif(startsWithANumber()) {\n\t\t\t\treconsume();\n\t\t\t\treturn consumeANumericToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x2c) return new CommaToken();\n\t\telse if(code == 0x2d) {\n\t\t\tif(startsWithANumber()) {\n\t\t\t\treconsume();\n\t\t\t\treturn consumeANumericToken();\n\t\t\t} else if(next(1) == 0x2d && next(2) == 0x3e) {\n\t\t\t\tconsume(2);\n\t\t\t\treturn new CDCToken();\n\t\t\t} else if(startsWithAnIdentifier()) {\n\t\t\t\treconsume();\n\t\t\t\treturn consumeAnIdentlikeToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x2e) {\n\t\t\tif(startsWithANumber()) {\n\t\t\t\treconsume();\n\t\t\t\treturn consumeANumericToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x3a) return new ColonToken;\n\t\telse if(code == 0x3b) return new SemicolonToken;\n\t\telse if(code == 0x3c) {\n\t\t\tif(next(1) == 0x21 && next(2) == 0x2d && next(3) == 0x2d) {\n\t\t\t\tconsume(3);\n\t\t\t\treturn new CDOToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x40) {\n\t\t\tif(wouldStartAnIdentifier(next(1), next(2), next(3))) {\n\t\t\t\treturn new AtKeywordToken(consumeAName());\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x5b) return new OpenSquareToken();\n\t\telse if(code == 0x5c) {\n\t\t\tif(startsWithAValidEscape()) {\n\t\t\t\treconsume();\n\t\t\t\treturn consumeAnIdentlikeToken();\n\t\t\t} else {\n\t\t\t\ttokenizeerror();\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x5d) return new CloseSquareToken();\n\t\telse if(code == 0x5e) {\n\t\t\tif(next() == 0x3d) {\n\t\t\t\tconsume();\n\t\t\t\treturn new PrefixMatchToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x7b) return new OpenCurlyToken();\n\t\telse if(code == 0x7c) {\n\t\t\tif(next() == 0x3d) {\n\t\t\t\tconsume();\n\t\t\t\treturn new DashMatchToken();\n\t\t\t} else if(next() == 0x7c) {\n\t\t\t\tconsume();\n\t\t\t\treturn new ColumnToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x7d) return new CloseCurlyToken();\n\t\telse if(code == 0x7e) {\n\t\t\tif(next() == 0x3d) {\n\t\t\t\tconsume();\n\t\t\t\treturn new IncludeMatchToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(digit(code)) {\n\t\t\treconsume();\n\t\t\treturn consumeANumericToken();\n\t\t}\n\t\telse if(namestartchar(code)) {\n\t\t\treconsume();\n\t\t\treturn consumeAnIdentlikeToken();\n\t\t}\n\t\telse if(eof()) return new EOFToken();\n\t\telse return new DelimToken(code);\n\t};\n\n\tvar consumeComments = function() {\n\t\twhile(next(1) == 0x2f && next(2) == 0x2a) {\n\t\t\tconsume(2);\n\t\t\twhile(true) {\n\t\t\t\tconsume();\n\t\t\t\tif(code == 0x2a && next() == 0x2f) {\n\t\t\t\t\tconsume();\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(eof()) {\n\t\t\t\t\ttokenizeerror();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tvar consumeANumericToken = function() {\n\t\tvar num = consumeANumber();\n\t\tif(wouldStartAnIdentifier(next(1), next(2), next(3))) {\n\t\t\tvar token = new DimensionToken();\n\t\t\ttoken.value = num.value;\n\t\t\ttoken.repr = num.repr;\n\t\t\ttoken.type = num.type;\n\t\t\ttoken.unit = consumeAName();\n\t\t\treturn token;\n\t\t} else if(next() == 0x25) {\n\t\t\tconsume();\n\t\t\tvar token = new PercentageToken();\n\t\t\ttoken.value = num.value;\n\t\t\ttoken.repr = num.repr;\n\t\t\treturn token;\n\t\t} else {\n\t\t\tvar token = new NumberToken();\n\t\t\ttoken.value = num.value;\n\t\t\ttoken.repr = num.repr;\n\t\t\ttoken.type = num.type;\n\t\t\treturn token;\n\t\t}\n\t};\n\n\tvar consumeAnIdentlikeToken = function() {\n\t\tvar str = consumeAName();\n\t\tif(str.toLowerCase() == \"url\" && next() == 0x28) {\n\t\t\tconsume();\n\t\t\twhile(whitespace(next(1)) && whitespace(next(2))) consume();\n\t\t\tif(next() == 0x22 || next() == 0x27) {\n\t\t\t\treturn new FunctionToken(str);\n\t\t\t} else if(whitespace(next()) && (next(2) == 0x22 || next(2) == 0x27)) {\n\t\t\t\treturn new FunctionToken(str);\n\t\t\t} else {\n\t\t\t\treturn consumeAURLToken();\n\t\t\t}\n\t\t} else if(next() == 0x28) {\n\t\t\tconsume();\n\t\t\treturn new FunctionToken(str);\n\t\t} else {\n\t\t\treturn new IdentifierToken(str);\n\t\t}\n\t};\n\n\tvar consumeAStringToken = function(endingCodePoint) {\n\t\tif(endingCodePoint === undefined) endingCodePoint = code;\n\t\tvar string = \"\";\n\t\twhile(consume()) {\n\t\t\tif(code == endingCodePoint || eof()) {\n\t\t\t\treturn new StringToken(string);\n\t\t\t} else if(newline(code)) {\n\t\t\t\ttokenizeerror();\n\t\t\t\treconsume();\n\t\t\t\treturn new BadStringToken();\n\t\t\t} else if(code == 0x5c) {\n\t\t\t\tif(eof(next())) {\n\t\t\t\t\tdonothing();\n\t\t\t\t} else if(newline(next())) {\n\t\t\t\t\tconsume();\n\t\t\t\t} else {\n\t\t\t\t\tstring += stringFromCode(consumeEscape())\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstring += stringFromCode(code);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar consumeAURLToken = function() {\n\t\tvar token = new URLToken(\"\");\n\t\twhile(whitespace(next())) consume();\n\t\tif(eof(next())) return token;\n\t\twhile(consume()) {\n\t\t\tif(code == 0x29 || eof()) {\n\t\t\t\treturn token;\n\t\t\t} else if(whitespace(code)) {\n\t\t\t\twhile(whitespace(next())) consume();\n\t\t\t\tif(next() == 0x29 || eof(next())) {\n\t\t\t\t\tconsume();\n\t\t\t\t\treturn token;\n\t\t\t\t} else {\n\t\t\t\t\tconsumeTheRemnantsOfABadURL();\n\t\t\t\t\treturn new BadURLToken();\n\t\t\t\t}\n\t\t\t} else if(code == 0x22 || code == 0x27 || code == 0x28 || nonprintable(code)) {\n\t\t\t\ttokenizeerror();\n\t\t\t\tconsumeTheRemnantsOfABadURL();\n\t\t\t\treturn new BadURLToken();\n\t\t\t} else if(code == 0x5c) {\n\t\t\t\tif(startsWithAValidEscape()) {\n\t\t\t\t\ttoken.value += stringFromCode(consumeEscape());\n\t\t\t\t} else {\n\t\t\t\t\ttokenizeerror();\n\t\t\t\t\tconsumeTheRemnantsOfABadURL();\n\t\t\t\t\treturn new BadURLToken();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttoken.value += stringFromCode(code);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar consumeEscape = function() {\n\t\t// Assume the the current character is the \\\n\t\t// and the next code point is not a newline.\n\t\tconsume();\n\t\tif(hexdigit(code)) {\n\t\t\t// Consume 1-6 hex digits\n\t\t\tvar digits = [code];\n\t\t\tfor(var total = 0; total < 5; total++) {\n\t\t\t\tif(hexdigit(next())) {\n\t\t\t\t\tconsume();\n\t\t\t\t\tdigits.push(code);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(whitespace(next())) consume();\n\t\t\tvar value = parseInt(digits.map(function(x){return String.fromCharCode(x);}).join(''), 16);\n\t\t\tif( value > maximumallowedcodepoint ) value = 0xfffd;\n\t\t\treturn value;\n\t\t} else if(eof()) {\n\t\t\treturn 0xfffd;\n\t\t} else {\n\t\t\treturn code;\n\t\t}\n\t};\n\n\tvar areAValidEscape = function(c1, c2) {\n\t\tif(c1 != 0x5c) return false;\n\t\tif(newline(c2)) return false;\n\t\treturn true;\n\t};\n\tvar startsWithAValidEscape = function() {\n\t\treturn areAValidEscape(code, next());\n\t};\n\n\tvar wouldStartAnIdentifier = function(c1, c2, c3) {\n\t\tif(c1 == 0x2d) {\n\t\t\treturn namestartchar(c2) || c2 == 0x2d || areAValidEscape(c2, c3);\n\t\t} else if(namestartchar(c1)) {\n\t\t\treturn true;\n\t\t} else if(c1 == 0x5c) {\n\t\t\treturn areAValidEscape(c1, c2);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\tvar startsWithAnIdentifier = function() {\n\t\treturn wouldStartAnIdentifier(code, next(1), next(2));\n\t};\n\n\tvar wouldStartANumber = function(c1, c2, c3) {\n\t\tif(c1 == 0x2b || c1 == 0x2d) {\n\t\t\tif(digit(c2)) return true;\n\t\t\tif(c2 == 0x2e && digit(c3)) return true;\n\t\t\treturn false;\n\t\t} else if(c1 == 0x2e) {\n\t\t\tif(digit(c2)) return true;\n\t\t\treturn false;\n\t\t} else if(digit(c1)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\tvar startsWithANumber = function() {\n\t\treturn wouldStartANumber(code, next(1), next(2));\n\t};\n\n\tvar consumeAName = function() {\n\t\tvar result = \"\";\n\t\twhile(consume()) {\n\t\t\tif(namechar(code)) {\n\t\t\t\tresult += stringFromCode(code);\n\t\t\t} else if(startsWithAValidEscape()) {\n\t\t\t\tresult += stringFromCode(consumeEscape());\n\t\t\t} else {\n\t\t\t\treconsume();\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t};\n\n\tvar consumeANumber = function() {\n\t\tvar repr = '';\n\t\tvar type = \"integer\";\n\t\tif(next() == 0x2b || next() == 0x2d) {\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t}\n\t\twhile(digit(next())) {\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t}\n\t\tif(next(1) == 0x2e && digit(next(2))) {\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t\ttype = \"number\";\n\t\t\twhile(digit(next())) {\n\t\t\t\tconsume();\n\t\t\t\trepr += stringFromCode(code);\n\t\t\t}\n\t\t}\n\t\tvar c1 = next(1), c2 = next(2), c3 = next(3);\n\t\tif((c1 == 0x45 || c1 == 0x65) && digit(c2)) {\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t\ttype = \"number\";\n\t\t\twhile(digit(next())) {\n\t\t\t\tconsume();\n\t\t\t\trepr += stringFromCode(code);\n\t\t\t}\n\t\t} else if((c1 == 0x45 || c1 == 0x65) && (c2 == 0x2b || c2 == 0x2d) && digit(c3)) {\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t\ttype = \"number\";\n\t\t\twhile(digit(next())) {\n\t\t\t\tconsume();\n\t\t\t\trepr += stringFromCode(code);\n\t\t\t}\n\t\t}\n\t\tvar value = convertAStringToANumber(repr);\n\t\treturn {type:type, value:value, repr:repr};\n\t};\n\n\tvar convertAStringToANumber = function(string) {\n\t\t// CSS's number rules are identical to JS, afaik.\n\t\treturn +string;\n\t};\n\n\tvar consumeTheRemnantsOfABadURL = function() {\n\t\twhile(consume()) {\n\t\t\tif(code == 0x2d || eof()) {\n\t\t\t\treturn;\n\t\t\t} else if(startsWithAValidEscape()) {\n\t\t\t\tconsumeEscape();\n\t\t\t\tdonothing();\n\t\t\t} else {\n\t\t\t\tdonothing();\n\t\t\t}\n\t\t}\n\t};\n\n\n\n\tvar iterationCount = 0;\n\twhile(!eof(next())) {\n\t\ttokens.push(consumeAToken());\n\t\tif(iterationCount++ > str.length*2) throw new Error(\"The CSS Tokenizer is infinite-looping\");\n\t}\n\treturn tokens;\n}\n\nfunction CSSParserToken() { return this; }\nCSSParserToken.prototype.toJSON = function() {\n\treturn {token: this.tokenType};\n}\nCSSParserToken.prototype.toString = function() { return this.tokenType; }\nCSSParserToken.prototype.toCSSString = function() { return ''+this; }\n\nfunction BadStringToken() { return this; }\nBadStringToken.prototype = new CSSParserToken;\nBadStringToken.prototype.tokenType = \"BADSTRING\";\nBadStringToken.prototype.toCSSString = function() { return \"'\"; }\n\nfunction BadURLToken() { return this; }\nBadURLToken.prototype = new CSSParserToken;\nBadURLToken.prototype.tokenType = \"BADURL\";\nBadURLToken.prototype.toCSSString = function() { return \"url(\"; }\n\nfunction WhitespaceToken() { return this; }\nWhitespaceToken.prototype = new CSSParserToken;\nWhitespaceToken.prototype.tokenType = \"WHITESPACE\";\nWhitespaceToken.prototype.toString = function() { return \"WS\"; }\nWhitespaceToken.prototype.toCSSString = function() { return \" \"; }\n\nfunction CDOToken() { return this; }\nCDOToken.prototype = new CSSParserToken;\nCDOToken.prototype.tokenType = \"CDO\";\nCDOToken.prototype.toCSSString = function() { return \"<!--\"; }\n\nfunction CDCToken() { return this; }\nCDCToken.prototype = new CSSParserToken;\nCDCToken.prototype.tokenType = \"CDC\";\nCDCToken.prototype.toCSSString = function() { return \"-->\"; }\n\nfunction ColonToken() { return this; }\nColonToken.prototype = new CSSParserToken;\nColonToken.prototype.tokenType = \":\";\n\nfunction SemicolonToken() { return this; }\nSemicolonToken.prototype = new CSSParserToken;\nSemicolonToken.prototype.tokenType = \";\";\n\nfunction CommaToken() { return this; }\nCommaToken.prototype = new CSSParserToken;\nCommaToken.prototype.tokenType = \",\";\nCommaToken.prototype.value = \";\"; // backwards-compat with DELIM token\n\nfunction GroupingToken() { return this; }\nGroupingToken.prototype = new CSSParserToken;\n\nfunction OpenCurlyToken() { this.value = \"{\"; this.mirror = \"}\"; return this; }\nOpenCurlyToken.prototype = new GroupingToken;\nOpenCurlyToken.prototype.tokenType = \"{\";\n\nfunction CloseCurlyToken() { this.value = \"}\"; this.mirror = \"{\"; return this; }\nCloseCurlyToken.prototype = new GroupingToken;\nCloseCurlyToken.prototype.tokenType = \"}\";\n\nfunction OpenSquareToken() { this.value = \"[\"; this.mirror = \"]\"; return this; }\nOpenSquareToken.prototype = new GroupingToken;\nOpenSquareToken.prototype.tokenType = \"[\";\n\nfunction CloseSquareToken() { this.value = \"]\"; this.mirror = \"[\"; return this; }\nCloseSquareToken.prototype = new GroupingToken;\nCloseSquareToken.prototype.tokenType = \"]\";\n\nfunction OpenParenToken() { this.value = \"(\"; this.mirror = \")\"; return this; }\nOpenParenToken.prototype = new GroupingToken;\nOpenParenToken.prototype.tokenType = \"(\";\n\nfunction CloseParenToken() { this.value = \")\"; this.mirror = \"(\"; return this; }\nCloseParenToken.prototype = new GroupingToken;\nCloseParenToken.prototype.tokenType = \")\";\n\nfunction IncludeMatchToken() { return this; }\nIncludeMatchToken.prototype = new CSSParserToken;\nIncludeMatchToken.prototype.tokenType = \"~=\";\n\nfunction DashMatchToken() { return this; }\nDashMatchToken.prototype = new CSSParserToken;\nDashMatchToken.prototype.tokenType = \"|=\";\n\nfunction PrefixMatchToken() { return this; }\nPrefixMatchToken.prototype = new CSSParserToken;\nPrefixMatchToken.prototype.tokenType = \"^=\";\n\nfunction SuffixMatchToken() { return this; }\nSuffixMatchToken.prototype = new CSSParserToken;\nSuffixMatchToken.prototype.tokenType = \"$=\";\n\nfunction SubstringMatchToken() { return this; }\nSubstringMatchToken.prototype = new CSSParserToken;\nSubstringMatchToken.prototype.tokenType = \"*=\";\n\nfunction ColumnToken() { return this; }\nColumnToken.prototype = new CSSParserToken;\nColumnToken.prototype.tokenType = \"||\";\n\nfunction EOFToken() { return this; }\nEOFToken.prototype = new CSSParserToken;\nEOFToken.prototype.tokenType = \"EOF\";\nEOFToken.prototype.toCSSString = function() { return \"\"; }\n\nfunction DelimToken(code) {\n\tthis.value = stringFromCode(code);\n\treturn this;\n}\nDelimToken.prototype = new CSSParserToken;\nDelimToken.prototype.tokenType = \"DELIM\";\nDelimToken.prototype.toString = function() { return \"DELIM(\"+this.value+\")\"; }\nDelimToken.prototype.toCSSString = function() {\n\treturn (this.value == \"\\\\\") ? \"\\\\\\n\" : this.value;\n}\n\nfunction StringValuedToken() { return this; }\nStringValuedToken.prototype = new CSSParserToken;\nStringValuedToken.prototype.ASCIIMatch = function(str) {\n\treturn this.value.toLowerCase() == str.toLowerCase();\n}\n\nfunction IdentifierToken(val) {\n\tthis.value = val;\n}\nIdentifierToken.prototype = new StringValuedToken;\nIdentifierToken.prototype.tokenType = \"IDENT\";\nIdentifierToken.prototype.toString = function() { return \"IDENT(\"+this.value+\")\"; }\nIdentifierToken.prototype.toCSSString = function() {\n\treturn escapeIdent(this.value);\n}\n\nfunction FunctionToken(val) {\n\tthis.value = val;\n\tthis.mirror = \")\";\n}\nFunctionToken.prototype = new StringValuedToken;\nFunctionToken.prototype.tokenType = \"FUNCTION\";\nFunctionToken.prototype.toString = function() { return \"FUNCTION(\"+this.value+\")\"; }\nFunctionToken.prototype.toCSSString = function() {\n\treturn escapeIdent(this.value) + \"(\";\n}\n\t\nfunction AtKeywordToken(val) {\n\tthis.value = val;\n}\nAtKeywordToken.prototype = new StringValuedToken;\nAtKeywordToken.prototype.tokenType = \"AT-KEYWORD\";\nAtKeywordToken.prototype.toString = function() { return \"AT(\"+this.value+\")\"; }\nAtKeywordToken.prototype.toCSSString = function() {\n\treturn \"@\" + escapeIdent(this.value);\n}\n\nfunction HashToken(val) {\n\tthis.value = val;\n\tthis.type = \"unrestricted\";\n}\nHashToken.prototype = new StringValuedToken;\nHashToken.prototype.tokenType = \"HASH\";\nHashToken.prototype.toString = function() { return \"HASH(\"+this.value+\")\"; }\nHashToken.prototype.toCSSString = function() {\n\tvar escapeValue = (this.type == \"id\") ? escapeIdent : escapeHash;\n\treturn \"#\" + escapeValue(this.value);\n}\n\nfunction StringToken(val) {\nthis.value = val;\n}\nStringToken.prototype = new StringValuedToken;\nStringToken.prototype.tokenType = \"STRING\";\nStringToken.prototype.toString = function() {\n\treturn '\"' + escapeString(this.value) + '\"';\n}\n\nfunction URLToken(val) {\n\tthis.value = val;\n}\nURLToken.prototype = new StringValuedToken;\nURLToken.prototype.tokenType = \"URL\";\nURLToken.prototype.toString = function() { return \"URL(\"+this.value+\")\"; }\nURLToken.prototype.toCSSString = function() {\n\treturn 'url(\"' + escapeString(this.value) + '\")';\n}\n\nfunction NumberToken() {\n\tthis.value = null;\n\tthis.type = \"integer\";\n\tthis.repr = \"\";\n}\nNumberToken.prototype = new CSSParserToken;\nNumberToken.prototype.tokenType = \"NUMBER\";\nNumberToken.prototype.toString = function() {\n\tif(this.type == \"integer\")\n\t\treturn \"INT(\"+this.value+\")\";\n\treturn \"NUMBER(\"+this.value+\")\";\n}\nNumberToken.prototype.toJSON = function() {\n\tvar json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n\tjson.value = this.value;\n\tjson.type = this.type;\n\tjson.repr = this.repr;\n\treturn json;\n}\nNumberToken.prototype.toCSSString = function() { return this.repr; };\n\nfunction PercentageToken() {\n\tthis.value = null;\n\tthis.repr = \"\";\n}\nPercentageToken.prototype = new CSSParserToken;\nPercentageToken.prototype.tokenType = \"PERCENTAGE\";\nPercentageToken.prototype.toString = function() { return \"PERCENTAGE(\"+this.value+\")\"; }\nPercentageToken.prototype.toCSSString = function() { return this.repr + \"%\"; }\n\nfunction DimensionToken() {\n\tthis.value = null;\n\tthis.type = \"integer\";\n\tthis.repr = \"\";\n\tthis.unit = \"\";\n}\nDimensionToken.prototype = new CSSParserToken;\nDimensionToken.prototype.tokenType = \"DIMENSION\";\nDimensionToken.prototype.toString = function() { return \"DIM(\"+this.value+\",\"+this.unit+\")\"; }\nDimensionToken.prototype.toCSSString = function() {\n\tvar source = this.repr;\n\tvar unit = escapeIdent(this.unit);\n\tif(unit[0].toLowerCase() == \"e\" && (unit[1] == \"-\" || between(unit.charCodeAt(1), 0x30, 0x39))) {\n\t\t// Unit is ambiguous with scinot\n\t\t// Remove the leading \"e\", replace with escape.\n\t\tunit = \"\\\\65 \" + unit.slice(1, unit.length);\n\t}\n\treturn source+unit;\n}\n\nfunction escapeIdent(string) {\n\tstring = ''+string;\n\tvar result = '';\n\tvar firstcode = string.charCodeAt(0);\n\tfor(var i = 0; i < string.length; i++) {\n\t\tvar code = string.charCodeAt(i);\n\t\tif(code == 0x0) {\n\t\t\tthrow new InvalidCharacterError('Invalid character: the input contains U+0000.');\n\t\t}\n\n\t\tif(\n\t\t\tbetween(code, 0x1, 0x1f) || code == 0x7f ||\n\t\t\t(i == 0 && between(code, 0x30, 0x39)) ||\n\t\t\t(i == 1 && between(code, 0x30, 0x39) && firstcode == 0x2d)\n\t\t) {\n\t\t\tresult += '\\\\' + code.toString(16) + ' ';\n\t\t} else if(\n\t\t\tcode >= 0x80 ||\n\t\t\tcode == 0x2d ||\n\t\t\tcode == 0x5f ||\n\t\t\tbetween(code, 0x30, 0x39) ||\n\t\t\tbetween(code, 0x41, 0x5a) ||\n\t\t\tbetween(code, 0x61, 0x7a)\n\t\t) {\n\t\t\tresult += string[i];\n\t\t} else {\n\t\t\tresult += '\\\\' + string[i];\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction escapeHash(string) {\n\t// Escapes the contents of \"unrestricted\"-type hash tokens.\n\t// Won't preserve the ID-ness of \"id\"-type hash tokens;\n\t// use escapeIdent() for that.\n\tstring = ''+string;\n\tvar result = '';\n\tvar firstcode = string.charCodeAt(0);\n\tfor(var i = 0; i < string.length; i++) {\n\t\tvar code = string.charCodeAt(i);\n\t\tif(code == 0x0) {\n\t\t\tthrow new InvalidCharacterError('Invalid character: the input contains U+0000.');\n\t\t}\n\n\t\tif(\n\t\t\tcode >= 0x80 ||\n\t\t\tcode == 0x2d ||\n\t\t\tcode == 0x5f ||\n\t\t\tbetween(code, 0x30, 0x39) ||\n\t\t\tbetween(code, 0x41, 0x5a) ||\n\t\t\tbetween(code, 0x61, 0x7a)\n\t\t) {\n\t\t\tresult += string[i];\n\t\t} else {\n\t\t\tresult += '\\\\' + code.toString(16) + ' ';\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction escapeString(string) {\n\tstring = ''+string;\n\tvar result = '';\n\tfor(var i = 0; i < string.length; i++) {\n\t\tvar code = string.charCodeAt(i);\n\n\t\tif(code == 0x0) {\n\t\t\tthrow new InvalidCharacterError('Invalid character: the input contains U+0000.');\n\t\t}\n\n\t\tif(between(code, 0x1, 0x1f) || code == 0x7f) {\n\t\t\tresult += '\\\\' + code.toString(16) + ' ';\n\t\t} else if(code == 0x22 || code == 0x5c) {\n\t\t\tresult += '\\\\' + string[i];\n\t\t} else {\n\t\t\tresult += string[i];\n\t\t}\n\t}\n\treturn result;\n}\n\n// Exportation.\ncssSyntax.tokenize = tokenize;\ncssSyntax.IdentToken = IdentifierToken;\ncssSyntax.IdentifierToken = IdentifierToken;\ncssSyntax.FunctionToken = FunctionToken;\ncssSyntax.AtKeywordToken = AtKeywordToken;\ncssSyntax.HashToken = HashToken;\ncssSyntax.StringToken = StringToken;\ncssSyntax.BadStringToken = BadStringToken;\ncssSyntax.URLToken = URLToken;\ncssSyntax.BadURLToken = BadURLToken;\ncssSyntax.DelimToken = DelimToken;\ncssSyntax.NumberToken = NumberToken;\ncssSyntax.PercentageToken = PercentageToken;\ncssSyntax.DimensionToken = DimensionToken;\ncssSyntax.IncludeMatchToken = IncludeMatchToken;\ncssSyntax.DashMatchToken = DashMatchToken;\ncssSyntax.PrefixMatchToken = PrefixMatchToken;\ncssSyntax.SuffixMatchToken = SuffixMatchToken;\ncssSyntax.SubstringMatchToken = SubstringMatchToken;\ncssSyntax.ColumnToken = ColumnToken;\ncssSyntax.WhitespaceToken = WhitespaceToken;\ncssSyntax.CDOToken = CDOToken;\ncssSyntax.CDCToken = CDCToken;\ncssSyntax.ColonToken = ColonToken;\ncssSyntax.SemicolonToken = SemicolonToken;\ncssSyntax.CommaToken = CommaToken;\ncssSyntax.OpenParenToken = OpenParenToken;\ncssSyntax.CloseParenToken = CloseParenToken;\ncssSyntax.OpenSquareToken = OpenSquareToken;\ncssSyntax.CloseSquareToken = CloseSquareToken;\ncssSyntax.OpenCurlyToken = OpenCurlyToken;\ncssSyntax.CloseCurlyToken = CloseCurlyToken;\ncssSyntax.EOFToken = EOFToken;\ncssSyntax.CSSParserToken = CSSParserToken;\ncssSyntax.GroupingToken = GroupingToken;\n\n//\n// css parser\n//\n\nfunction TokenStream(tokens) {\n\t// Assume that tokens is an array.\n\tthis.tokens = tokens;\n\tthis.i = -1;\n}\nTokenStream.prototype.tokenAt = function(i) {\n\tif(i < this.tokens.length)\n\t\treturn this.tokens[i];\n\treturn new EOFToken();\n}\nTokenStream.prototype.consume = function(num) {\n\tif(num === undefined) num = 1;\n\tthis.i += num;\n\tthis.token = this.tokenAt(this.i);\n\t//console.log(this.i, this.token);\n\treturn true;\n}\nTokenStream.prototype.next = function() {\n\treturn this.tokenAt(this.i+1);\n}\nTokenStream.prototype.reconsume = function() {\n\tthis.i--;\n}\n\nfunction parseerror(s, msg) {\n\tconsole.log(\"Parse error at token \" + s.i + \": \" + s.token + \".\\n\" + msg);\n\treturn true;\n}\nfunction donothing(){ return true; };\n\nfunction consumeAListOfRules(s, topLevel) {\n\tvar rules = new TokenList();\n\tvar rule;\n\twhile(s.consume()) {\n\t\tif(s.token instanceof WhitespaceToken) {\n\t\t\tcontinue;\n\t\t} else if(s.token instanceof EOFToken) {\n\t\t\treturn rules;\n\t\t} else if(s.token instanceof CDOToken || s.token instanceof CDCToken) {\n\t\t\tif(topLevel == \"top-level\") continue;\n\t\t\ts.reconsume();\n\t\t\tif(rule = consumeAStyleRule(s)) rules.push(rule);\n\t\t} else if(s.token instanceof AtKeywordToken) {\n\t\t\ts.reconsume();\n\t\t\tif(rule = consumeAnAtRule(s)) rules.push(rule);\n\t\t} else {\n\t\t\ts.reconsume();\n\t\t\tif(rule = consumeAStyleRule(s)) rules.push(rule);\n\t\t}\n\t}\n}\n\nfunction consumeAnAtRule(s) {\n\ts.consume();\n\tvar rule = new AtRule(s.token.value);\n\twhile(s.consume()) {\n\t\tif(s.token instanceof SemicolonToken || s.token instanceof EOFToken) {\n\t\t\treturn rule;\n\t\t} else if(s.token instanceof OpenCurlyToken) {\n\t\t\trule.value = consumeASimpleBlock(s);\n\t\t\treturn rule;\n\t\t} else if(s.token instanceof SimpleBlock && s.token.name == \"{\") {\n\t\t\trule.value = s.token;\n\t\t\treturn rule;\n\t\t} else {\n\t\t\ts.reconsume();\n\t\t\trule.prelude.push(consumeAComponentValue(s));\n\t\t}\n\t}\n}\n\nfunction consumeAStyleRule(s) {\n\tvar rule = new StyleRule();\n\twhile(s.consume()) {\n\t\tif(s.token instanceof EOFToken) {\n\t\t\tparseerror(s, \"Hit EOF when trying to parse the prelude of a qualified rule.\");\n\t\t\treturn;\n\t\t} else if(s.token instanceof OpenCurlyToken) {\n\t\t\trule.value = consumeASimpleBlock(s);\n\t\t\treturn rule;\n\t\t} else if(s.token instanceof SimpleBlock && s.token.name == \"{\") {\n\t\t\trule.value = s.token;\n\t\t\treturn rule;\n\t\t} else {\n\t\t\ts.reconsume();\n\t\t\trule.prelude.push(consumeAComponentValue(s));\n\t\t}\n\t}\n}\n\nfunction consumeAListOfDeclarations(s) {\n\tvar decls = new TokenList();\n\twhile(s.consume()) {\n\t\tif(s.token instanceof WhitespaceToken || s.token instanceof SemicolonToken) {\n\t\t\tdonothing();\n\t\t} else if(s.token instanceof EOFToken) {\n\t\t\treturn decls;\n\t\t} else if(s.token instanceof AtKeywordToken) {\n\t\t\ts.reconsume();\n\t\t\tdecls.push(consumeAnAtRule(s));\n\t\t} else if(s.token instanceof IdentifierToken) {\n\t\t\tvar temp = [s.token];\n\t\t\twhile(!(s.next() instanceof SemicolonToken || s.next() instanceof EOFToken))\n\t\t\t\ttemp.push(consumeAComponentValue(s));\n\t\t\tvar decl;\n\t\t\tif(decl = consumeADeclaration(new TokenStream(temp))) decls.push(decl);\n\t\t} else {\n\t\t\tparseerror(s);\n\t\t\ts.reconsume();\n\t\t\twhile(!(s.next() instanceof SemicolonToken || s.next() instanceof EOFToken))\n\t\t\t\tconsumeAComponentValue(s);\n\t\t}\n\t}\n}\n\nfunction consumeADeclaration(s) {\n\t// Assumes that the next input token will be an ident token.\n\ts.consume();\n\tvar decl = new Declaration(s.token.value);\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\n\tif(!(s.next() instanceof ColonToken)) {\n\t\tparseerror(s);\n\t\treturn;\n\t} else {\n\t\ts.consume();\n\t}\n\twhile(!(s.next() instanceof EOFToken)) {\n\t\tdecl.value.push(consumeAComponentValue(s));\n\t}\n\tvar foundImportant = false;\n\tfor(var i = decl.value.length - 1; i >= 0; i--) {\n\t\tif(decl.value[i] instanceof WhitespaceToken) {\n\t\t\tcontinue;\n\t\t} else if(decl.value[i] instanceof IdentifierToken && decl.value[i].ASCIIMatch(\"important\")) {\n\t\t\tfoundImportant = true;\n\t\t} else if(foundImportant && decl.value[i] instanceof DelimToken && decl.value[i].value == \"!\") {\n\t\t\tdecl.value.splice(i, decl.value.length);\n\t\t\tdecl.important = true;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn decl;\n}\n\nfunction consumeAComponentValue(s) {\n\ts.consume();\n\tif(s.token instanceof OpenCurlyToken || s.token instanceof OpenSquareToken || s.token instanceof OpenParenToken)\n\t\treturn consumeASimpleBlock(s);\n\tif(s.token instanceof FunctionToken)\n\t\treturn consumeAFunction(s);\n\treturn s.token;\n}\n\nfunction consumeASimpleBlock(s) {\n\tvar mirror = s.token.mirror;\n\tvar block = new SimpleBlock(s.token.value);\n\twhile(s.consume()) {\n\t\tif(s.token instanceof EOFToken || (s.token instanceof GroupingToken && s.token.value == mirror))\n\t\t\treturn block;\n\t\telse {\n\t\t\ts.reconsume();\n\t\t\tblock.value.push(consumeAComponentValue(s));\n\t\t}\n\t}\n}\n\nfunction consumeAFunction(s) {\n\tvar func = new Func(s.token.value);\n\twhile(s.consume()) {\n\t\tif(s.token instanceof EOFToken || s.token instanceof CloseParenToken)\n\t\t\treturn func;\n\t\telse {\n\t\t\ts.reconsume();\n\t\t\tfunc.value.push(consumeAComponentValue(s));\n\t\t}\n\t}\n}\n\nfunction normalizeInput(input) {\n\tif(typeof input == \"string\")\n\t\treturn new TokenStream(tokenize(input));\n\tif(input instanceof TokenStream)\n\t\treturn input;\n\tif(input.length !== undefined)\n\t\treturn new TokenStream(input);\n\telse throw SyntaxError(input);\n}\n\nfunction parseAStylesheet(s) {\n\ts = normalizeInput(s);\n\tvar sheet = new Stylesheet();\n\tsheet.value = consumeAListOfRules(s, \"top-level\");\n\treturn sheet;\n}\n\nfunction parseAListOfRules(s) {\n\ts = normalizeInput(s);\n\treturn consumeAListOfRules(s);\n}\n\nfunction parseARule(s) {\n\ts = normalizeInput(s);\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\n\tif(s.next() instanceof EOFToken) throw SyntaxError();\n\tif(s.next() instanceof AtKeywordToken) {\n\t\tvar rule = consumeAnAtRule(s);\n\t} else {\n\t\tvar rule = consumeAStyleRule(s);\n\t\tif(!rule) throw SyntaxError();\n\t}\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\n\tif(s.next() instanceof EOFToken)\n\t\treturn rule;\n\tthrow SyntaxError();\n}\n\nfunction parseADeclaration(s) {\n\ts = normalizeInput(s);\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\n\tif(!(s.next() instanceof IdentifierToken)) throw SyntaxError();\n\tvar decl = consumeADeclaration(s);\n\tif(!decl) { throw new SyntaxError() }\n\treturn decl;\n}\n\nfunction parseAListOfDeclarations(s) {\n\ts = normalizeInput(s);\n\treturn consumeAListOfDeclarations(s);\n}\n\nfunction parseAComponentValue(s) {\n\ts = normalizeInput(s);\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\n\tif(s.next() instanceof EOFToken) throw SyntaxError();\n\tvar val = consumeAComponentValue(s);\n\tif(!val) throw SyntaxError();\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\n\tif(!(s.next() instanceof EOFToken)) throw new SyntaxError();\n\treturn val;\n}\n\nfunction parseAListOfComponentValues(s) {\n\ts = normalizeInput(s);\n\tvar vals = new TokenList();\n\twhile(true) {\n\t\tvar val = consumeAComponentValue(s);\n\t\tif(val instanceof EOFToken)\n\t\t\treturn vals\n\t\telse\n\t\t\tvals.push(val);\n\t}\n}\n\nfunction parseACommaSeparatedListOfComponentValues(s) {\n\ts = normalizeInput(s);\n\tvar listOfCVLs = new TokenList();\n\twhile(true) {\n\t\tvar vals = new TokenList();\n\t\twhile(true) {\n\t\t\tvar val = consumeAComponentValue(s);\n\t\t\tif(val instanceof EOFToken) {\n\t\t\t\tlistOfCVLs.push(vals);\n\t\t\t\treturn listOfCVLs;\n\t\t\t} else if(val instanceof CommaToken) {\n\t\t\t\tlistOfCVLs.push(vals);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tvals.push(val);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction CSSParserRule() { return this; }\nCSSParserRule.prototype.toString = function(indent) {\n\treturn JSON.stringify(this,null,indent);\n}\n\nfunction Stylesheet() {\n\tthis.value = new TokenList();\n\treturn this;\n}\nStylesheet.prototype = new CSSParserRule;\nStylesheet.prototype.type = \"STYLESHEET\";\nStylesheet.prototype.toCSSString = function() { return this.value.toCSSString(\"\\n\"); }\n\nfunction AtRule(name) {\n\tthis.name = name;\n\tthis.prelude = new TokenList();\n\tthis.value = null;\n\treturn this;\n}\nAtRule.prototype = new CSSParserRule;\nAtRule.prototype.toCSSString = function() { \n\tif(this.value) {\n\t\treturn \"@\" + escapeIdent(this.name) + \" \" + this.prelude.toCSSString() + this.value.toCSSString(); \n\t} else {\n\t\treturn \"@\" + escapeIdent(this.name) + \" \" + this.prelude.toCSSString() + '; '; \n\t}\n}\nAtRule.prototype.toStylesheet = function() {\n\treturn this.asStylesheet || (this.asStylesheet = this.value ? parseAStylesheet(this.value.value) : new Stylesheet());\n}\n\nfunction StyleRule() {\n\tthis.prelude = new TokenList(); this.selector = this.prelude;\n\tthis.value = null;\n\treturn this;\n}\nStyleRule.prototype = new CSSParserRule;\nStyleRule.prototype.type = \"STYLE-RULE\";\nStyleRule.prototype.toCSSString = function() {\n\treturn this.prelude.toCSSString() + this.value.toCSSString();\n}\nStyleRule.prototype.getSelector = function() {\n\treturn this.prelude;\n}\nStyleRule.prototype.getDeclarations = function() {\n\tif(!(this.value instanceof SimpleBlock)) { return new TokenList(); }\n\tvar value = this.value.value; return parseAListOfDeclarations(value);\n}\n\n\nfunction Declaration(name) {\n\tthis.name = name;\n\tthis.value = new TokenList();\n\tthis.important = false;\n\treturn this;\n}\nDeclaration.prototype = new CSSParserRule;\nDeclaration.prototype.type = \"DECLARATION\";\nDeclaration.prototype.toCSSString = function() {\n\treturn this.name + ':' + this.value.toCSSString() + '; ';\n}\n\nfunction SimpleBlock(type) {\n\tthis.name = type;\n\tthis.value = new TokenList();\n\treturn this;\n}\nSimpleBlock.prototype = new CSSParserRule;\nSimpleBlock.prototype.type = \"BLOCK\";\nSimpleBlock.prototype.toCSSString = function() {\n\tswitch(this.name) {\n\t\tcase \"(\":\n\t\t\treturn \"(\" + this.value.toCSSString() + \")\";\n\t\t\t\n\t\tcase \"[\":\n\t\t\treturn \"[\" + this.value.toCSSString() + \"]\";\n\t\t\t\n\t\tcase \"{\":\n\t\t\treturn \"{\" + this.value.toCSSString() + \"}\";\n\t\t\n\t\tdefault: //best guess\n\t\t\treturn this.name + this.value.toCSSString() + this.name;\n\t}\n}\n\nfunction Func(name) {\n\tthis.name = name;\n\tthis.value = new TokenList();\n\treturn this;\n}\nFunc.prototype = new CSSParserRule;\nFunc.prototype.type = \"FUNCTION\";\nFunc.prototype.toCSSString = function() {\n\treturn this.name+'('+this.value.toCSSString()+')';\n}\nFunc.prototype.getArguments = function() {\n\tvar args = new TokenList(); var arg = new TokenList(); var value = this.value;\n\tfor(var i = 0; i<value.length; i++) {\n\t\tif(value[i].tokenType == ',') {\n\t\t\targs.push(arg); arg = new TokenList();\n\t\t} else {\n\t\t\targ.push(value[i])\n\t\t}\n\t}\n\tif(args.length > 0 || arg.length > 0) { args.push(arg); }\n\treturn args;\n}\n\nfunction FuncArg() {\n\tthis.value = new TokenList();\n\treturn this;\n}\nFuncArg.prototype = new CSSParserRule;\nFuncArg.prototype.type = \"FUNCTION-ARG\";\nFuncArg.prototype.toCSSString = function() {\n\treturn this.value.toCSSString()+', ';\n}\n\n// Exportation.\ncssSyntax.CSSParserRule = CSSParserRule;\ncssSyntax.Stylesheet = Stylesheet;\ncssSyntax.AtRule = AtRule;\ncssSyntax.StyleRule = StyleRule;\ncssSyntax.Declaration = Declaration;\ncssSyntax.SimpleBlock = SimpleBlock;\ncssSyntax.Func = Func;\ncssSyntax.parseAStylesheet = parseAStylesheet;\ncssSyntax.parseAListOfRules = parseAListOfRules;\ncssSyntax.parseARule = parseARule;\ncssSyntax.parseADeclaration = parseADeclaration;\ncssSyntax.parseAListOfDeclarations = parseAListOfDeclarations;\ncssSyntax.parseAComponentValue = parseAComponentValue;\ncssSyntax.parseAListOfComponentValues = parseAListOfComponentValues;\ncssSyntax.parseACommaSeparatedListOfComponentValues = parseACommaSeparatedListOfComponentValues;\ncssSyntax.parse = parseAStylesheet;\ncssSyntax.parseCSSValue = parseAListOfComponentValues;\n\nreturn cssSyntax;\n\n}());\n\nrequire.define('src/core/css-syntax.js');","module.exports = (function(window, document) { \"use strict\";\n\n\trequire('src/core/polyfill-dom-console.js');\n\n\t//\n\t// some other basic om code\n\t//\n\tvar domEvents = {\n\t\t\n\t\t//\n\t\t// the following functions are about event cloning\n\t\t//\n\t\tcloneMouseEvent: function cloneMouseEvent(e) {\n\t\t\tvar evt = document.createEvent(\"MouseEvent\");\n\t\t\tevt.initMouseEvent( \n\t\t\t\te.type, \n\t\t\t\te.canBubble||e.bubbles, \n\t\t\t\te.cancelable, \n\t\t\t\te.view, \n\t\t\t\te.detail, \n\t\t\t\te.screenX, \n\t\t\t\te.screenY, \n\t\t\t\te.clientX, \n\t\t\t\te.clientY, \n\t\t\t\te.ctrlKey, \n\t\t\t\te.altKey, \n\t\t\t\te.shiftKey, \n\t\t\t\te.metaKey, \n\t\t\t\te.button, \n\t\t\t\te.relatedTarget\n\t\t\t);\n\t\t\treturn evt;\n\t\t},\n\t\t\n\t\tcloneKeyboardEvent: function cloneKeyboardEvent(e) {\n\t\t\t// TODO: this doesn't work cross-browser...\n\t\t\t// see https://gist.github.com/termi/4654819/ for the huge code\n\t\t\treturn domEvents.cloneCustomEvent(e);\n\t\t},\n\t\t\n\t\tcloneCustomEvent: function cloneCustomEvent(e) {\n\t\t\tvar ne = document.createEvent(\"CustomEvent\");\n\t\t\tne.initCustomEvent(e.type, e.canBubble||e.bubbles, e.cancelable, \"detail\" in e ? e.detail : e);\n\t\t\tfor(var prop in e) {\n\t\t\t\ttry {\n\t\t\t\t\tif(e[prop] != ne[prop] && e[prop] != e.target) {\n\t\t\t\t\t\ttry { ne[prop] = e[prop]; }\n\t\t\t\t\t\tcatch (ex) { Object.defineProperty(ne,prop,{get:function() { return e[prop]} }) }\n\t\t\t\t\t}\n\t\t\t\t} catch(ex) {}\n\t\t\t}\n\t\t\treturn ne;\n\t\t},\n\t\t\n\t\tcloneEvent: function cloneEvent(e) {\n\t\t\t\n\t\t\tif(e instanceof MouseEvent) {\n\t\t\t\treturn domEvents.cloneMouseEvent(e);\n\t\t\t} else if(e instanceof KeyboardEvent) {\n\t\t\t\treturn domEvents.cloneKeyboardEvent(e);\n\t\t\t} else {\n\t\t\t\treturn domEvents.cloneCustomEvent(e);\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// allows you to drop event support to any class easily\n\t\t//\n\t\tEventTarget: {\n\t\t\timplementsIn: function(eventClass, static_class) {\n\t\t\t\t\n\t\t\t\tif(!static_class && typeof(eventClass)==\"function\") eventClass=eventClass.prototype;\n\t\t\t\t\n\t\t\t\teventClass.dispatchEvent = domEvents.EventTarget.prototype.dispatchEvent;\n\t\t\t\teventClass.addEventListener = domEvents.EventTarget.prototype.addEventListener;\n\t\t\t\teventClass.removeEventListener = domEvents.EventTarget.prototype.removeEventListener;\n\t\t\t\t\n\t\t\t},\n\t\t\tprototype: {}\n\t\t}\n\t\t\n\t};\n\n\tdomEvents.EventTarget.prototype.addEventListener = function(eventType,f) {\n\t\tif(!this.eventListeners) this.eventListeners=[];\n\t\t\n\t\tvar ls = (this.eventListeners[eventType] || (this.eventListeners[eventType]=[]));\n\t\tif(ls.indexOf(f)==-1) {\n\t\t\tls.push(f);\n\t\t}\n\t\t\n\t}\n\n\tdomEvents.EventTarget.prototype.removeEventListener = function(eventType,f) {\n\t\tif(!this.eventListeners) this.eventListeners=[];\n\n\t\tvar ls = (this.eventListeners[eventType] || (this.eventListeners[eventType]=[])), i;\n\t\tif((i=ls.indexOf(f))!==-1) {\n\t\t\tls.splice(i,1);\n\t\t}\n\t\t\n\t}\n\n\tdomEvents.EventTarget.prototype.dispatchEvent = function(event_or_type) {\n\t\tif(!this.eventListeners) this.eventListeners=[];\n\t\t\n\t\t// abort quickly when no listener has been set up\n\t\tif(typeof(event_or_type) == \"string\") {\n\t\t\tif(!this.eventListeners[event_or_type] || this.eventListeners[event_or_type].length==0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif(!this.eventListeners[event_or_type.type] || this.eventListeners[event_or_type.type].length==0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// convert the event\n\t\tvar event = event_or_type;\n\t\tfunction setUpPropertyForwarding(e,ee,key) {\n\t\t\tObject.defineProperty(ee,key,{\n\t\t\t\tget:function() {\n\t\t\t\t\tvar v = e[key]; \n\t\t\t\t\tif(typeof(v)==\"function\") {\n\t\t\t\t\t\treturn v.bind(e);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn v;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tset:function(v) {\n\t\t\t\t\te[key] = v;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tfunction setUpTarget(e,v) {\n\t\t\ttry { Object.defineProperty(e,\"target\",{get:function() {return v}}); }\n\t\t\tcatch(ex) {}\n\t\t\tfinally {\n\t\t\t\t\n\t\t\t\tif(e.target !== v) {\n\t\t\t\t\t\n\t\t\t\t\tvar ee = Object.create(Object.getPrototypeOf(e));\n\t\t\t\t\tee = setUpTarget(ee,v);\n\t\t\t\t\tfor(key in e) {\n\t\t\t\t\t\tif(key != \"target\") setUpPropertyForwarding(e,ee,key);\n\t\t\t\t\t}\n\t\t\t\t\treturn ee;\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\treturn e;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t// try to set the target\n\t\tif(typeof(event)==\"object\") {\n\t\t\ttry { event=setUpTarget(event,this); } catch(ex) {}\n\t\t\t\n\t\t} else if(typeof(event)==\"string\") {\n\t\t\tevent = document.createEvent(\"CustomEvent\");\n\t\t\tevent.initCustomEvent(event_or_type, /*canBubble:*/ true, /*cancelable:*/ false, /*detail:*/this);\n\t\t\ttry { event=setUpTarget(event,this); } catch(ex) {}\n\t\t\t\n\t\t} else {\n\t\t\tthrow new Error(\"dispatchEvent expect an Event object or a string containing the event type\");\n\t\t}\n\t\t\n\t\t// call all listeners\n\t\tvar ls = (this.eventListeners[event.type] || (this.eventListeners[event.type]=[]));\n\t\tfor(var i=ls.length; i--;) {\n\t\t\ttry { \n\t\t\t\tls[i](event);\n\t\t\t} catch(ex) {\n\t\t\t\tsetImmediate(function() { throw ex; });\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn event.isDefaultPrevented;\n\t}\n\t\n\treturn domEvents;\n\t\n})(window, document);\nrequire.define('src/core/dom-events.js');","/////////////////////////////////////////////////////////////////\n////                                                         ////\n////                 prerequirements of qSL                  ////\n////                                                         ////\n/////////////////////////////////////////////////////////////////\n////                                                         ////\n////   Please note that I require querySelectorAll to work   ////\n////                                                         ////\n////   See http://github.com/termi/CSS_selector_engine/      ////\n////   for a polyfill for older browsers                     ////\n////                                                         ////\n/////////////////////////////////////////////////////////////////\n\n// TODO: improve event streams\n// - look for a few optimizations ideas in gecko/webkit\n// - use arrays in CompositeEventStream to avoid nested debouncings\nmodule.exports = (function(window, document) { \"use strict\";\n\n\t///\n\t/// event stream implementation\n\t/// please note this is required to 'live update' the qSA requests\n\t///\n\tfunction EventStream(connect, disconnect, reconnect) {\n\t\tvar self=this;\n\t\t\n\t\t// validate arguments\n\t\tif(!disconnect) disconnect=function(){};\n\t\tif(!reconnect) reconnect=connect;\n\t\t\n\t\t// high-level states\n\t\tvar isConnected=false;\n\t\tvar isDisconnected=false;\n\t\tvar shouldDisconnect=false;\n\t\t\n\t\t// global variables\n\t\tvar callback=null;\n\t\tvar yieldEvent = function() {\n\t\t\t\n\t\t\t// call the callback function, and pend disposal\n\t\t\tshouldDisconnect=true;\n\t\t\ttry { callback && callback(self); } catch(ex) { setImmediate(function() { throw ex; }); }\n\t\t\t\n\t\t\t// if no action was taken, dispose\n\t\t\tif(shouldDisconnect) { dispose(); }\n\t\t\t\n\t\t}\n\t\t\n\t\t// export the interface\n\t\tvar schedule = this.schedule = function(newCallback) {\n\t\t\n\t\t\t// do not allow to schedule on disconnected event streams\n\t\t\tif(isDisconnected) { throw new Error(\"Cannot schedule on a disconnected event stream\"); }\n\t\t\t\n\t\t\t// do not allow to schedule on already scheduled event streams\n\t\t\tif(isConnected && !shouldDisconnect) { throw new Error(\"Cannot schedule on an already-scheduled event stream\"); }\n\t\t\t\n\t\t\t// schedule the new callback\n\t\t\tcallback=newCallback; shouldDisconnect=false;\n\t\t\t\n\t\t\t// reconnect to the stream\n\t\t\tif(isConnected) {\n\t\t\t\treconnect(yieldEvent);\n\t\t\t} else {\n\t\t\t\tconnect(yieldEvent);\n\t\t\t\tisConnected=true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar dispose = this.dispose = function() {\n\t\t\n\t\t\t// do not allow to dispose non-connected streams\n\t\t\tif(isConnected) {\n\t\t\t\n\t\t\t\t// disconnect & save resources\n\t\t\t\tdisconnect(); \n\t\t\t\tself=null; yieldEvent=null; callback=null; \n\t\t\t\tisConnected=false; isDisconnected=true; shouldDisconnect=false;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\n\t///\n\t/// call a function every frame\n\t///\n\tfunction AnimationFrameEventStream(options) {\n\t\t\n\t\t// flag that says whether the observer is still needed or not\n\t\tvar rid = 0;\n\t\t\t\n\t\t// start the event stream\n\t\tEventStream.call(\n\t\t\tthis, \n\t\t\tfunction connect(yieldEvent) { rid = requestAnimationFrame(yieldEvent); },\n\t\t\tfunction disconnect() { cancelAnimationFrame(rid); }\n\t\t);\n\t\t\n\t}\n\n\t///\n\t/// call a function every timeout\n\t///\n\tfunction TimeoutEventStream(options) {\n\t\t\n\t\t// flag that says whether the observer is still needed or not\n\t\tvar rid = 0; var timeout=(typeof(options)==\"number\") ? (+options) : (\"timeout\" in options ? +options.timeout : 333);\n\t\t\t\n\t\t// start the event stream\n\t\tEventStream.call(\n\t\t\tthis, \n\t\t\tfunction connect(yieldEvent) { rid = setTimeout(yieldEvent, timeout); },\n\t\t\tfunction disconnect() { clearTimeout(rid); }\n\t\t);\n\t\t\n\t}\n\n\t///\n\t/// call a function every time the mouse moves\n\t///\n\tfunction MouseEventStream() {\n\t\tvar self=this; var pointermove = ((\"PointerEvent\" in window) ? \"pointermove\" : ((\"MSPointerEvent\" in window) ? \"MSPointerMove\" : \"mousemove\"));\n\n\t\t// flag that says whether the event is still observed or not\n\t\tvar scheduled = false; var interval=0;\n\t\t\n\t\t// handle the synchronous nature of mutation events\n\t\tvar yieldEvent=null;\n\t\tvar yieldEventDelayed = function() {\n\t\t\tif(scheduled) return;\n\t\t\twindow.removeEventListener(pointermove, yieldEventDelayed, true);\n\t\t\tscheduled = requestAnimationFrame(yieldEvent);\n\t\t}\n\t\t\n\t\t// start the event stream\n\t\tEventStream.call(\n\t\t\tthis, \n\t\t\tfunction connect(newYieldEvent) {\n\t\t\t\tyieldEvent=newYieldEvent;\n\t\t\t\twindow.addEventListener(pointermove, yieldEventDelayed, true);\n\t\t\t},\n\t\t\tfunction disconnect() { \n\t\t\t\twindow.removeEventListener(pointermove, yieldEventDelayed, true);\n\t\t\t\tcancelAnimationFrame(scheduled); yieldEventDelayed=null; yieldEvent=null; scheduled=false;\n\t\t\t},\n\t\t\tfunction reconnect(newYieldEvent) { \n\t\t\t\tyieldEvent=newYieldEvent; scheduled=false;\n\t\t\t\twindow.addEventListener(pointermove, yieldEventDelayed, true);\n\t\t\t}\n\t\t);\n\t\t\n\t}\n\n\t///\n\t/// call a function every time the mouse is clicked/unclicked\n\t///\n\tfunction MouseButtonEventStream() {\n\t\tvar self=this; \n\t\tvar pointerup = ((\"PointerEvent\" in window) ? \"pointerup\" : ((\"MSPointerEvent\" in window) ? \"MSPointerUp\" : \"mouseup\"));\n\t\tvar pointerdown = ((\"PointerEvent\" in window) ? \"pointerdown\" : ((\"MSPointerEvent\" in window) ? \"MSPointerDown\" : \"mousedown\"));\n\n\t\t// flag that says whether the event is still observed or not\n\t\tvar scheduled = false; var interval=0;\n\t\t\n\t\t// handle the synchronous nature of mutation events\n\t\tvar yieldEvent=null;\n\t\tvar yieldEventDelayed = function() {\n\t\t\tif(scheduled) return;\n\t\t\twindow.removeEventListener(pointerup, yieldEventDelayed, true);\n\t\t\twindow.removeEventListener(pointerdown, yieldEventDelayed, true);\n\t\t\tscheduled = requestAnimationFrame(yieldEvent);\n\t\t}\n\t\t\n\t\t// start the event stream\n\t\tEventStream.call(\n\t\t\tthis, \n\t\t\tfunction connect(newYieldEvent) {\n\t\t\t\tyieldEvent=newYieldEvent;\n\t\t\t\twindow.addEventListener(pointerup, yieldEventDelayed, true);\n\t\t\t\twindow.addEventListener(pointerdown, yieldEventDelayed, true);\n\t\t\t},\n\t\t\tfunction disconnect() { \n\t\t\t\twindow.removeEventListener(pointerup, yieldEventDelayed, true);\n\t\t\t\twindow.removeEventListener(pointerdown, yieldEventDelayed, true);\n\t\t\t\tcancelAnimationFrame(scheduled); yieldEventDelayed=null; yieldEvent=null; scheduled=false;\n\t\t\t},\n\t\t\tfunction reconnect(newYieldEvent) { \n\t\t\t\tyieldEvent=newYieldEvent; scheduled=false;\n\t\t\t\twindow.addEventListener(pointerup, yieldEventDelayed, true);\n\t\t\t\twindow.addEventListener(pointerdown, yieldEventDelayed, true);\n\t\t\t}\n\t\t);\n\t\t\n\t}\n\n\t///\n\t/// call a function whenever the DOM is modified\n\t///\n\tvar DOMUpdateEventStream;\n\tif(\"MutationObserver\" in window) {\n\t\tDOMUpdateEventStream = function DOMUpdateEventStream(options) {\n\t\t\t \n\t\t\t// configuration of the observer\n\t\t\tif(options) {\n\t\t\t\tvar target = \"target\" in options ? options.target : document.documentElement;\n\t\t\t\tvar config = { \n\t\t\t\t\tsubtree: \"subtree\" in options ? !!options.subtree : true, \n\t\t\t\t\tattributes: \"attributes\" in options ? !!options.attributes : true, \n\t\t\t\t\tchildList: \"childList\" in options ? !!options.childList : true, \n\t\t\t\t\tcharacterData: \"characterData\" in options ? !!options.characterData : false\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tvar target = document.documentElement;\n\t\t\t\tvar config = { \n\t\t\t\t\tsubtree: true, \n\t\t\t\t\tattributes: true, \n\t\t\t\t\tchildList: true, \n\t\t\t\t\tcharacterData: false\n\t\t\t\t};\n\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t// start the event stream\n\t\t\tvar observer = null;\n\t\t\tEventStream.call(\n\t\t\t\tthis, \n\t\t\t\tfunction connect(yieldEvent) { if(config) { observer=new MutationObserver(yieldEvent); observer.observe(target,config); target=null; config=null; } },\n\t\t\t\tfunction disconnect() { observer && observer.disconnect(); observer=null; },\n\t\t\t\tfunction reconnect() { observer.takeRecords(); }\n\t\t\t);\n\n\t\t}\n\t} else if(\"MutationEvent\" in window) {\n\t\tDOMUpdateEventStream = function DOMUpdateEventStream(options) {\n\t\t\tvar self=this;\n\n\t\t\t// flag that says whether the event is still observed or not\n\t\t\tvar scheduled = false;\n\t\t\t\n\t\t\t// configuration of the observer\n\t\t\tif(options) {\n\t\t\t\tvar target = \"target\" in options ? options.target : document.documentElement;\n\t\t\t} else {\n\t\t\t\tvar target = document.documentElement;\n\t\t\t}\n\t\t\t\n\t\t\t// handle the synchronous nature of mutation events\n\t\t\tvar yieldEvent=null;\n\t\t\tvar yieldEventDelayed = function() {\n\t\t\t\tif(scheduled || !yieldEventDelayed) return;\n\t\t\t\tdocument.removeEventListener(\"DOMContentLoaded\", yieldEventDelayed, false);\n\t\t\t\tdocument.removeEventListener(\"DOMContentLoaded\", yieldEventDelayed, false);\n\t\t\t\ttarget.removeEventListener(\"DOMSubtreeModified\", yieldEventDelayed, false);\n\t\t\t\tscheduled = requestAnimationFrame(yieldEvent);\n\t\t\t}\n\t\t\t\n\t\t\t// start the event stream\n\t\t\tEventStream.call(\n\t\t\t\tthis, \n\t\t\t\tfunction connect(newYieldEvent) {\n\t\t\t\t\tyieldEvent=newYieldEvent;\n\t\t\t\t\tdocument.addEventListener(\"DOMContentLoaded\", yieldEventDelayed, false);\n\t\t\t\t\ttarget.addEventListener(\"DOMSubtreeModified\", yieldEventDelayed, false);\n\t\t\t\t},\n\t\t\t\tfunction disconnect() { \n\t\t\t\t\tdocument.removeEventListener(\"DOMContentLoaded\", yieldEventDelayed, false);\n\t\t\t\t\ttarget.removeEventListener(\"DOMSubtreeModified\", yieldEventDelayed, false);\n\t\t\t\t\tcancelAnimationFrame(scheduled); yieldEventDelayed=null; yieldEvent=null; scheduled=false;\n\t\t\t\t},\n\t\t\t\tfunction reconnect(newYieldEvent) { \n\t\t\t\t\tyieldEvent=newYieldEvent; scheduled=false;\n\t\t\t\t\ttarget.addEventListener(\"DOMSubtreeModified\", yieldEventDelayed, false);\n\t\t\t\t}\n\t\t\t);\n\t\t\t\n\t\t}\n\t} else {\n\t\tDOMUpdateEventStream = AnimationFrameEventStream;\n\t}\n\n\t///\n\t/// call a function every time the focus shifts\n\t///\n\tfunction FocusEventStream() {\n\t\tvar self=this;\n\t\t\n\t\t// handle the filtering nature of focus events\n\t\tvar yieldEvent=null; var previousActiveElement=null; var previousHasFocus=false; var rid=0;\n\t\tvar yieldEventDelayed = function() {\n\t\t\t\n\t\t\t// if the focus didn't change\n\t\t\tif(previousActiveElement==document.activeElement && previousHasFocus==document.hasFocus()) {\n\t\t\t\t\n\t\t\t\t// then do not generate an event\n\t\t\t\tsetTimeout(yieldEventDelayed, 333); // focus that didn't move is expected to stay\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// else, generate one & save config\n\t\t\t\tpreviousActiveElement=document.activeElement;\n\t\t\t\tpreviousHasFocus=document.hasFocus();\n\t\t\t\tyieldEvent();\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t// start the event stream\n\t\tEventStream.call(\n\t\t\tthis, \n\t\t\tfunction connect(newYieldEvent) {\n\t\t\t\tyieldEvent=newYieldEvent;\n\t\t\t\trid=setTimeout(yieldEventDelayed, 500); // let the document load\n\t\t\t},\n\t\t\tfunction disconnect() { \n\t\t\t\tclearTimeout(rid); yieldEventDelayed=null; yieldEvent=null; rid=0;\n\t\t\t},\n\t\t\tfunction reconnect(newYieldEvent) { \n\t\t\t\tyieldEvent=newYieldEvent;\n\t\t\t\trid=setTimeout(yieldEventDelayed, 100); // focus by tab navigation moves fast\n\t\t\t}\n\t\t);\n\t\t\n\t}\n\n\t///\n\t/// composite event stream\n\t/// because sometimes you need more than one event source\n\t///\n\tfunction CompositeEventStream(stream1, stream2) {\n\t\tvar self=this;\n\t\t\n\t\t// fields\n\t\tvar yieldEvent=null; var s1=false, s2=false;\n\t\tvar yieldEventWrapper=function(s) { \n\t\t\tif(s==stream1) s1=true;\n\t\t\tif(s==stream2) s2=true;\n\t\t\tif(s1&&s2) return;\n\t\t\tyieldEvent(self);\n\t\t}\n\t\t\n\t\t// start the event stream\n\t\tEventStream.call(\n\t\t\tthis, \n\t\t\tfunction connect(newYieldEvent) {\n\t\t\t\tyieldEvent=newYieldEvent;\n\t\t\t\tstream1.schedule(yieldEventWrapper);\n\t\t\t\tstream2.schedule(yieldEventWrapper);\n\t\t\t},\n\t\t\tfunction disconnect() { \n\t\t\t\tstream1.dispose();\n\t\t\t\tstream2.dispose();\n\t\t\t},\n\t\t\tfunction reconnect(newYieldEvent) { \n\t\t\t\tyieldEvent=newYieldEvent;\n\t\t\t\ts1 && stream1.schedule(yieldEventWrapper);\n\t\t\t\ts2 && stream2.schedule(yieldEventWrapper);\n\t\t\t\ts1 = s2 = false;\n\t\t\t}\n\t\t);\n\t}\n\t\n\treturn {\n\t\tEventStream:                EventStream,\n\t\tAnimationFrameEventStream:  AnimationFrameEventStream,\n\t\tTimeoutEventStream:         TimeoutEventStream,\n\t\tMouseEventStream:           MouseEventStream,\n\t\tMouseButtonEventStream:     MouseButtonEventStream,\n\t\tDOMUpdateEventStream:       DOMUpdateEventStream,\n\t\tFocusEventStream:           FocusEventStream,\n\t\tCompositeEventStream:       CompositeEventStream\n\t};\n\n})(window, document);\nrequire.define('src/core/dom-experimental-event-streams.js');","/////////////////////////////////////////////////////////////////\n////                                                         ////\n////                  Implementation of qSL                  ////\n////                                                         ////\n/////////////////////////////////////////////////////////////////\n////                                                         ////\n////   Please note that I require querySelectorAll to work   ////\n////                                                         ////\n////   See http://github.com/termi/CSS_selector_engine/      ////\n////   for a polyfill for older browsers                     ////\n////                                                         ////\n/////////////////////////////////////////////////////////////////\n\nmodule.exports = (function(window, document) { \"use strict\";\n\n\t// import dependencies\n\tvar eventStreams = require('src/core/dom-experimental-event-streams.js'),\n\t    DOMUpdateEventStream = eventStreams.DOMUpdateEventStream,\n\t\tAnimationFrameEventStream = eventStreams.AnimationFrameEventStream,\n\t\tCompositeEventStream = eventStreams.CompositeEventStream,\n\t\tFocusEventStream = eventStreams.FocusEventStream,\n\t\tMouseButtonEventStream = eventStreams.MouseButtonEventStream,\n\t\tTimeoutEventStream = eventStreams.TimeoutEventStream,\n\t\tMouseEventStream = eventStreams.MouseEventStream;\n\n\t///\n\t/// the live querySelectorAll implementation\n\t///\n\tfunction querySelectorLive(selector, handler, root) {\n\t\t\n\t\t// restrict the selector coverage to some part of the DOM only\n\t\tvar root = root || document;\n\t\t\n\t\t// TODO: make use of \"mutatedAncestorElement\" to update only elements inside the mutated zone\n\t\t\n\t\tvar currentElms = [];\n\t\tvar loop = function loop(eventStream) {\n\t\t\t\n\t\t\t// schedule next run\n\t\t\teventStream.schedule(loop);\n\t\t\t\n\t\t\t// update elements matching the selector\n\t\t\tvar newElms = [];\n\t\t\tvar oldElms = currentElms.slice(0);\n\t\t\tvar temps = root.querySelectorAll(selector);\n\t\t\tfor(var i=newElms.length=temps.length; i;) { newElms.push(temps[--i]); }\n\t\t\tcurrentElms = newElms.slice(0); temps=null;\n\t\t\t\n\t\t\t// first let's clear all elements that have been removed from the document\n\t\t\toldElms = oldElms.filter(function(e) {\n\t\t\t\t\n\t\t\t\t// check whether the current element is still there\n\t\t\t\tvar isStillInDocument = (\n\t\t\t\t\te===document.documentElement \n\t\t\t\t\t|| document.documentElement.contains(e)\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\tif(isStillInDocument) {\n\t\t\t\t\t\n\t\t\t\t\t// NEED_COMPARE: we will compare this element to the new list\n\t\t\t\t\treturn true;\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\t// DELETE: raise onremoved, pop old elements\n\t\t\t\t\ttry { handler.onremoved && handler.onremoved(e); } catch(ex) { setImmediate(function() {throw ex})}\n\t\t\t\t\treturn false;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t\t// now pop and match until both lists are exhausted\n\t\t\t// (we use the fact the returned elements are in document order)\n\t\t\tvar el1 = oldElms.pop();\n\t\t\tvar el2 = newElms.pop();\n\t\t\twhile(el1 || el2) {\n\t\t\t\tif(el1===el2) {\n\t\t\t\t\n\t\t\t\t\t// MATCH: pop both elements\n\t\t\t\t\tel1 = oldElms.pop();\n\t\t\t\t\tel2 = newElms.pop();\n\t\t\t\t\t\n\t\t\t\t} else if (el2 && /*el1 is after el2*/(!el1||(el2.compareDocumentPosition(el1) & (1|2|8|32))===0)) {\n\t\t\t\t\t\n\t\t\t\t\t// INSERT: raise onadded, pop new elements\n\t\t\t\t\ttry { handler.onadded && handler.onadded(el2); } catch(ex) { setImmediate(function() {throw ex})}\n\t\t\t\t\tel2 = newElms.pop();\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\n\t\t\t\t\t// DELETE: raise onremoved, pop old elements\n\t\t\t\t\ttry { handler.onremoved && handler.onremoved(el1); } catch(ex) { setImmediate(function() {throw ex})}\n\t\t\t\t\tel1 = oldElms.pop();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t};\n\t\t\n\t\t// use the event stream that best matches our needs\n\t\tvar simpleSelector = selector.replace(/:(dir|lang|root|empty|blank|nth-child|nth-last-child|first-child|last-child|only-child|nth-of-type|nth-last-of-child|fist-of-type|last-of-type|only-of-type|not|matches|default)\\b/gi,'')\n\t\tvar eventStream; if(simpleSelector.indexOf(':') == -1) {\n\t\t\t\n\t\t\t// static stuff only\n\t\t\teventStream = new DOMUpdateEventStream({target:root}); \n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\t// dynamic stuff too\n\t\t\teventStream = new DOMUpdateEventStream({target:root}); \n\t\t\tif(DOMUpdateEventStream != AnimationFrameEventStream) {\n\t\t\t\n\t\t\t\t// detect the presence of focus-related pseudo-classes\n\t\t\t\tvar reg = /:(focus|active)\\b/gi;\n\t\t\t\tif(reg.test(simpleSelector)) {\n\t\t\t\t\t\n\t\t\t\t\t// mouse events should be listened\n\t\t\t\t\teventStream = new CompositeEventStream(\n\t\t\t\t\t\tnew FocusEventStream(),\n\t\t\t\t\t\teventStream\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\t// simplify simpleSelector\n\t\t\t\t\tvar reg = /:(focus)\\b/gi;\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, ''); // :active has other hooks\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// detect the presence of mouse-button-related pseudo-classes\n\t\t\t\tvar reg = /:(active)\\b/gi;\n\t\t\t\tif(reg.test(simpleSelector)) {\n\t\t\t\t\t\n\t\t\t\t\t// mouse events should be listened\n\t\t\t\t\teventStream = new CompositeEventStream(\n\t\t\t\t\t\tnew MouseButtonEventStream(),\n\t\t\t\t\t\teventStream\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\t// simplify simpleSelector\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\t// detect the presence of user input pseudo-classes\n\t\t\t\tvar reg = /:(target|checked|indeterminate|valid|invalid|in-range|out-of-range|user-error)\\b/gi;\n\t\t\t\tif(reg.test(simpleSelector)) {\n\t\t\t\t\t\n\t\t\t\t\t// slowly dynamic stuff do happen\n\t\t\t\t\teventStream = new CompositeEventStream(\n\t\t\t\t\t\tnew TimeoutEventStream(250),\n\t\t\t\t\t\teventStream\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\t// simplify simpleSelector\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\n\n\t\t\t\t\tvar reg = /:(any-link|link|visited|local-link|enabled|disabled|read-only|read-write|required|optional)\\b/gi;\n\t\t\t\t\t// simplify simpleSelector\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// detect the presence of nearly-static pseudo-classes\n\t\t\t\tvar reg = /:(any-link|link|visited|local-link|enabled|disabled|read-only|read-write|required|optional)\\b/gi;\n\t\t\t\tif(reg.test(simpleSelector)) {\n\t\t\t\t\t\n\t\t\t\t\t// nearly static stuff do happen\n\t\t\t\t\teventStream = new CompositeEventStream(\n\t\t\t\t\t\tnew TimeoutEventStream(333),\n\t\t\t\t\t\teventStream\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\t// simplify simpleSelector\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// detect the presence of mouse-related pseudo-classes\n\t\t\t\tvar reg = /:(hover)\\b/gi;\n\t\t\t\tif(reg.test(simpleSelector)) {\n\t\t\t\t\t\n\t\t\t\t\t// mouse events should be listened\n\t\t\t\t\teventStream = new CompositeEventStream(\n\t\t\t\t\t\tnew MouseEventStream(),\n\t\t\t\t\t\teventStream\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\t// simplify simpleSelector\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// detect the presence of unknown pseudo-classes\n\t\t\t\tif(simpleSelector.indexOf(':') !== -1) {\n\t\t\t\t\t\n\t\t\t\t\t// other stuff do happen, too (let's give up on events)\n\t\t\t\t\teventStream = new AnimationFrameEventStream(); \n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t// start handling changes\n\t\tloop(eventStream);\n\t\t\n\t}\n\t\n\treturn querySelectorLive;\n\t\n})(window, document);\nrequire.define('src/core/dom-query-selector-live.js');","// TODO: comment about the 'no_auto_stylesheet_detection' flag?\n\nmodule.exports = (function(window, document) { \"use strict\";\n\t\n\t// import dependencies\n\trequire('src/core/polyfill-dom-console.js');\n\trequire('src/core/polyfill-dom-requestAnimationFrame.js');\n\tvar cssSyntax = require('src/core/css-syntax.js');\n\tvar domEvents = require('src/core/dom-events.js');\n\tvar querySelectorLive = require('src/core/dom-query-selector-live.js');\n\t\n\t// define the module\n\tvar cssCascade = {\n\t\t\n\t\t//\n\t\t// returns the priority of a unique selector (NO COMMA!)\n\t\t// { the return value is an integer, with the same formula as webkit }\n\t\t//\n\t\tcomputeSelectorPriorityOf: function computeSelectorPriorityOf(selector) {\n\t\t\tif(typeof selector == \"string\") selector = cssSyntax.parse(selector.trim()+\"{}\").value[0].selector;\n\t\t\t\n\t\t\tvar numberOfIDs = 0;\n\t\t\tvar numberOfClasses = 0;\n\t\t\tvar numberOfTags = 0;\n\t\t\t\n\t\t\t// TODO: improve this parser, or find one on the web\n\t\t\tfor(var i = 0; i < selector.length; i++) {\n\t\t\t\t\n\t\t\t\tif(selector[i] instanceof cssSyntax.IdentifierToken) {\n\t\t\t\t\tnumberOfTags++;\n\t\t\t\t\t\n\t\t\t\t} else if(selector[i] instanceof cssSyntax.DelimToken) {\n\t\t\t\t\tif(selector[i].value==\".\") {\n\t\t\t\t\t\tnumberOfClasses++; i++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else if(selector[i] instanceof cssSyntax.ColonToken) {\n\t\t\t\t\tif(selector[++i] instanceof cssSyntax.ColonToken) {\n\t\t\t\t\t\tnumberOfTags++; i++;\n\t\t\t\t\t\t\n\t\t\t\t\t} else if((selector[i] instanceof cssSyntax.Func) && (/^(not|matches)$/i).test(selector[i].name)) {\n\t\t\t\t\t\tvar nestedPriority = this.computeSelectorPriorityOf(selector[i].value);\n\t\t\t\t\t\tnumberOfTags += nestedPriority % 256; nestedPriority /= 256;\n\t\t\t\t\t\tnumberOfClasses += nestedPriority % 256; nestedPriority /= 256;\n\t\t\t\t\t\tnumberOfIDs += nestedPriority;\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnumberOfClasses++;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else if(selector[i] instanceof cssSyntax.SimpleBlock) {\n\t\t\t\t\tif(selector[i].name==\"[\") {\n\t\t\t\t\t\tnumberOfClasses++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else if(selector[i] instanceof cssSyntax.HashToken) {\n\t\t\t\t\tnumberOfIDs++;\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t// TODO: stop ignoring unknown symbols?\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(numberOfIDs>255) numberOfIds=255;\n\t\t\tif(numberOfClasses>255) numberOfClasses=255;\n\t\t\tif(numberOfTags>255) numberOfTags=255;\n\t\t\t\n\t\t\treturn ((numberOfIDs*256)+numberOfClasses)*256+numberOfTags;\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// returns an array of the css rules matching an element\n\t\t//\n\t\tfindAllMatchingRules: function findAllMatchingRules(element) {\n\t\t\treturn this.findAllMatchingRulesWithPseudo(element);\n\t\t},\n\t\t\n\t\t//\n\t\t// returns an array of the css rules matching a pseudo-element\n\t\t//\n\t\tfindAllMatchingRulesWithPseudo: function findAllMatchingRules(element,pseudo) {\n\t\t\tpseudo = pseudo ? (''+pseudo).toLowerCase() : pseudo;\n\t\t\t\n\t\t\t// let's look for new results if needed...\n\t\t\tvar results = [];\n\t\t\t\n\t\t\t// walk the whole stylesheet...\n\t\t\tvar visit = function(rules) {\n\t\t\t\ttry {\n\t\t\t\t\tfor(var r = rules.length; r--; ) {\n\t\t\t\t\t\tvar rule = rules[r]; \n\t\t\t\t\t\t\n\t\t\t\t\t\t// media queries hook\n\t\t\t\t\t\tif(rule.disabled) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(rule instanceof cssSyntax.StyleRule) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// consider each selector independently\n\t\t\t\t\t\t\tvar subrules = rule.subRules || cssCascade.splitRule(rule);\n\t\t\t\t\t\t\tfor(var sr = subrules.length; sr--; ) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tvar selector = subrules[sr].selector.toCSSString().replace(/ *(\\/\\*\\*\\/|  ) */g,' ').trim();\n\t\t\t\t\t\t\t\tif(pseudo) {\n\t\t\t\t\t\t\t\t\t// WE ONLY ACCEPT SELECTORS ENDING WITH THE PSEUDO\n\t\t\t\t\t\t\t\t\tvar selectorLow = selector.toLowerCase();\n\t\t\t\t\t\t\t\t\tvar newLength = selector.length-pseudo.length-1;\n\t\t\t\t\t\t\t\t\tif(newLength<=0) continue;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(selectorLow.lastIndexOf('::'+pseudo)==newLength-1) {\n\t\t\t\t\t\t\t\t\t\tselector = selector.substr(0,newLength-1);\n\t\t\t\t\t\t\t\t\t} else if(selectorLow.lastIndexOf(':'+pseudo)==newLength) {\n\t\t\t\t\t\t\t\t\t\tselector = selector.substr(0,newLength);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// fix selectors like \"#element > :first-child ~ ::before\"\n\t\t\t\t\t\t\t\t\tif(selector.trim().length == 0) { selector = '*' }\n\t\t\t\t\t\t\t\t\telse if(selector[selector.length-1] == ' ') { selector += '*' }\n\t\t\t\t\t\t\t\t\telse if(selector[selector.length-1] == '+') { selector += '*' }\n\t\t\t\t\t\t\t\t\telse if(selector[selector.length-1] == '>') { selector += '*' }\n\t\t\t\t\t\t\t\t\telse if(selector[selector.length-1] == '~') { selector += '*' }\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// look if the selector matches\n\t\t\t\t\t\t\t\tvar isMatching = false;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tif(element.matches) isMatching=element.matches(selector)\n\t\t\t\t\t\t\t\t\telse if(element.matchesSelector) isMatching=element.matchesSelector(selector)\n\t\t\t\t\t\t\t\t\telse if(element.oMatchesSelector) isMatching=element.oMatchesSelector(selector)\n\t\t\t\t\t\t\t\t\telse if(element.msMatchesSelector) isMatching=element.msMatchesSelector(selector)\n\t\t\t\t\t\t\t\t\telse if(element.mozMatchesSelector) isMatching=element.mozMatchesSelector(selector)\n\t\t\t\t\t\t\t\t\telse if(element.webkitMatchesSelector) isMatching=element.webkitMatchesSelector(selector)\n\t\t\t\t\t\t\t\t\telse { throw new Error(\"no element.matches?\") }\n\t\t\t\t\t\t\t\t} catch(ex) { debugger; setImmediate(function() { throw ex; }) }\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// if yes, add it to the list of matched selectors\n\t\t\t\t\t\t\t\tif(isMatching) { results.push(subrules[sr]); }\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else if(rule instanceof cssSyntax.AtRule && rule.name==\"media\") {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// visit them\n\t\t\t\t\t\t\tvisit(rule.toStylesheet().value);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tsetImmediate(function() { throw ex; });\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(var s=cssCascade.stylesheets.length; s--; ) {\n\t\t\t\tvar rules = cssCascade.stylesheets[s];\n\t\t\t\tvisit(rules);\n\t\t\t}\n\t\t\t\n\t\t\treturn results;\n\t\t},\n\t\t\n\t\t//\n\t\t// a list of all properties supported by the current browser\n\t\t//\n\t\tallCSSProperties: null,\n\t\tgetAllCSSProperties: function getAllCSSProperties() {\n\t\t\t\n\t\t\tif(this.allCSSProperties) return this.allCSSProperties;\n\t\t\t\n\t\t\t// get all claimed properties\n\t\t\tvar s = getComputedStyle(document.documentElement); var ps = new Array(s.length);\n\t\t\tfor(var i=s.length; i--; ) {\n\t\t\t\tps[i] = s[i];\n\t\t\t}\n\t\t\t\n\t\t\t// FIX A BUG WHERE WEBKIT DOESN'T REPORT ALL PROPERTIES\n\t\t\tif(ps.indexOf('content')==-1) {ps.push('content');}\n\t\t\tif(ps.indexOf('counter-reset')==-1) {\n\t\t\t\t\n\t\t\t\tps.push('counter-reset');\n\t\t\t\tps.push('counter-increment');\n\t\t\t\t\n\t\t\t\t// FIX A BUG WHERE WEBKIT RETURNS SHIT FOR THE COMPUTED VALUE OF COUNTER-RESET\n\t\t\t\tcssCascade.computationUnsafeProperties['counter-reset']=true;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// save in a cache for faster access the next times\n\t\t\treturn this.allCSSProperties = ps;\n\t\t\t\n\t\t},\n\t\t\n\t\t// \n\t\t// those properties are not safe for computation->specified round-tripping\n\t\t// \n\t\tcomputationUnsafeProperties: {\n\t\t\t\"bottom\"          : true,\n\t\t\t\"direction\"       : true,\n\t\t\t\"display\"         : true,\n\t\t\t\"font-size\"       : true,\n\t\t\t\"height\"          : true,\n\t\t\t\"left\"            : true,\n\t\t\t\"line-height\"     : true,\n\t\t\t\"margin-left\"     : true,\n\t\t\t\"margin-right\"    : true,\n\t\t\t\"margin-bottom\"   : true,\n\t\t\t\"margin-top\"      : true,\n\t\t\t\"max-height\"      : true,\n\t\t\t\"max-width\"       : true,\n\t\t\t\"min-height\"      : true,\n\t\t\t\"min-width\"       : true,\n\t\t\t\"padding-left\"    : true,\n\t\t\t\"padding-right\"   : true,\n\t\t\t\"padding-bottom\"  : true,\n\t\t\t\"padding-top\"     : true,\n\t\t\t\"right\"           : true,\n\t\t\t\"text-align\"      : true,\n\t\t\t\"text-align-last\" : true,\n\t\t\t\"top\"             : true,\n\t\t\t\"width\"           : true,\n\t\t\t__proto__         : null,\n\t\t},\n\t\t\n\t\t//\n\t\t// a list of property we should inherit...\n\t\t//\n\t\tinheritingProperties: {\n\t\t\t\"border-collapse\"       : true,\n\t\t\t\"border-spacing\"        : true,\n\t\t\t\"caption-side\"          : true,\n\t\t\t\"color\"                 : true,\n\t\t\t\"cursor\"                : true,\n\t\t\t\"direction\"             : true,\n\t\t\t\"empty-cells\"           : true,\n\t\t\t\"font-family\"           : true,\n\t\t\t\"font-size\"             : true,\n\t\t\t\"font-style\"            : true,\n\t\t\t\"font-variant\"          : true,\n\t\t\t\"font-weight\"           : true,\n\t\t\t\"font\"                  : true,\n\t\t\t\"letter-spacing\"        : true,\n\t\t\t\"line-height\"           : true,\n\t\t\t\"list-style-image\"      : true,\n\t\t\t\"list-style-position\"   : true,\n\t\t\t\"list-style-type\"       : true,\n\t\t\t\"list-style\"            : true,\n\t\t\t\"orphans\"               : true,\n\t\t\t\"quotes\"                : true,\n\t\t\t\"text-align\"            : true,\n\t\t\t\"text-indent\"           : true,\n\t\t\t\"text-transform\"        : true,\n\t\t\t\"visibility\"            : true,\n\t\t\t\"white-space\"           : true,\n\t\t\t\"widows\"                : true,\n\t\t\t\"word-break\"            : true,\n\t\t\t\"word-spacing\"          : true,\n\t\t\t\"word-wrap\"             : true,\n\t\t\t__proto__               : null,\n\t\t},\n\t\t\n\t\t//\n\t\t// returns the default style for a tag\n\t\t//\n\t\tdefaultStylesForTag: Object.create ? Object.create(null) : {},\n\t\tgetDefaultStyleForTag: function getDefaultStyleForTag(tagName) {\n\t\t\t\n\t\t\t// get result from cache\n\t\t\tvar result = this.defaultStylesForTag[tagName];\n\t\t\tif(result) return result;\n\t\t\t\n\t\t\t// create dummy virtual element\n\t\t\tvar element = document.createElement(tagName);\n\t\t\tvar style = this.defaultStylesForTag[tagName] = getComputedStyle(element);\n\t\t\tif(style.display) return style;\n\t\t\t\n\t\t\t// webkit fix: insert the dummy element anywhere (head -> display:none)\n\t\t\tdocument.head.insertBefore(element, document.head.firstChild);\n\t\t\treturn style;\n\t\t},\n\t\t\n\t\t// \n\t\t// returns the specified style of an element. \n\t\t// REMARK: may or may not unwrap \"inherit\" and \"initial\" depending on implementation\n\t\t// REMARK: giving \"matchedRules\" as a parameter allow you to mutualize the \"findAllMatching\" rules calls\n\t\t// \n\t\tgetSpecifiedStyle: function getSpecifiedStyle(element, cssPropertyName, matchedRules) {\n\t\t\t\n\t\t\t// hook for css regions\n\t\t\tvar fragmentSource;\n\t\t\tif(fragmentSource=element.getAttribute('data-css-regions-fragment-of')) {\n\t\t\t\tfragmentSource = document.querySelector('[data-css-regions-fragment-source=\"'+fragmentSource+'\"]');\n\t\t\t\tif(fragmentSource) return cssCascade.getSpecifiedStyle(fragmentSource, cssPropertyName);\n\t\t\t}\n\t\t\t\n\t\t\t// give IE a thumbs up for this!\n\t\t\tif(element.currentStyle && !window.opera) {\n\t\t\t\t\n\t\t\t\t// ask IE to manage the style himself...\n\t\t\t\tvar bestValue = element.myStyle[cssPropertyName] || element.currentStyle[cssPropertyName];\n\t\t\t\t\n\t\t\t\t// return a parsed representation of the value\n\t\t\t\treturn cssSyntax.parseAListOfComponentValues(bestValue);\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// TODO: support the \"initial\" and \"inherit\" things?\n\t\t\t\t\n\t\t\t\t// first, let's try inline style as it's fast and generally accurate\n\t\t\t\t// TODO: what if important rules override that?\n\t\t\t\ttry {\n\t\t\t\t\tif(bestValue = element.style.getPropertyValue(cssPropertyName) || element.myStyle[cssPropertyName]) {\n\t\t\t\t\t\treturn cssSyntax.parseAListOfComponentValues(bestValue);\n\t\t\t\t\t}\n\t\t\t\t} catch(ex) {}\n\t\t\t\t\n\t\t\t\t// find all relevant style rules\n\t\t\t\tvar isBestImportant=false; var bestPriority = 0; var bestValue = new cssSyntax.TokenList();\n\t\t\t\tvar rules = matchedRules || (\n\t\t\t\t\tcssPropertyName in cssCascade.monitoredProperties\n\t\t\t\t\t? element.myMatchedRules || []\n\t\t\t\t\t: cssCascade.findAllMatchingRules(element)\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\tvar visit = function(rules) {\n\t\t\t\t\t\n\t\t\t\t\tfor(var i=rules.length; i--; ) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// media queries hook\n\t\t\t\t\t\tif(rules[i].disabled) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// find a relevant declaration\n\t\t\t\t\t\tif(rules[i] instanceof cssSyntax.StyleRule) {\n\t\t\t\t\t\t\tvar decls = rules[i].getDeclarations();\n\t\t\t\t\t\t\tfor(var j=decls.length-1; j>=0; j--) {\n\t\t\t\t\t\t\t\tif(decls[j].type==\"DECLARATION\") {\n\t\t\t\t\t\t\t\t\tif(decls[j].name==cssPropertyName) {\n\t\t\t\t\t\t\t\t\t\t// only works if selectors containing a \",\" are deduplicated\n\t\t\t\t\t\t\t\t\t\tvar currentPriority = cssCascade.computeSelectorPriorityOf(rules[i].selector);\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif(isBestImportant) {\n\t\t\t\t\t\t\t\t\t\t\t// only an important declaration can beat another important declaration\n\t\t\t\t\t\t\t\t\t\t\tif(decls[j].important) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(currentPriority >= bestPriority) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tbestPriority = currentPriority;\n\t\t\t\t\t\t\t\t\t\t\t\t\tbestValue = decls[j].value;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t// an important declaration beats any non-important declaration\n\t\t\t\t\t\t\t\t\t\t\tif(decls[j].important) {\n\t\t\t\t\t\t\t\t\t\t\t\tisBestImportant = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbestPriority = currentPriority;\n\t\t\t\t\t\t\t\t\t\t\t\tbestValue = decls[j].value;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t// the selector priority has to be higher otherwise\n\t\t\t\t\t\t\t\t\t\t\t\tif(currentPriority >= bestPriority) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tbestPriority = currentPriority;\n\t\t\t\t\t\t\t\t\t\t\t\t\tbestValue = decls[j].value;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if((rules[i] instanceof cssSyntax.AtRule) && (rules[i].name==\"media\")) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// visit them\n\t\t\t\t\t\t\tvisit(rules[i].toStylesheet())\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tvisit(rules);\n\t\t\t\t\n\t\t\t\t// return our best guess...\n\t\t\t\treturn bestValue||null;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\t\n\t\t//\n\t\t// start monitoring a new stylesheet\n\t\t// (should usually not be used because stylesheets load automatically)\n\t\t//\n\t\tstylesheets: [],\n\t\tloadStyleSheet: function loadStyleSheet(cssText,i) {\n\t\t\t\n\t\t\t// load in order\n\t\t\t\n\t\t\t// parse the stylesheet content\n\t\t\tvar rules = cssSyntax.parse(cssText).value;\n\t\t\t\n\t\t\t// add the stylesheet into the object model\n\t\t\tif(typeof(i)!==\"undefined\") { cssCascade.stylesheets[i]=rules; } \n\t\t\telse { i=cssCascade.stylesheets.push(rules);}\n\t\t\t\n\t\t\t// make sure to monitor the required rules\n\t\t\tcssCascade.startMonitoringStylesheet(rules)\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// start monitoring a new stylesheet\n\t\t// (should usually not be used because stylesheets load automatically)\n\t\t//\n\t\tloadStyleSheetTag: function loadStyleSheetTag(stylesheet,i) {\n\t\t\t\n\t\t\tif(stylesheet.hasAttribute('data-css-polyfilled')) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(stylesheet.tagName=='LINK') {\n\t\t\t\t\n\t\t\t\t// oh, no, we have to download it...\n\t\t\t\ttry {\n\t\t\t\t\t\n\t\t\t\t\t// dummy value in-between\n\t\t\t\t\tcssCascade.stylesheets[i] = new cssSyntax.TokenList();\n\t\t\t\t\t\n\t\t\t\t\t//\n\t\t\t\t\tvar xhr = new XMLHttpRequest(); xhr.href = stylesheet.href;\n\t\t\t\t\txhr.open('GET',stylesheet.href,true); xhr.ruleIndex = i; \n\t\t\t\t\txhr.onreadystatechange = function() {\n\t\t\t\t\t\tif(this.readyState==4) { \n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// status 0 is a webkit bug for local files\n\t\t\t\t\t\t\tif(this.status==200||this.status==0) {\n\t\t\t\t\t\t\t\tcssCascade.loadStyleSheet(this.responseText,this.ruleIndex)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcssConsole.log(\"css-cascade polyfill failled to load: \" + this.href);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\txhr.send();\n\t\t\t\t\t\n\t\t\t\t} catch(ex) {\n\t\t\t\t\tcssConsole.log(\"css-cascade polyfill failled to load: \" + stylesheet.href);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// oh, cool, we just have to parse the content!\n\t\t\t\tcssCascade.loadStyleSheet(stylesheet.textContent,i);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// mark the stylesheet as ok\n\t\t\tstylesheet.setAttribute('data-css-polyfilled',true);\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// calling this function will load all currently existing stylesheets in the document\n\t\t// (should usually not be used because stylesheets load automatically)\n\t\t//\n\t\tselectorForStylesheets: \"style:not([data-no-css-polyfill]):not([data-css-polyfilled]), link[rel=stylesheet]:not([data-no-css-polyfill]):not([data-css-polyfilled])\",\n\t\tloadAllStyleSheets: function loadAllStyleSheets() {\n\t\t\t\n\t\t\t// for all stylesheets in the <head> tag...\n\t\t\tvar head = document.head || document.documentElement;\n\t\t\tvar stylesheets = head.querySelectorAll(cssCascade.selectorForStylesheets);\n\t\t\t\n\t\t\tvar intialLength = this.stylesheets.length;\n\t\t\tthis.stylesheets.length += stylesheets.length\n\t\t\t\n\t\t\t// for all of them...\n\t\t\tfor(var i = stylesheets.length; i--;) {\n\t\t\t\t\n\t\t\t\t// \n\t\t\t\t// load the stylesheet\n\t\t\t\t// \n\t\t\t\tvar stylesheet = stylesheets[i]; \n\t\t\t\tcssCascade.loadStyleSheetTag(stylesheet,intialLength+i)\n\t\t\t\t\n\t\t\t}\n\t\t},\n\t\t\n\t\t//\n\t\t// this is where we store event handlers for monitored properties\n\t\t//\n\t\tmonitoredProperties: Object.create ? Object.create(null) : {},\n\t\tmonitoredPropertiesHandler: {\n\t\t\tonupdate: function(element, rule) {\n\t\t\t\t\n\t\t\t\t// we need to find all regexps that matches\n\t\t\t\tvar mps = cssCascade.monitoredProperties;\n\t\t\t\tvar decls = rule.getDeclarations();\n\t\t\t\tfor(var j=decls.length-1; j>=0; j--) {\n\t\t\t\t\tif(decls[j].type==\"DECLARATION\") {\n\t\t\t\t\t\tif(decls[j].name in mps) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// call all handlers waiting for this\n\t\t\t\t\t\t\tvar hs = mps[decls[j].name];\n\t\t\t\t\t\t\tfor(var hi=hs.length; hi--;) {\n\t\t\t\t\t\t\t\ths[hi].onupdate(element,rule);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// don't call twice\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t},\n\t\t\n\t\t//\n\t\t// add an handler to some properties (aka fire when their value *MAY* be affected)\n\t\t// REMARK: because this event does not promise the value changed, you may want to figure it out before relayouting\n\t\t//\n\t\tstartMonitoringProperties: function startMonitoringProperties(properties, handler) {\n\t\t\t\n\t\t\tfor(var i=properties.length; i--; ) {\n\t\t\t\tvar property = properties[i];\n\t\t\t\tvar handlers = (\n\t\t\t\t\tcssCascade.monitoredProperties[property]\n\t\t\t\t\t|| (cssCascade.monitoredProperties[property] = [])\n\t\t\t\t);\n\t\t\t\thandlers.push(handler)\n\t\t\t}\n\t\t\t\n\t\t\tfor(var s=0; s<cssCascade.stylesheets.length; s++) {\n\t\t\t\tvar currentStylesheet = cssCascade.stylesheets[s];\n\t\t\t\tcssCascade.startMonitoringStylesheet(currentStylesheet);\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// calling this function will detect monitored rules in the stylesheet\n\t\t// (should usually not be used because stylesheets load automatically)\n\t\t//\n\t\tstartMonitoringStylesheet: function startMonitoringStylesheet(rules) {\n\t\t\tfor(var i=0; i<rules.length; i++) {\n\t\t\t\t\n\t\t\t\t// only consider style rules\n\t\t\t\tif(rules[i] instanceof cssSyntax.StyleRule) {\n\t\t\t\t\t\n\t\t\t\t\t// try to see if the current rule is worth monitoring\n\t\t\t\t\tif(rules[i].isMonitored) continue;\n\t\t\t\t\t\n\t\t\t\t\t// for that, let's see if we can find a declaration we should watch\n\t\t\t\t\tvar decls = rules[i].getDeclarations();\n\t\t\t\t\tfor(var j=decls.length-1; j>=0; j--) {\n\t\t\t\t\t\tif(decls[j].type==\"DECLARATION\") {\n\t\t\t\t\t\t\tif(decls[j].name in cssCascade.monitoredProperties) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// if we found some, start monitoring\n\t\t\t\t\t\t\t\tcssCascade.startMonitoringRule(rules[i]);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else if(rules[i] instanceof cssSyntax.AtRule) {\n\t\t\t\t\t\n\t\t\t\t\t// handle @media\n\t\t\t\t\tif(rules[i].name == \"media\" && window.matchMedia) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tcssCascade.startMonitoringMedia(rules[i]);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t},\n\t\t\n\t\t//\n\t\t// calling this function will detect media query updates and fire events accordingly\n\t\t// (should usually not be used because stylesheets load automatically)\n\t\t//\n\t\tstartMonitoringMedia: function startMonitoringMedia(atrule) {\n\t\t\ttry {\n\t\t\t\t\n\t\t\t\tvar media = window.matchMedia(atrule.prelude.toCSSString());\n\t\t\t\t\n\t\t\t\t// update all the rules when needed\n\t\t\t\tvar rules = atrule.toStylesheet().value;\n\t\t\t\tcssCascade.updateMedia(rules, !media.matches, false);\n\t\t\t\tmedia.addListener(\n\t\t\t\t\tfunction(newMedia) { cssCascade.updateMedia(rules, !newMedia.matches, true); }\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\t// it seems I like taking risks...\n\t\t\t\tcssCascade.startMonitoringStylesheet(rules);\n\t\t\t\t\n\t\t\t} catch(ex) {\n\t\t\t\tsetImmediate(function() { throw ex; })\n\t\t\t}\n\t\t},\n\t\t\n\t\t//\n\t\t// define what happens when a media query status changes\n\t\t//\n\t\tupdateMedia: function(rules,disabled,update) {\n\t\t\tfor(var i=rules.length; i--; ) {\n\t\t\t\trules[i].disabled = disabled;\n\t\t\t\t// TODO: should probably get handled by a setter on the rule...\n\t\t\t\tvar sr = rules[i].subRules;\n\t\t\t\tif(sr) {\n\t\t\t\t\tfor(var j=sr.length; j--; ) {\n\t\t\t\t\t\tsr[j].disabled = disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// in case of update, all elements matching the selector went potentially updated...\n\t\t\tif(update) {\n\t\t\t\tfor(var i=rules.length; i--; ) {\n\t\t\t\t\tvar els = document.querySelectorAll(rules[i].selector.toCSSString());\n\t\t\t\t\tfor(var j=els.length; j--; ) {\n\t\t\t\t\t\tcssCascade.monitoredPropertiesHandler.onupdate(els[j],rules[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\n\t\t// \n\t\t// splits a rule if it has multiple selectors\n\t\t// \n\t\tsplitRule: function splitRule(rule) {\n\t\t\t\n\t\t\t// create an array for all the subrules\n\t\t\tvar rules = [];\n\t\t\t\n\t\t\t// fill the array\n\t\t\tvar currentRule = new cssSyntax.StyleRule(); currentRule.disabled=rule.disabled;\n\t\t\tfor(var i=0; i<rule.selector.length; i++) {\n\t\t\t\tif(rule.selector[i] instanceof cssSyntax.DelimToken && rule.selector[i].value==\",\") {\n\t\t\t\t\tcurrentRule.value = rule.value; rules.push(currentRule);\n\t\t\t\t\tcurrentRule = new cssSyntax.StyleRule(); currentRule.disabled=rule.disabled;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentRule.selector.push(rule.selector[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrentRule.value = rule.value; rules.push(currentRule);\n\t\t\t\n\t\t\t// save the result of the split as subrules\n\t\t\treturn rule.subRules = rules;\n\t\t\t\n\t\t},\n\t\t\n\t\t// \n\t\t// ask the css-selector implementation to notify changes for the rules\n\t\t// \n\t\tstartMonitoringRule: function startMonitoringRule(rule) {\n\t\t\t\n\t\t\t// avoid monitoring rules twice\n\t\t\tif(!rule.isMonitored) { rule.isMonitored=true } else { return; }\n\t\t\t\n\t\t\t// split the rule if it has multiple selectors\n\t\t\tvar rules = rule.subRules || cssCascade.splitRule(rule);\n\t\t\t\n\t\t\t// monitor the rules\n\t\t\tfor(var i=0; i<rules.length; i++) {\n\t\t\t\trule = rules[i];\n\t\t\t\tquerySelectorLive(rule.selector.toCSSString(), {\n\t\t\t\t\tonadded: function(e) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// add the rule to the matching list of this element\n\t\t\t\t\t\t(e.myMatchedRules = e.myMatchedRules || []).unshift(rule); // TODO: does not respect priority order\n\t\t\t\t\t\t\n\t\t\t\t\t\t// generate an update event\n\t\t\t\t\t\tcssCascade.monitoredPropertiesHandler.onupdate(e, rule);\n\t\t\t\t\t\t\n\t\t\t\t\t},\n\t\t\t\t\tonremoved: function(e) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// remove the rule from the matching list of this element\n\t\t\t\t\t\tif(e.myMatchedRules) e.myMatchedRules.splice(e.myMatchedRules.indexOf(rule), 1);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// generate an update event\n\t\t\t\t\t\tcssCascade.monitoredPropertiesHandler.onupdate(e, rule);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// converts a css property name to a javascript name\n\t\t//\n\t\ttoCamelCase: function toCamelCase(variable) { \n\t\t\treturn variable.replace(\n\t\t\t\t/-([a-z])/g, \n\t\t\t\tfunction(str,letter) { \n\t\t\t\t\treturn letter.toUpperCase();\n\t\t\t\t}\n\t\t\t);\n\t\t},\n\t\t\n\t\t//\n\t\t// add some magic code to support properties on the style interface\n\t\t//\n\t\tpolyfillStyleInterface: function(cssPropertyName) {\n\t\t\t\n\t\t\tvar prop = {\n\t\t\t\t\n\t\t\t\tget: function() {\n\t\t\t\t\t\n\t\t\t\t\t// check we know which element we work on\n\t\t\t\t\ttry { if(!this.parentElement) throw new Error(\"Please use the anHTMLElement.myStyle property to get polyfilled properties\") }\n\t\t\t\t\tcatch(ex) { setImmediate(function() { throw ex; }); return ''; }\n\t\t\t\t\t\n\t\t\t\t\ttry { \n\t\t\t\t\t\t// non-computed style: return the local style of the element\n\t\t\t\t\t\tthis.clip = (this.clip===undefined?'':this.clip);\n\t\t\t\t\t\treturn this.parentElement.getAttribute('data-style-'+cssPropertyName);\n\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\t// computed style: return the specified style of the element\n\t\t\t\t\t\tvar value = cssCascade.getSpecifiedStyle(this.parentElement, cssPropertyName, undefined, true);\n\t\t\t\t\t\treturn value && value.length>0 ? value.toCSSString() : '';\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tset: function(v) {\n\t\t\t\t\t\n\t\t\t\t\t// check that the style is writable\n\t\t\t\t\tthis.clip = (this.clip===undefined?'':this.clip);\n\n\t\t\t\t\t// check we know which element we work on\n\t\t\t\t\ttry { if(!this.parentElement) throw new Error(\"Please use the anHTMLElement.myStyle property to set polyfilled properties\") }\n\t\t\t\t\tcatch(ex) { setImmediate(function() { throw ex; }); return; }\n\t\t\t\t\t\n\t\t\t\t\t// modify the local style of the element\n\t\t\t\t\tif(this.parentElement.getAttribute('data-style-'+cssPropertyName) != v) {\n\t\t\t\t\t\tthis.parentElement.setAttribute('data-style-'+cssPropertyName,v);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t};\n\t\t\t\n\t\t\tvar styleProtos = [];\n\t\t\ttry { styleProtos.push(Object.getPrototypeOf(document.documentElement.style) || CSSStyleDeclaration); } catch (ex) {}\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(getComputedStyle(document.documentElement))); } catch (ex) {}\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.currentStyle)); } catch (ex) {}\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.runtimeStyle)); } catch (ex) {}\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.specifiedStyle)); } catch (ex) {}\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.cascadedStyle)); } catch (ex) {}\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.usedStyle)); } catch (ex) {}\n\t\t\t\n\t\t\tfor(var i = styleProtos.length; i--;) {\n\t\t\t\tvar styleProto = styleProtos[i];\n\t\t\t\tObject.defineProperty(styleProto,cssPropertyName,prop);\n\t\t\t\tObject.defineProperty(styleProto,cssCascade.toCamelCase(cssPropertyName),prop);\n\t\t\t}\n\t\t\tcssCascade.startMonitoringRule(cssSyntax.parse('[style*=\"'+cssPropertyName+'\"]{'+cssPropertyName+':attr(style)}').value[0]);\n\t\t\tcssCascade.startMonitoringRule(cssSyntax.parse('[data-style-'+cssPropertyName+']{'+cssPropertyName+':attr(style)}').value[0]);\n\t\t\t\n\t\t\t// add to the list of polyfilled properties...\n\t\t\tcssCascade.getAllCSSProperties().push(cssPropertyName);\n\t\t\tcssCascade.computationUnsafeProperties[cssPropertyName] = true;\n\t\t\t\n\t\t}\n\t\t\n\t};\n\n\t//\n\t// polyfill for browsers not support CSSStyleDeclaration.parentElement (all of them right now)\n\t//\n\tdomEvents.EventTarget.implementsIn(cssCascade);\n\tObject.defineProperty(Element.prototype,'myStyle',{\n\t\tget: function() {\n\t\t\tvar style = this.style; \n\t\t\tif(!style.parentElement) style.parentElement = this;\n\t\t\treturn style;\n\t\t}\n\t});\n\n\t//\n\t// load all stylesheets at the time the script is loaded\n\t// then do it again when all stylesheets are downloaded\n\t// and again if some style tag is added to the DOM\n\t//\n\tif(!(\"no_auto_stylesheet_detection\" in window)) {\n\t\t\n\t\tcssCascade.loadAllStyleSheets();\n\t\tdocument.addEventListener(\"DOMContentLoaded\", function() {\n\t\t\tcssCascade.loadAllStyleSheets();\n\t\t\tquerySelectorLive(\n\t\t\t\tcssCascade.selectorForStylesheets,\n\t\t\t\t{\n\t\t\t\t\tonadded: function(e) {\n\t\t\t\t\t\t// TODO: respect DOM order?\n\t\t\t\t\t\tcssCascade.loadStyleSheetTag(e);\n\t\t\t\t\t\tcssCascade.dispatchEvent('stylesheetadded');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t)\n\t\t})\n\t}\n\t\n\treturn cssCascade;\n\n})(window, document);\nrequire.define('src/core/css-cascade.js');","//\n// The CSS Style module attempts to provide helpers to deal with Style Declarations and elements\n// [0] http://lists.w3.org/Archives/Public/www-style/2013Sep/0283.html\n//\nmodule.exports = (function(window, document) { \"use strict\";\n\n\tfunction usedStyleOf(element) {\n\t\tvar style = element.usedStyle || getComputedStyle(element);\n\t\tif(!style.parentElement) { style.parentElement = element; }\n\t\treturn style;\n\t}\n\t\n\tfunction currentStyleOf(element) {\n\t\tvar style = element.cascadedStyle || element.specifiedStyle || element.currentStyle || getComputedStyle(element); // TODO: check CSSOM spec for real name\n\t\tif(!style.parentElement) { style.parentElement = element; }\n\t\treturn style;\n\t}\n\t\n\tfunction styleOf(element) {\n\t\tvar style = element.style;\n\t\tif(!style.parentElement) { style.parentElement = element; }\n\t\treturn style;\n\t}\n\t\n\tfunction runtimeStyleOf(element) {\n\t\tvar style = /*element.runtimeStyle || */element.style;\n\t\tif(!style.parentElement) { style.parentElement = element; }\n\t\treturn style;\n\t}\n\t\n\tfunction enforceStyle(element, property, value) {\n\t\t\n\t\tvar propertyBackup = null;\n\t\tvar usedValue = usedStyleOf(element).getPropertyValue(property);\n\t\tif(value instanceof Array) {\n\t\t\tif(value.indexOf(usedValue) >= 0) return null;\n\t\t\tvalue = ''+value[0];\n\t\t} else {\n\t\t\tvalue = ''+value;\n\t\t}\n\t\t\n\t\tif(usedValue != value) {\n\t\t\tvar style = runtimeStyleOf(element);\n\t\t\tpropertyBackup = { \n\t\t\t\tvalue:     style.getPropertyValue(property),\n\t\t\t\tpriority:  style.getPropertyPriority(property),\n\t\t\t\tproperty:  property\n\t\t\t};\n\t\t\tstyle.setProperty(property, \"\", \"\"); // reset [0]\n\t\t\tstyle.setProperty(property, \"\" + value, \"important\");\n\t\t}\n\t\t\n\t\treturn propertyBackup;\n\t\t\n\t}\n\t\n\tfunction enforceStyles(element, propertyValues, backups) {\n\t\tvar backups = backups || [];\n\t\tfor(var property in propertyValues) { if(propertyValues.hasOwnProperty(key)) {\n\t\t\tvar currentBackup = enforceStyle(element, property, propertyValues[property]);\n\t\t\tif(currentBackup) { backups.push(currentBackup) }\n\t\t}}\n\t\treturn backups;\n\t}\n\n\tfunction restoreStyle(element, backup) {\n\n\t\tif(backup) {\n\t\t\n\t\t\t// get the element runtime style\n\t\t\tvar style = runtimeStyleOf(element);\n\t\t\t\n\t\t\t// reset [0]\n\t\t\tstyle.setProperty(backup.property, \"\", \"\");\n\t\t\t\n\t\t\t// restore\n\t\t\tif(backup.value) {\n\t\t\t\tstyle.setProperty(backup.property, backup.value, \"\");\n\t\t\t\tstyle.setProperty(backup.property, backup.value, backup.priority);\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t}\n\t\n\tfunction restoreStyles(element, backups) {\n\t\tif(!backups || !(backups.length > 0)) { return; }\n\t\tfor(var i=backups.length; i--;) {\n\t\t\trestoreStyle(element, backups[i]);\n\t\t}\n\t}\n\t\n\tvar cssStyle = {\n\t\tstyleOf: styleOf,\n\t\tusedStyleOf: usedStyleOf,\n\t\tcurrentStyleOf: currentStyleOf,\n\t\truntimeStyleOf: runtimeStyleOf,\n\t\tenforceStyle: enforceStyle,\n\t\tenforceStyles: enforceStyles,\n\t\trestoreStyle: restoreStyle,\n\t\trestoreStyles: restoreStyles,\n\t};\n\t\n\treturn cssStyle;\n\n})(window);\nrequire.define('src/core/css-style.js');","module.exports = (function(window, document) { \"use strict\";\n\t\n\tvar VSS_COUNT = 0;\n\tfunction VirtualStylesheetFactory() {\n\t\tvar This = this || Object.create(VirtualStylesheet.prototype);\n\t\t\n\t\t// create the style sheet\n\t\tvar styleElement = document.createElement('style');\n\t\tstyleElement.id = \"virtual-stylesheet-\" + (VSS_COUNT++);\n\t\tstyleElement.setAttribute('data-no-css-polyfill', 'true');\n\t\tstyleElement.appendChild(document.createTextNode(''));\n\t\tdocument.querySelector(':root > head').appendChild(styleElement);\n\t\t\n\t\t// grab its stylesheet object\n\t\tvar ss = styleElement.sheet;\n\t\tif(!ss.cssRules) ss.cssRules = ss.rules;\n\t\tss.removeRule = ss.removeRule || function(i) {\n\t\t\treturn ss.deleteRule(i);\n\t\t}\n\t\tss.addRule = ss.addRule || function(s,d,i) {\n\t\t\tvar rule = s+'{'+d+'}'\n\t\t\tvar index = typeof(i)=='number' ? i : ss.cssRules.length;\n\t\t\treturn ss.insertRule(rule, index);\n\t\t}\n\t\t\n\t\t// create the mapping table\n\t\tvar rules = [];\n\t\t\n\t\t// add the factory\n\t\t\n\t\tThis.stylesheets = Object.create(null);\n\t\tThis.createStyleSheet = function(name) {\n\t\t\treturn This.stylesheets[name] || (This.stylesheets[name] = new VirtualStylesheet(this, name));\n\t\t}\n\t\t\n\t\t// add the methods\n\t\t\n\t\tThis.addRule = function(selector, declarations, stylesheet, enabled) {\n\t\t\t\n\t\t\t// convert selector & declarations to a non-empty string\n\t\t\tselector = '' + selector + ' ';\n\t\t\tdeclarations = '' + declarations + ' ';\n\t\t\t\n\t\t\t// add the rule to the known rules\n\t\t\trules.push({ stylesheet: stylesheet, selector: selector, declarations: declarations, enabled: enabled });\n\t\t\t\n\t\t\t// add the rule to the enabled stylesheet, if needed\n\t\t\tif(enabled) {\n\t\t\t\tss.addRule(selector, declarations);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tThis.disableAllRules = function(stylesheet) {\n\t\t\tvar ssIndex = ss.cssRules.length;\n\t\t\tfor(var i = rules.length; i--;) { var rule = rules[i];\n\t\t\t\tif(rule.enabled) {\n\t\t\t\t\tssIndex--;\n\t\t\t\t\tif(rule.stylesheet == stylesheet) {\n\t\t\t\t\t\tss.removeRule(ssIndex);\n\t\t\t\t\t\trule.enabled = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tThis.enableAllRules = function(stylesheet) {\n\t\t\tvar ssIndex = 0;\n\t\t\tfor(var i = 0; i<rules.length; i++) { var rule = rules[i];\n\t\t\t\tif(rule.enabled) {\n\t\t\t\t\tssIndex++;\n\t\t\t\t} else {\n\t\t\t\t\tif(rule.stylesheet == stylesheet) {\n\t\t\t\t\t\tss.addRule(rule.selector, rule.declarations, ssIndex);\n\t\t\t\t\t\trule.enabled = true;\n\t\t\t\t\t\tssIndex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tThis.deleteAllRules = function(stylesheet) {\n\t\t\tvar ssIndex = ss.cssRules.length;\n\t\t\tfor(var i = rules.length; i--;) { var rule = rules[i];\n\t\t\t\tif(rule.enabled) {\n\t\t\t\t\tssIndex--;\n\t\t\t\t\tif(rule.stylesheet == stylesheet) {\n\t\t\t\t\t\tss.removeRule(ssIndex);\n\t\t\t\t\t\trules.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tfunction VirtualStylesheet(factory, name) {\n\t\tthis.factory = factory;\n\t\tthis.name = name;\n\t\tthis.enabled = true;\n\t}\n\t\n\tVirtualStylesheet.prototype.addRule = function(selector, declarations) {\n\t\tthis.factory.addRule(selector, declarations, this.name, this.enabled);\n\t}\n\t\n\tVirtualStylesheet.prototype.set = function(element, properties) {\n\t\t\n\t\t// give an id to the element\n\t\tif(!element.id) { element.id = element.uniqueID; }\n\t\n\t\t// compute the css rule to add\n\t\tvar selector = \"#\"+element.id;\n\t\tvar rule = \"\"; for(var property in properties) {\n\t\t\tif(properties.hasOwnProperty(property)) {\n\t\t\t\trule += property + \": \" + properties[property] + \" !important; \";\n\t\t\t}\n\t\t}\n\t\t\n\t\t// and then add it\n\t\tthis.addRule(selector, rule);\n\t\t\n\t}\n\t\n\tVirtualStylesheet.prototype.enable = function() {\n\t\tthis.factory.enableAllRules(this.name); this.enabled=true;\n\t}\n\t\n\tVirtualStylesheet.prototype.disable = function() {\n\t\tthis.factory.disableAllRules(this.name); this.enabled=false;\n\t}\n\t\n\tVirtualStylesheet.prototype.clear = function() {\n\t\tthis.factory.deleteAllRules(this.name);\n\t}\n\t\n\tVirtualStylesheet.prototype.revoke = function() {\n\t\tthis.clear();\n\t}\n\t\n\tVirtualStylesheetFactory.VirtualStylesheet = VirtualStylesheet;\n\tVirtualStylesheetFactory.VirtualStylesheetFactory = VirtualStylesheetFactory;\n\treturn VirtualStylesheetFactory;\n\t\n})(window, document)\nrequire.define('src/core/css-virtual-stylesheet-factory.js');","void function() {\n\tif(!('uniqueID' in document.documentElement)) {\n\t\tvar uniqueID_counter = 0;\n\t\tObject.defineProperty(Element.prototype, 'uniqueID', {get: function() {\n\t\t\tif(this.id) {\n\t\t\t\treturn(this.id);\n\t\t\t} else {\n\t\t\t\treturn(this.id = (\"EL__\"+(++uniqueID_counter)+\"__\"));\n\t\t\t}\n\t\t}});\n\t}\n}();\nrequire.define('src/core/polyfill-dom-uniqueID.js');","module.exports = (function(window, document) {\n\t\n\t// import dependencies\n\tvar cssStyle  = require('src/core/css-style.js'),\n\t    usedStyleOf     = cssStyle.usedStyleOf,\n\t    currentStyleOf  = cssStyle.currentStyleOf,\n\t    enforceStyle    = cssStyle.enforceStyle,\n\t    restoreStyle    = cssStyle.restoreStyle;\n\t\n\t// define the module\n\tvar cssSizing = {\n\t\t\n\t\tabsoluteMinWidthOf: function(element) {\n\n\t\t\t//\n\t\t\t// make the parent a relative container (if necessary)\n\t\t\t//\n\t\t\tvar parentPositionBackup = enforceStyle(element.parentNode, \"position\", \"relative\");\n\t\t\t\n\t\t\t//\n\t\t\t// remove the element from the flow (if necessary)\n\t\t\t//\n\t\t\tvar positionBackup = enforceStyle(element, \"position\", \"absolute\");\n\t\t\t\n\t\t\t//\n\t\t\t// put impossible sizing constraints to the element\n\t\t\t//\n\t\t\tvar widthBackup = enforceStyle(element, \"width\", \"0px\");\n\t\t\tvar minWidthBackup = enforceStyle(element, \"min-width\", \"0px\");\n\t\t\t\n\t\t\t//\n\t\t\t// see what size is finally being used\n\t\t\t//\n\t\t\tvar result = element.offsetWidth;\n\t\t\t\n\t\t\t//\n\t\t\t// restore styling where needed\n\t\t\t//\n\t\t\trestoreStyle(element, minWidthBackup);\n\t\t\trestoreStyle(element, widthBackup);\n\t\t\trestoreStyle(element, positionBackup);\n\t\t\trestoreStyle(element.parentNode, parentPositionBackup);\n\t\t\t\n\t\t\t//\n\t\t\t// return the result\n\t\t\t//\n\t\t\treturn result;\n\t\t\t\t\n\t\t},\n\t\t\n\t\tminWidthOf: function(element) {\n\t\t\n\t\t\t//\n\t\t\t// make the parent an infinite relative container (if necessary)\n\t\t\t//\n\t\t\tvar parentPositionBackup = enforceStyle(element.parentNode, \"position\", \"relative\");\n\t\t\tvar parentWidthBackup = enforceStyle(element.parentNode, \"width\", \"0px\");\n\t\t\tvar parentMinWidthBackup = enforceStyle(element.parentNode, \"min-width\", \"0px\");\n\t\t\tvar parentMaxWidthBackup = enforceStyle(element.parentNode, \"max-width\", \"0px\");\n\t\t\t\n\t\t\t//\n\t\t\t// remove the element from the flow (if necessary)\n\t\t\t//\n\t\t\tvar positionBackup = enforceStyle(element, \"position\", \"absolute\");\n\t\t\t\n\t\t\t//\n\t\t\t// put impossible sizing constraints to the element\n\t\t\t//\n\t\t\tvar widthBackup = enforceStyle(element, \"width\", \"auto\");\n\t\t\t\n\t\t\t//\n\t\t\t// see what size is finally being used\n\t\t\t//\n\t\t\tvar result = element.offsetWidth;\n\t\t\t\n\t\t\t//\n\t\t\t// restore styling where needed\n\t\t\t//\n\t\t\trestoreStyle(element, widthBackup);\n\t\t\trestoreStyle(element, positionBackup);\n\t\t\trestoreStyle(element.parentNode, parentWidthBackup);\n\t\t\trestoreStyle(element.parentNode, parentMaxWidthBackup);\n\t\t\trestoreStyle(element.parentNode, parentMinWidthBackup);\n\t\t\trestoreStyle(element.parentNode, parentPositionBackup);\n\t\t\t\n\t\t\t//\n\t\t\t// return the result\n\t\t\t//\n\t\t\treturn result;\n\t\t},\n\t\t\n\t\tmaxWidthOf: function(element) {\n\t\t\n\t\t\t//\n\t\t\t// make the parent a relative container (if necessary)\n\t\t\t//\n\t\t\tvar parentPositionBackup = enforceStyle(element.parentNode, \"position\", \"relative\");\n\t\t\t\n\t\t\t//\n\t\t\t// remove the element from the flow (if necessary)\n\t\t\t//\n\t\t\tvar positionBackup = enforceStyle(element, \"position\", \"absolute\");\n\t\t\t\n\t\t\t//\n\t\t\t// put impossible sizing constraints to the element\n\t\t\t//\n\t\t\tvar widthBackup = enforceStyle(element, \"width\", \"auto\");\n\t\t\t\n\t\t\t//\n\t\t\t// see what size is finally being used\n\t\t\t//\n\t\t\tvar result = element.offsetWidth;\n\t\t\t\t\t\n\t\t\t//\n\t\t\t// restore styling where needed\n\t\t\t//\n\t\t\trestoreStyle(element, widthBackup);\n\t\t\trestoreStyle(element, positionBackup);\n\t\t\trestoreStyle(element.parentNode, parentPositionBackup);\n\t\t\t\n\t\t\t//\n\t\t\t// return the result\n\t\t\t//\n\t\t\treturn result;\n\t\t},\n\t\t\n\t\tabsoluteMaxWidthOf: function(element) {\n\t\t\n\t\t\t//\n\t\t\t// make the parent an infinite relative container (if necessary)\n\t\t\t//\n\t\t\tvar parentPositionBackup = enforceStyle(element.parentNode, \"position\", \"relative\");\n\t\t\tvar parentWidthBackup = enforceStyle(element.parentNode, \"width\", \"9999px\");\n\t\t\tvar parentMinWidthBackup = enforceStyle(element.parentNode, \"min-width\", \"9999px\");\n\t\t\t\n\t\t\t//\n\t\t\t// remove the element from the flow (if necessary)\n\t\t\t//\n\t\t\tvar positionBackup = enforceStyle(element, \"position\", \"absolute\");\n\t\t\t\n\t\t\t//\n\t\t\t// put impossible sizing constraints to the element\n\t\t\t//\n\t\t\tvar widthBackup = enforceStyle(element, \"width\", \"auto\");\n\t\t\t\n\t\t\t//\n\t\t\t// see what size is finally being used\n\t\t\t//\n\t\t\tvar result = element.offsetWidth;\n\t\t\t\n\t\t\t//\n\t\t\t// restore styling where needed\n\t\t\t//\n\t\t\trestoreStyle(element, widthBackup);\n\t\t\trestoreStyle(element, positionBackup);\n\t\t\trestoreStyle(element.parentNode, parentWidthBackup);\n\t\t\trestoreStyle(element.parentNode, parentMinWidthBackup);\n\t\t\trestoreStyle(element.parentNode, parentPositionBackup);\n\t\t\t\n\t\t\t//\n\t\t\t// return the result\n\t\t\t//\n\t\t\treturn result;\n\t\t},\n\t\t\n\t};\n\t\n\treturn cssSizing;\n\t\n})(window, document)\nrequire.define('src/core/css-sizing.js');","//\n// The Box module defines algorithms for dealing with css boxes\n//\nmodule.exports = (function(window, document) {\n\t\n\t// Original code licensed by Adobe Systems Incorporated under the Apache License 2.0. \n\t// https://github.com/adobe-webplatform/brackets-css-shapes-editor/blob/master/thirdparty/CSSShapesEditor.js#L442\n\n\tvar cssBox = cssBox || {};\n\tcssBox.getBox = \n\t\t\n\t\t// returns {top/left/bottom/right} for 'content/padding/border/margin-box' relative to the border box top-left corner.\n\t\tfunction getBox(element, boxType){\n\t\t\tvar width = element.offsetWidth,\n\t\t\t\theight = element.offsetHeight,\n\n\t\t\t\tstyle = getComputedStyle(element),\n\n\t\t\t\tleftBorder = parseFloat(style.borderLeftWidth),\n\t\t\t\trightBorder = parseFloat(style.borderRightWidth),\n\t\t\t\ttopBorder = parseFloat(style.borderTopWidth),\n\t\t\t\tbottomBorder = parseFloat(style.borderBottomWidth),\n\n\t\t\t\tleftPadding = parseFloat(style.paddingLeft),\n\t\t\t\trightPadding = parseFloat(style.paddingRight),\n\t\t\t\ttopPadding = parseFloat(style.paddingTop),\n\t\t\t\tbottomPadding = parseFloat(style.paddingBottom),\n\n\t\t\t\tleftMargin = parseFloat(style.marginLeft),\n\t\t\t\trightMargin = parseFloat(style.marginRight),\n\t\t\t\ttopMargin = parseFloat(style.marginTop),\n\t\t\t\tbottomMargin = parseFloat(style.marginBottom);\n\n\t\t\tvar box = {\n\t\t\t\ttop: 0,\n\t\t\t\tleft: 0,\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\n\t\t\tswitch (boxType||'border-box'){\n\t\t\tcase 'content-box':\n\t\t\t\tbox.top = topBorder + topPadding;\n\t\t\t\tbox.left = leftBorder + leftPadding;\n\t\t\t\tbox.width = width - leftBorder - leftPadding - rightPadding - rightBorder;\n\t\t\t\tbox.height = height - topBorder - topPadding - bottomPadding - bottomBorder;\n\t\t\t\tbreak;\n\n\t\t\tcase 'padding-box':\n\t\t\t\tbox.top = topPadding;\n\t\t\t\tbox.left = leftPadding;\n\t\t\t\tbox.width = width - leftBorder - rightBorder;\n\t\t\t\tbox.height = height - topBorder - bottomBorder;\n\t\t\t\tbreak;\n\n\t\t\tcase 'border-box':\n\t\t\t\tbox.top = 0;\n\t\t\t\tbox.left = 0;\n\t\t\t\tbox.width = width;\n\t\t\t\tbox.height = height;\n\t\t\t\tbreak;\n\n\t\t\tcase 'margin-box':\n\t\t\t\tbox.top = 0 - topMargin;\n\t\t\t\tbox.left = 0 - leftMargin;\n\t\t\t\tbox.width = width + leftMargin + rightMargin;\n\t\t\t\tbox.height = height + topMargin + bottomMargin;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new TypeError('Invalid parameter, boxType: ' + boxType);\n\t\t\t}\n\n\t\t\treturn box;\n\t\t};\n\t\n\treturn cssBox;\n\t\n})(window, document);\nrequire.define('src/core/css-box.js');","//\n// The CSS Units module is handling conversions between units\n//\nmodule.exports = (function(window, document) {\n\t\n\t// import dependencies\n\tvar getBox = require('src/core/css-box.js').getBox;\n\t\n\t// define the module\n\tvar cssUnits = {\n\t\t\n\t\t// converts \"cssLength\" from its inherent unit to pixels, and returns the result as a float\n\t\tconvertToPixels: function convertToPixels(cssLength, element, opts) {\n\t\t\t\n\t\t\tif(typeof cssLength == \"string\") {\n\t\t\t\n\t\t\t\tvar match = cssLength.match(/^\\s*(-?\\d+(?:\\.\\d+)?)(\\S*)\\s*$/);\n\t\t\t\tvar currentLength = match ? parseFloat(match[1]) : 0.0;\n\t\t\t\tvar currentUnit = match ? match[2] : '';\n\t\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tvar currentLength = cssLength.value;\n\t\t\t\tvar currentUnit = cssLength.unit;\n\t\t\t\t\n\t\t\t}\n\n\t\t\tvar converter = convertToPixels.converters[currentUnit];\n\t\t\tif (!converter) throw new Error(\"No suitable conversion from unit '\"+currentUnit+\"' to unit 'px'\");\n\t\t\t\n\t\t\tvar convertedLength = converter.call(null, currentLength, element||document.documentElement, opts)\n\t\t\treturn Math.round(20*convertedLength)/20;\n\t\t\t\n\t\t},\n\n\t\t// converts \"pixelLength\" from pixels to \"destinUnit\", and returns the result as a float\n\t\tconvertFromPixels: function convertFromPixels(pixelLength, destinUnit, element, opts) {\n\n\t\t\tvar converter = convertFromPixels.converters[destinUnit];\n\t\t\tif (!converter) throw new Error(\"No suitable conversion to unit '\"+destinUnit+\"' from unit 'px'\");\n\n\t\t\tvar convertedLength = converter.call(null, pixelLength, element||document.documentElement, opts)\n\t\t\treturn Math.round(20*convertedLength)/20;\n\t\t\t\n\t\t},\n\t\t\n\t}\n\t\n\tcssUnits.convertToPixels.converters = {\n\t\t'px' : function(x) { return x; },\n\t\t'in' : function(x) { return x * 96; },\n\t\t'cm' : function(x) { return x / 0.02645833333; },\n\t\t'mm' : function(x) { return x / 0.26458333333; },\n\t\t'pt' : function(x) { return x / 0.75; },\n\t\t'pc' : function(x) { return x / 0.0625; },\n\t\t'em' : function(x, e) { return x*parseFloat(e?getComputedStyle(e).fontSize:16); },\n\t\t'rem': function(x, e) { return x*parseFloat(e?getComputedStyle(e.ownerDocument.documentElement).fontSize:16); },\n\t\t'vw' : function(x, e) { return x/100*window.innerWidth; },\n\t\t'vh' : function(x, e) { return x/100*window.innerHeight; },\n\t\t'%'  : function(x, e, opts) {\n\t\t\topts = opts || {};\n\n\t\t\t// get the box from which to compute the percentages\n\t\t\tvar box = e ? getBox(e, opts.boxType) : {\n\t\t\t\ttop: 0,\n\t\t\t\tleft: 0,\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\n\t\t\t// now apply the conversion algorithm\n\t\t\tswitch(true) {\n\t\t\t\tcase opts.isRadius:\n\t\t\t\t\tvar radius = Math.sqrt( box.height*box.height + box.width*box.width ) / Math.sqrt(2);\n\t\t\t\t\treturn Math.round(x/100*radius);\n\t\t\t\t\t\n\t\t\t\tcase opts.isHeightRelated:\n\t\t\t\t\treturn x/100*box.height;\n\t\t\t\t\t\n\t\t\t\tcase opts.isWidthRelated: default:\n\t\t\t\t\treturn x/100*box.width;\n\t\t\t\t\t\n\t\t\t}\n\n\t\t}\n\t}\n\n\tcssUnits.convertFromPixels.converters = {\n\t\t'px' : function(x) { return x; },\n\t\t'in' : function(x) { return x / 96; },\n\t\t'cm' : function(x) { return x * 0.02645833333; },\n\t\t'mm' : function(x) { return x * 0.26458333333; },\n\t\t'pt' : function(x) { return x * 0.75; },\n\t\t'pc' : function(x) { return x * 0.0625; },\n\t\t'em' : function(x, e) { return x/parseFloat(e?getComputedStyle(e).fontSize:16); },\n\t\t'rem': function(x, e) { return x/parseFloat(e?getComputedStyle(e.ownerDocument.documentElement).fontSize:16); },\n\t\t'vw' : function(x, e) { return x*100/window.innerWidth; },\n\t\t'vh' : function(x, e) { return x*100/window.innerHeight; },\n\t\t'%'  : function(x, e, opts) {\n\t\t\topts = opts || {};\n\n\t\t\t// get the box from which to compute the percentages\n\t\t\tvar box = e ? getBox(e, opts.boxType) : {\n\t\t\t\ttop: 0,\n\t\t\t\tleft: 0,\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\n\t\t\t// now apply the conversion algorithm\n\t\t\tswitch(true) {\n\t\t\t\tcase opts.isRadius:\n\t\t\t\t\tvar radius = Math.sqrt( box.height*box.height + box.width*box.width ) / Math.sqrt(2);\n\t\t\t\t\treturn Math.round(x*100/radius);\n\t\t\t\t\t\n\t\t\t\tcase opts.isHeightRelated:\n\t\t\t\t\treturn x*100/box.height;\n\t\t\t\t\t\n\t\t\t\tcase opts.isWidthRelated: default:\n\t\t\t\t\treturn x*100/box.width;\n\t\t\t\t\t\n\t\t\t}\n\n\n\t\t}\n\t};\n\t\n\treturn cssUnits;\n\n})(window, document);\nrequire.define('src/core/css-units.js');","module.exports = (function(window, document) { \"use strict\";\n\t\n\t// import dependencies\n\tvar cssSyntax = require('src/core/css-syntax.js');\n\t\n\tvar cssStyle  = require('src/core/css-style.js'),\n\t    usedStyleOf     = cssStyle.usedStyleOf,\n\t    currentStyleOf  = cssStyle.currentStyleOf,\n\t    enforceStyle    = cssStyle.enforceStyle,\n\t    restoreStyle    = cssStyle.restoreStyle;\n\t\t\n\tvar VirtualStylesheetFactory = require('src/core/css-virtual-stylesheet-factory.js');\n\t\n\trequire('src/core/polyfill-dom-uniqueID.js');\n\trequire('src/core/polyfill-dom-requestAnimationFrame.js');\n\t\n\tvar virtualStylesheetFactory = new VirtualStylesheetFactory();\n\t\n\tvar createRuntimeStyle = function(reason, element) {\n\t\t\n\t\t// expand the reason\n\t\tif(element) {\n\t\t\treason = (element.id || element.uniqueID) + '-' + reason;\n\t\t}\n\t\t\n\t\t// return a virtual stylesheet\n\t\treturn virtualStylesheetFactory.createStyleSheet(reason);\n\t\t\n\t}\n\t\n\tvar cssSizing = require('src/core/css-sizing.js');\n\t\n\tvar cssUnits = require('src/core/css-units.js');\n\t\n\t// define the module\n\tvar LOCATE_AUTO = 0;\n\tvar LOCATE_LINE = 1;\n\tvar LOCATE_SPAN = 2;\n\tvar LOCATE_AREA = 3;\n\t\n\tvar ALIGN_START  = 0;\n\tvar ALIGN_CENTER = 1;\n\tvar ALIGN_END    = 2;\n\tvar ALIGN_FIT    = 3;\n\t\n\tvar TRACK_BREADTH_AUTO        = 0;\n\tvar TRACK_BREADTH_LENGTH      = 1;\n\tvar TRACK_BREADTH_FRACTION    = 2;\n\tvar TRACK_BREADTH_PERCENTAGE  = 3;\n\tvar TRACK_BREADTH_MIN_CONTENT = 4;\n\tvar TRACK_BREADTH_MAX_CONTENT = 5;\n\t\n\tfunction GridTrackBreadth() {\n\t\tthis.minType = TRACK_BREADTH_AUTO;\n\t\tthis.minValue = \"auto\";\n\t\tthis.maxType = TRACK_BREADTH_AUTO;\n\t\tthis.maxValue = \"auto\";\n\t}\n\t\n\tGridTrackBreadth.prototype = {\n\t\ttoString: function() {\n\t\t\tif(this.minType==this.maxType && this.minValue==this.maxValue) {\n\t\t\t\tswitch(this.minType) {\n\t\t\t\t\tcase TRACK_BREADTH_AUTO: return \"auto\";\n\t\t\t\t\tcase TRACK_BREADTH_LENGTH: return this.minValue+\"px\";\n\t\t\t\t\tcase TRACK_BREADTH_FRACTION: return this.minValue+\"fr\";\n\t\t\t\t\tcase TRACK_BREADTH_PERCENTAGE: return this.minValue+\"%\";\n\t\t\t\t\tcase TRACK_BREADTH_MIN_CONTENT: return \"min-content\";\n\t\t\t\t\tcase TRACK_BREADTH_MAX_CONTENT: return \"max-content\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar min = \"auto\";\n\t\t\t\tvar max = \"auto\";\n\t\t\t\tswitch(this.minType) {\n\t\t\t\t\tcase TRACK_BREADTH_AUTO: min = \"auto\"; break;\n\t\t\t\t\tcase TRACK_BREADTH_LENGTH: min = this.minValue+\"px\"; break;\n\t\t\t\t\tcase TRACK_BREADTH_FRACTION: min = this.minValue+\"fr\"; break;\n\t\t\t\t\tcase TRACK_BREADTH_PERCENTAGE: min = this.minValue+\"%\"; break;\n\t\t\t\t\tcase TRACK_BREADTH_MIN_CONTENT: min = \"min-content\"; break;\n\t\t\t\t\tcase TRACK_BREADTH_MAX_CONTENT: min = \"max-content\"; break;\n\t\t\t\t}\n\t\t\t\tswitch(this.maxType) {\n\t\t\t\t\tcase TRACK_BREADTH_AUTO: max = \"auto\"; break;\n\t\t\t\t\tcase TRACK_BREADTH_LENGTH: max = this.maxValue+\"px\"; break;\n\t\t\t\t\tcase TRACK_BREADTH_FRACTION: max = this.maxValue+\"fr\"; break;\n\t\t\t\t\tcase TRACK_BREADTH_PERCENTAGE: max = this.maxValue+\"%\"; break;\n\t\t\t\t\tcase TRACK_BREADTH_MIN_CONTENT: max = \"min-content\"; break;\n\t\t\t\t\tcase TRACK_BREADTH_MAX_CONTENT: max = \"max-content\"; break;\n\t\t\t\t}\n\t\t\t\treturn \"minmax(\" + min + \", \" + max + \")\";\n\t\t\t}\n\t\t},\n\t\tsetValue: function(type, val) {\n\t\t\tthis.minType  = this.maxType  = type;\n\t\t\tthis.minValue = this.maxValue = val;\n\t\t},\n\t\tsetMaxValue: function(type, val) {\n\t\t\tthis.maxType  = type;\n\t\t\tthis.maxValue = val;\n\t\t},\n\t\tsetMinValue: function(type, val) {\n\t\t\tthis.minType  = type;\n\t\t\tthis.minValue = val;\n\t\t}\n\t}\n\t\n\tfunction GridItemPosition(type, name, index) {\n\t\tthis.type = type|LOCATE_AUTO;\n\t\tthis.name = name;\n\t\tthis.index = index|0;\n\t}\n\t\n\tGridItemPosition.prototype = {\n\t\textractXLineIndex: function(grid, TODO_args) {\n\t\t\tthrow \"Not implemented\";\n\t\t},\n\t\textractYLineIndex: function(grid, TODO_args) {\n\t\t\tthrow \"Not implemented\";\n\t\t},\n\t\ttoString: function() {\n\t\t\t\n\t\t}\n\t}\n\t\n\tfunction GridItem(element, parentGrid) {\n\t\t\n\t\tthis.element = element;\n\t\tthis.parentGrid = element.parentGridLayout = parentGrid;\n\t\t\n\t\tthis.reset();\n\t\tthis.buggy = true;\n\t\t\n\t}\n\t\n\tGridItem.prototype = {\n\t\t\n\t\tdispose: function() {\n\t\t\tthis.element.parentGridLayout = undefined;\n\t\t},\n\t\t\n\t\treset: function() {\n\t\t\t\n\t\t\tthis.order = 0;\n\t\t\t\n\t\t\tthis.minWidth = 0;\n\t\t\tthis.maxWidth = 0;\n\t\t\t\n\t\t\tthis.hMargins = 0;\n\t\t\tthis.vMargins = 0;\n\t\t\tthis.hPaddings = 0;\n\t\t\tthis.vPaddings = 0;\n\t\t\tthis.hBorders = 0;\n\t\t\tthis.vBorders = 0;\n\t\t\t\n\t\t\t\n\t\t\tthis.xStart = -1;\n\t\t\tthis.xEnd = -1;\n\t\t\t\n\t\t\tthis.specifiedXStart = this.specifiedXStart || new GridItemPosition();\n\t\t\tthis.specifiedXStart.type = LOCATE_AUTO;\n\t\t\tthis.specifiedXStart.name = undefined;\n\t\t\tthis.specifiedXStart.index = undefined;\n\t\t\t\n\t\t\tthis.specifiedXEnd = this.specifiedXEnd || new GridItemPosition();\n\t\t\tthis.specifiedXEnd.type = LOCATE_AUTO;\n\t\t\tthis.specifiedXEnd.name = undefined;\n\t\t\tthis.specifiedXEnd.index = undefined;\n\n\t\t\t\n\t\t\tthis.yStart = -1;\n\t\t\tthis.yEnd = -1;\n\t\t\t\n\t\t\tthis.specifiedYStart = this.specifiedYStart || new GridItemPosition();\n\t\t\tthis.specifiedYStart.type = LOCATE_AUTO;\n\t\t\tthis.specifiedYStart.name = undefined;\n\t\t\tthis.specifiedYStart.index = undefined;\n\t\t\t\n\t\t\tthis.specifiedYEnd = this.specifiedYEnd || new GridItemPosition();\n\t\t\tthis.specifiedYEnd.type = LOCATE_AUTO;\n\t\t\tthis.specifiedYEnd.name = undefined;\n\t\t\tthis.specifiedYEnd.index = undefined;\n\t\t\t\n\t\t\tthis.marginAlignX = ALIGN_CENTER;\n\t\t\tthis.marginAlignY = ALIGN_CENTER;\n\t\t\t\n\t\t\tthis.paddingAlignX = ALIGN_FIT;\n\t\t\tthis.paddingAlignY = ALIGN_FIT;\n\t\t\t\n\t\t\t\n\t\t},\n\t\n\t\tupdateFromElement: function() {\n\t\t\t\n\t\t\tvar element = this.element;\n\t\t\tvar usedStyle = usedStyleOf(element);\n\t\t\tvar style = currentStyleOf(element);\n\t\t\tvar getStyle = function(prop) {\n\t\t\t\tvar value = style[prop];\n\t\t\t\tif(typeof(value)==\"undefined\") { return \"\"; }\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\t\n\t\t\tthis.reset(); \n\t\t\tthis.buggy = false;\n\t\t\t\n\t\t\t// compute order property\n\t\t\tthis.order = parseInt(style['order'])|0;\n\t\t\t\n\t\t\t// compute size\n\t\t\tthis.minWidth = cssSizing.minWidthOf(element);\n\t\t\tthis.maxWidth = cssSizing.maxWidthOf(element);\n\t\t\t\n\t\t\tthis.hMargins = parseInt(usedStyle.getPropertyValue('margin-left')) + parseInt(usedStyle.getPropertyValue('margin-right'));\n\t\t\tthis.vMargins = parseInt(usedStyle.getPropertyValue('margin-top')) + parseInt(usedStyle.getPropertyValue('margin-bottom'));\n\t\t\tthis.hPaddings = parseInt(usedStyle.getPropertyValue('padding-left')) + parseInt(usedStyle.getPropertyValue('padding-right'));\n\t\t\tthis.vPaddings = parseInt(usedStyle.getPropertyValue('padding-top')) + parseInt(usedStyle.getPropertyValue('padding-bottom'));\n\t\t\tthis.hBorders = parseInt(usedStyle.getPropertyValue('border-left-width')) + parseInt(usedStyle.getPropertyValue('border-right-width'));\n\t\t\tthis.vBorders = parseInt(usedStyle.getPropertyValue('border-top-width')) + parseInt(usedStyle.getPropertyValue('border-bottom-width'));\n\t\t\t\n\t\t\t// locate x and y lines together\n\t\t\tif(style[\"grid-area\"]) {\n\t\t\t\tvar parts = getStyle(\"grid-area\").split('/');\n\t\t\t\tvar is_ident = /^\\s*([a-z][-_a-z0-9]*)\\s*$/i;\n\t\t\t\tvar row_start = parts[0] || 'auto';\n\t\t\t\tvar col_start = parts[1] || (is_ident.test(row_start) ? row_start : 'auto');\n\t\t\t\tvar row_end = parts[2] || (is_ident.test(row_start) ? row_start : 'auto');\n\t\t\t\tvar col_end = parts[3] || (is_ident.test(col_start) ? col_start : 'auto');\n\t\t\t\tthis.parseLocationInstructions(this.specifiedXStart, this.specifiedXEnd, col_start + \" / \" + col_end);\n\t\t\t\tthis.parseLocationInstructions(this.specifiedYStart, this.specifiedYEnd, row_start + \" / \" + row_end);\n\t\t\t}\n\t\t\t\n\t\t\t// locate x lines\n\t\t\tif(style[\"grid-column\"] || style[\"grid-column-start\"] || style[\"grid-column-end\"]) {\n\t\t\t\tvar parts = getStyle(\"grid-column\").split('/');\n\t\t\t\tvar start = getStyle(\"grid-column-start\") || parts[0] || 'auto';\n\t\t\t\tvar end   = getStyle(\"grid-column-end\") || parts[1] || parts[0] || start;\n\t\t\t\tthis.parseLocationInstructions(this.specifiedXStart, this.specifiedXEnd, start + \" / \" + end);\n\t\t\t}\n\t\t\t\n\t\t\t// locate y lines\n\t\t\tif(style[\"grid-row\"] || style[\"grid-row-start\"] || style[\"grid-row-end\"]) {\n\t\t\t\tvar parts = getStyle(\"grid-row\").split('/');\n\t\t\t\tvar start = getStyle(\"grid-row-start\") || parts[0];\n\t\t\t\tvar end   = getStyle(\"grid-row-end\") || parts[1] || parts[0];\n\t\t\t\tthis.parseLocationInstructions(this.specifiedYStart, this.specifiedYEnd, start + \" / \" + end);\n\t\t\t}\n\t\t\t\n\t\t\t// FIXME: is it possible to understand cascading here, and not use a fixed order?\n\t\t\t// TODO: other positioning methods\n\t\t\t\n\t\t},\n\t\t\n\t\tparseLocationInstructions: function(specifiedStart, specifiedEnd, cssText) {\n\t\t\t\n\t\t\tvar unfiltred_value = cssSyntax.parseCSSValue(cssText);\n\t\t\tvar value = unfiltred_value.filter(function(o) { return !(o instanceof cssSyntax.WhitespaceToken); });\n\t\t\tvalue.toCSSString = function() { return unfiltred_value.toCSSString(); }\n\t\t\tvar I = 0;\n\t\t\t\n\t\t\tvar updateNameOrIndex = function(data) {\n\t\t\t\tif(value[I] instanceof cssSyntax.IdentifierToken) {\n\t\t\t\t\t\n\t\t\t\t\t// grid-column: C;\n\t\t\t\t\tif(data.name) { \n\t\t\t\t\t\t// duplicate line-name value\n\t\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (duplicate line name)\");\n\t\t\t\t\t\tthis.buggy = true;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tdata.name = value[I++].value;\n\t\t\t\t\treturn false;\n\t\t\t\t\t\n\t\t\t\t} else if(value[I] instanceof cssSyntax.NumberToken) {\n\t\t\t\t\t\n\t\t\t\t\t// grid-column: 3\n\t\t\t\t\tdata.index = value[I].value|0;\n\t\t\t\t\t\n\t\t\t\t\t// only accept integer values\n\t\t\t\t\tif(value[I].value != data.index) {\n\t\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (non-integer number)\");\n\t\t\t\t\t\tthis.buggy = true;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// do not accept zero\n\t\t\t\t\tif(data.index == 0) {\n\t\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (line index can't be zero)\");\n\t\t\t\t\t\tthis.buggy = true;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// do not accept negative spans\n\t\t\t\t\tif(data.index <= 0 && data.type == LOCATE_SPAN) {\n\t\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (negative spans not allowed)\");\n\t\t\t\t\t\tthis.buggy = true;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tI++;\n\t\t\t\t\t\n\t\t\t\t\treturn false;\n\t\t\t\t\t\n\t\t\t\t} else if(value[I] instanceof cssSyntax.DelimToken && value[I].value == \"/\") {\n\t\t\t\t\t\n\t\t\t\t\t// break grid-column-start detection\n\t\t\t\t\treturn true;\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\t// this is wrong\n\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (invalid token)\");\n\t\t\t\t\tthis.buggy = true;\n\t\t\t\t\treturn true;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t\tvar gatherNameIndexPair = function(data) {\n\n\t\t\t\t// first token to be analyzed (may be either kind)\n\t\t\t\tupdateNameOrIndex.call(this, data);\n\t\t\t\t\n\t\t\t\t// abort if no second token or buggy\n\t\t\t\tif(this.buggy || !value[I]) { return; }\n\t\t\t\n\t\t\t\t// second token to be analyzed (will have to be the other kind)\n\t\t\t\tupdateNameOrIndex.call(this, data);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(!value[I]) { console.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (empty declaration)\"); this.buggy = true; return; }\n\t\t\t\n\n\t\t\t// first part\n\t\t\tgridColumnStart: while(true) {\n\t\t\t\tif(value[I] instanceof cssSyntax.IdentifierToken) {\n\t\t\t\t\t\n\t\t\t\t\tif(value[I].value == \"span\") {\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!value[++I]) {console.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (span is not a valid line name, more tokens expected)\"); this.buggy = true; return; }\n\t\t\t\t\t\t\n\t\t\t\t\t\tspecifiedStart.type = LOCATE_SPAN;\n\t\t\t\t\t\tspecifiedStart.name = undefined;\n\t\t\t\t\t\tspecifiedStart.index = undefined;\n\t\t\t\t\t\tgatherNameIndexPair.call(this, specifiedStart);\n\t\t\t\t\t\tif(this.buggy) { return; }\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\t} else if(value[I].value == \"auto\") {\n\t\t\t\t\t\t\n\t\t\t\t\t\tspecifiedStart.type = LOCATE_AUTO;\n\t\t\t\t\t\tspecifiedStart.name = undefined;\n\t\t\t\t\t\tspecifiedStart.index = undefined;\n\t\t\t\t\t\tI++; break;\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\t\t// grid-column: start-line...\n\t\t\t\t\t\tspecifiedStart.type = LOCATE_LINE;\n\t\t\t\t\t\tspecifiedStart.name = undefined;\n\t\t\t\t\t\tspecifiedStart.index = undefined;\n\t\t\t\t\t\tgatherNameIndexPair.call(this, specifiedStart);\n\t\t\t\t\t\tif(this.buggy) { return; }\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else if(value[I] instanceof cssSyntax.DelimToken && value[I].value == \"/\") {\n\t\t\t\t\t\n\t\t\t\t\t// this is wrong\n\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (no token to analyze before the slash token)\");\n\t\t\t\t\tthis.buggy = true;\n\t\t\t\t\treturn;\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tspecifiedStart.type = LOCATE_LINE;\n\t\t\t\t\tgatherNameIndexPair.call(this, specifiedStart);\n\t\t\t\t\tif(this.buggy) { return; }\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t// test whether there is a second part\n\t\t\tif(value[I]) {\n\t\t\t\t\n\t\t\t\tif(value[I] instanceof cssSyntax.DelimToken && value[I].value == \"/\") {\n\t\t\t\t\t\n\t\t\t\t\t// second part will start now\n\t\t\t\t\tif(!value[++I]) {\n\t\t\t\t\t\t// unexpected lack token at the start of the second part\n\t\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (expected at least one more token after the slash token)\");\n\t\t\t\t\t\tthis.buggy = true; \n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\n\t\t\t\t\t// unexpected token at the end of the first part\n\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (expected slash / or end of declaration)\");\n\t\t\t\t\tthis.buggy = true; \n\t\t\t\t\treturn;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// end of declaration\n\t\t\t\tif(specifiedStart.type == LOCATE_LINE && specifiedStart.name != undefined && specifiedStart.index == undefined) {\n\t\t\t\t\t// a value consisting of a custom ident is duplicated to the other side\n\t\t\t\t\tspecifiedEnd.type = LOCATE_LINE;\n\t\t\t\t\tspecifiedEnd.name = specifiedStart.name;\n\t\t\t\t\tspecifiedEnd.index = undefined;\n\t\t\t\t} else {\n\t\t\t\t\t// the default value (auto) is a 1-line span in all other cases\n\t\t\t\t\tspecifiedEnd.type = LOCATE_AUTO;\n\t\t\t\t\tspecifiedEnd.name = undefined;\n\t\t\t\t\tspecifiedEnd.index = undefined;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// second part (after the \"/\" token)\n\t\t\tgridColumnEnd: while(value[I]) {\n\t\t\t\t\n\t\t\t\tif(value[I] instanceof cssSyntax.IdentifierToken) {\n\t\t\t\t\t\n\t\t\t\t\tif(value[I].value == \"span\") {\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!value[++I]) {console.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (span is not a valid line name, more tokens expected)\"); this.buggy = true; return; }\n\t\t\t\t\t\t\n\t\t\t\t\t\tspecifiedEnd.type = LOCATE_SPAN;\n\t\t\t\t\t\tspecifiedEnd.name = undefined;\n\t\t\t\t\t\tspecifiedEnd.index = undefined;\n\t\t\t\t\t\tgatherNameIndexPair.call(this, specifiedEnd);\n\t\t\t\t\t\tif(this.buggy) { return; }\n\t\t\t\t\t\n\t\t\t\t\t} else if(value[I].value == \"auto\") {\n\t\t\t\t\t\t\n\t\t\t\t\t\tspecifiedEnd.type = LOCATE_AUTO;\n\t\t\t\t\t\tspecifiedEnd.name = undefined;\n\t\t\t\t\t\tspecifiedEnd.index = undefined;\n\t\t\t\t\t\tI++; break;\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\t\t// grid-column: start-line...\n\t\t\t\t\t\tspecifiedEnd.type = LOCATE_LINE;\n\t\t\t\t\t\tspecifiedEnd.name = undefined;\n\t\t\t\t\t\tspecifiedEnd.name = undefined;\n\t\t\t\t\t\tspecifiedEnd.index = undefined;\n\t\t\t\t\t\tgatherNameIndexPair.call(this, specifiedEnd);\n\t\t\t\t\t\tif(this.buggy) { return; }\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else if(value[I] instanceof cssSyntax.DelimToken && value[I].value == \"/\") {\n\t\t\t\t\t\n\t\t\t\t\t// this is wrong\n\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (no token to analyze before the slash token)\");\n\t\t\t\t\tthis.buggy = true;\n\t\t\t\t\treturn;\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tspecifiedEnd.type = LOCATE_LINE;\n\t\t\t\t\tgatherNameIndexPair.call(this, specifiedEnd);\n\t\t\t\t\tif(this.buggy) { return; }\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(value[I]) {\n\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (tokens after end)\");\n\t\t\t\tthis.buggy = true; \n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t// If the <integer> is omitted, it defaults to 1.\n\t\t\t//if(specifiedStart.name && specifiedStart.index == undefined) { specifiedStart.index = 1; }\n\t\t\t//if(specifiedEnd.name && specifiedEnd.index == undefined) { specifiedEnd.index = 1; }\n\t\t\t\n\t\t\t// If both grid-row/column-start and grid-row/column-end specify a span, the end span is ignored. \n\t\t\tif(specifiedEnd.type == LOCATE_SPAN && specifiedStart.type == LOCATE_SPAN) { specifiedEnd.type = LOCATE_AUTO; specifiedEnd.index = undefined; specifiedEnd.name = undefined; }\n\t\t\t\n\t\t\treturn [specifiedStart, specifiedEnd];\n\t\t\t\n\t\t},\n\t\t\n\t\n\t};\t\n\n\tfunction GridLayout(element) {\n\t\n\t\t// items\n\t\tthis.element = element; this.element.gridLayout = this;\n\t\tthis.items = []; // array of GridItem\n\n\t\t// reset\n\t\tthis.reset();\n\t\t\n\t\t// other fields\n\t\tthis.isLayoutScheduled = false;\n\t\t\n\t}\n\t\n\tGridLayout.prototype = {\n\t\n\t\treset: function() {\n\t\t\t\n\t\t\t// layout exclusion style\n\t\t\tthis.hlPadding = 0;\n\t\t\tthis.hrPadding = 0;\n\t\t\tthis.vtPadding = 0;\n\t\t\tthis.vbPadding = 0;\n\t\t\tthis.rowGap = 0;\n\t\t\tthis.colGap = 0;\n\t\t\t\n\t\t\t// computed\n\t\t\tthis.xLines = []; // array of array of names\n\t\t\tthis.xSizes = []; // array of numbers (in pixels)\n\t\t\t\n\t\t\tthis.yLines = [];\n\t\t\tthis.ySizes = [];\n\n\t\t\tthis.growX = false;\n\t\t\tthis.growY = true;\n\t\t\tthis.growDense = false;\n\t\t\t\n\t\t\tthis.rcMatrix = []; // array of array of (whatever is not undefined, probably \"true\")\n\t\t\t\n\t\t\t// specified\n\t\t\tthis.specifiedXLines = [];\n\t\t\tthis.specifiedXSizes = [];\n\t\t\t\n\t\t\tthis.specifiedYLines = [];\n\t\t\tthis.specifiedYSizes = [];\n\t\t\t\n\t\t\tthis.defaultXSize = new GridTrackBreadth();\n\t\t\tthis.defaultYSize = new GridTrackBreadth();\n\n\t\t},\n\t\n\t\tR: function R(x,y) { \n\t\t\tif(this.growY) {\n\t\t\t\t// we grow by adding rows (normal behavior)\n\t\t\t\treturn y;\n\t\t\t} else {\n\t\t\t\t// we grow by adding columns (inversed behavior)\n\t\t\t\treturn x;\n\t\t\t}\n\t\t},\n\t\t\n\t\tC: function C(x,y) { \n\t\t\tif(this.growY) {\n\t\t\t\t// we grow by adding rows (normal behavior)\n\t\t\t\treturn x;\n\t\t\t} else {\n\t\t\t\t// we grow by adding columns (inversed behavior)\n\t\t\t\treturn y;\n\t\t\t}\n\t\t},\n\t\t\n\t\tdispose: function() {\n\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i];\n\t\t\t\titem.dispose();\n\t\t\t}\n\t\t\tthis.element.gridLayout = undefined;\n\t\t},\n\t\t\n\t\tupdateFromElement: function() {\n\t\t\t\n\t\t\t// delete old items\n\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i];\n\t\t\t\titem.dispose();\n\t\t\t}\n\t\t\t\n\t\t\t// add new items\n\t\t\tthis.items.length = 0;\n\t\t\tvar currentItem = this.element.firstElementChild;\n\t\t\twhile(currentItem) {\n\t\t\t\t\n\t\t\t\t// add a new grid item for the element\n\t\t\t\tvar newGridItem = new GridItem(currentItem, this);\n\t\t\t\tnewGridItem.updateFromElement();\n\t\t\t\tthis.items.push(newGridItem);\n\t\t\t\t\n\t\t\t\t// move to the next element\n\t\t\t\tcurrentItem = currentItem.nextElementSibling;\n\t\t\t}\n\t\t\t\n\t\t\t// sort them by css order (desc) then by dom order (asc)\n\t\t\tvar sortableItems = this.items.map(function(item, i) { return { item: item, order: item.order, position: i } });\n\t\t\tsortableItems.sort(function(a,b) { if(a.order==b.order) { return a.position-b.position } else if(a.order>b.order) { return +1 } else { return -1; } });\n\t\t\tthis.items = sortableItems.map(function(data) { return data.item; });\n\t\t\t\n\t\t\t// reset the style\n\t\t\tthis.reset();\n\t\t\t\n\t\t\t// update its own style\n\t\t\tvar style = usedStyleOf(this.element); var cssText = '';\n\t\t\tif(cssText=style[\"grid-template\"])         { this.parseGridTemplate(cssText);    }\n\t\t\tif(cssText=style[\"grid-template-rows\"])    { this.parseRowsTemplate(cssText);    }\n\t\t\tif(cssText=style[\"grid-template-columns\"]) { this.parseColumnsTemplate(cssText); }\n\t\t\tif(cssText=style[\"grid-template-areas\"])   { this.parseAreasTemplate(cssText);   }\n\t\t\tif(cssText=style[\"grid-auto-rows\"]) { this.parseAutoRowsBreadth(cssText); }\n\t\t\tif(cssText=style[\"grid-auto-columns\"]) { this.parseAutoColumnsBreadth(cssText); }\n\t\t\tif(cssText=style[\"grid-auto-flow\"]) { // FIXME: should be in a function\n\t\t\t\t\n\t\t\t\t// FIXME: not a real parse...\n\t\t\t\tvar tokens = cssText.trim().toLowerCase().split(/\\s+/g);\n\t\t\t\t\n\t\t\t\t// direction\n\t\t\t\tif(tokens.indexOf('row')>=0) {\n\t\t\t\t\tthis.growX = false;\n\t\t\t\t\tthis.growY = true;\n\t\t\t\t} else if(tokens.indexOf('column')>=0) {\n\t\t\t\t\tthis.growX = true;\n\t\t\t\t\tthis.growY = false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// algorithm\n\t\t\t\t// FIXME: should also support 'stack' (wtf)\n\t\t\t\tif(tokens.indexOf('dense')>=0) {\n\t\t\t\t\tthis.growDense = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis.growDense = false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tif(cssText=style[\"grid-row-gap\"]) { this.parseGridRowGap(cssText); }\n\t\t\tif(cssText=style[\"grid-column-gap\"]) { this.parseGridColumnGap(cssText); }\n\t\t\tif(cssText=style[\"grid-gap\"]) { this.parseGridGap(cssText); }\n\t\t\t\n\t\t\tvar usedStyle = style;\n\t\t\tthis.hlPadding = parseInt(usedStyle.getPropertyValue('border-left-width')) + parseInt(usedStyle.getPropertyValue('padding-left'));\n\t\t\tthis.hrPadding = parseInt(usedStyle.getPropertyValue('border-right-width')) + parseInt(usedStyle.getPropertyValue('padding-right'));\n\t\t\tthis.vtPadding = parseInt(usedStyle.getPropertyValue('border-top-width')) + parseInt(usedStyle.getPropertyValue('padding-top'));\n\t\t\tthis.vbPadding = parseInt(usedStyle.getPropertyValue('border-bottom-width')) + parseInt(usedStyle.getPropertyValue('padding-bottom'));\n\t\t\t\n\t\t},\n\t\t\n\t\tresetItems: function() {\n\t\t\tfor(var i = this.items.length; i--;) {\n\t\t\t\tvar item = this.items[i]; \n\t\t\t\titem.xStart = item.xEnd = item.yStart = item.yEnd = -1;\n\t\t\t}\n\t\t},\n\t\t\n\t\tresetLinesToSpecified: function() {\n\t\t\tthis.xLines = this.specifiedXLines.slice(0);\n\t\t\tthis.xSizes = this.specifiedXSizes.slice(0);\n\t\t\tthis.yLines = this.specifiedYLines.slice(0);\n\t\t\tthis.ySizes = this.specifiedYSizes.slice(0);\n\t\t},\n\t\t\n\t\tparseTrackBreadthToken: function(cssToken) {\n\t\t\t\n\t\t\t// try to match a pattern\n\t\t\tif(cssToken instanceof cssSyntax.IdentifierToken) {\n\t\t\t\t\n\t\t\t\tif(cssToken.value == \"auto\") {\n\t\t\t\t\treturn { type: TRACK_BREADTH_AUTO, value:\"auto\" };\n\t\t\t\t} else if(cssToken.value == \"min-content\") {\n\t\t\t\t\treturn { type: TRACK_BREADTH_MIN_CONTENT, value:\"min-content\" };\n\t\t\t\t} else if(cssToken.value == \"max-content\") {\n\t\t\t\t\treturn { type: TRACK_BREADTH_MAX_CONTENT, value:\"max-content\" };\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if(cssToken instanceof cssSyntax.DimensionToken) {\n\t\t\t\t\n\t\t\t\tif(cssToken.unit == \"fr\") {\n\t\t\t\t\treturn { type: TRACK_BREADTH_FRACTION, value:cssToken.value };\n\t\t\t\t} else {\n\t\t\t\t\treturn { type: TRACK_BREADTH_LENGTH, value:cssUnits.convertToPixels(cssToken.toCSSString(), this.element) };\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if(cssToken instanceof cssSyntax.PercentageToken) {\n\t\t\t\t\n\t\t\t\treturn { type: TRACK_BREADTH_PERCENTAGE, value:cssToken.value };\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// TODO: recognize \"calc()\", too\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\tparseTrackBreadth: function(value, I) {\n\t\t\n\t\t\t// TODO: try catch on null parsed token\n\t\t\tvar buggy = false;\n\t\t\t\n\t\t\tvar currentTrackBreadth = new GridTrackBreadth();\n\t\t\tvar parseTrackBreadthToken = function() {\n\t\t\t\t\n\t\t\t\t// try to match a pattern\n\t\t\t\tvar result = this.parseTrackBreadthToken(value[I]);\n\t\t\t\tif(result) { I++; return result; }\n\t\t\t\t\n\t\t\t\t// no pattern matched, so the declaration is invalid:\n\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-template-rows/columns: \"+value.toCSSString()+\" (unrecognized track breadth)\");\n\t\t\t\tbuggy = true;\n\t\t\t\treturn;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(value[I] instanceof cssSyntax.Func && value[I].name==\"minmax\") {\n\t\t\t\t\n\t\t\t\t// we need to parse two subvalues\n\t\t\t\tvar value_backup = value;\n\t\t\t\tvar I_backup = I;\n\t\t\t\t\n\t\t\t\t// check we have exactly two arguments\n\t\t\t\tvar args = value_backup[I_backup].getArguments();\n\t\t\t\tif(args.length != 2) { \n\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-template-rows/columns: \"+value_backup.toCSSString()+\" (invalid number of arguments to the minmax function)\");\n\t\t\t\t\tbuggy = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// here's the first one:\n\t\t\t\tvalue = args[0].filter(function(t) { return !(t instanceof cssSyntax.WhitespaceToken) }); I = 0;\t\t\t\t\n\t\t\t\tvar data = parseTrackBreadthToken.call(this);\n\t\t\t\tcurrentTrackBreadth.minType = data.type;\n\t\t\t\tcurrentTrackBreadth.minValue = data.value;\n\t\t\t\t\n\t\t\t\t// here's the second one:\n\t\t\t\tvalue = args[1].filter(function(t) { return !(t instanceof cssSyntax.WhitespaceToken) }); I = 0;\t\t\t\t\n\t\t\t\tvar data = parseTrackBreadthToken.call(this);\n\t\t\t\tcurrentTrackBreadth.maxType  = data.type;\n\t\t\t\tcurrentTrackBreadth.maxValue = data.value;\n\t\t\t\t\n\t\t\t\t// restore context\n\t\t\t\tvalue = value_backup;\n\t\t\t\tI = I_backup+1;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\n\t\t\t\t// we need to parse only one value\n\t\t\t\tvar data = parseTrackBreadthToken.call(this);\n\t\t\t\tcurrentTrackBreadth.minType  = currentTrackBreadth.maxType  = data.type;\n\t\t\t\tcurrentTrackBreadth.minValue = currentTrackBreadth.maxValue = data.value;\n\n\t\t\t}\n\t\t\t\t\n\t\t\treturn { result: currentTrackBreadth, I:I };\n\t\t\t\n\t\t},\n\t\t\n\t\tparseAutoRowsBreadth: function(cssText) {\n\t\t\n\t\t\t// TODO: check that no tokens are left when the parsing is done (+columns)\n\t\t\t\n\t\t\t// parse value into tokens:\n\t\t\tvar unfiltred_value = cssSyntax.parseCSSValue(cssText);\n\t\t\tvar value = unfiltred_value.filter(function(o) { return !(o instanceof cssSyntax.WhitespaceToken); });\n\t\t\tvalue.toCSSString = function() { return unfiltred_value.toCSSString(); }\n\t\t\t\n\t\t\t// parse tokens into data:\n\t\t\tvar data = this.parseTrackBreadth(value, 0);\n\t\t\tif(data.result) { this.defaultYSize = data.result; } else { throw \"TODO: better error message\"; }\n\t\t\treturn;\n\t\t\t\n\t\t},\n\t\t\n\t\tparseAutoColumnsBreadth: function(cssText) {\n\t\t\t\n\t\t\t// parse value into tokens:\n\t\t\tvar unfiltred_value = cssSyntax.parseCSSValue(cssText);\n\t\t\tvar value = unfiltred_value.filter(function(o) { return !(o instanceof cssSyntax.WhitespaceToken); });\n\t\t\tvalue.toCSSString = function() { return unfiltred_value.toCSSString(); }\n\t\t\t\n\t\t\t// parse tokens into data:\n\t\t\tvar data = this.parseTrackBreadth(value, 0);\n\t\t\tif(data.result) { this.defaultXSize = data.result; } else { throw \"TODO: better error message\"; }\n\t\t\treturn;\n\t\t\t\n\t\t},\n\t\t\n\t\tparseGridTemplate: function(cssText) { // TODO: I used some lazy heuristics here\n\t\t\tvar buggy = false; \n\t\t\n\t\t\t// step 1: columns are defined before the slash, if any\n\t\t\tvar cssText = cssText.replace(/\\/\\*(.*?)\\*\\//g,\"\");\n\t\t\tvar cssTextSections = cssText.split(\"/\");\n\t\t\tif(cssTextSections.length == 2) {\n\t\t\t\tif(this.parseColumnsTemplate(cssTextSections[0])) { return buggy=true; }\n\t\t\t\tcssText = cssTextSections[1];\n\t\t\t}\n\t\t\t\n\t\t\t// check that the syntax makes sense\n\t\t\telse if(cssTextSections.length >= 3) { \n\t\t\t\treturn buggy=true;\n\t\t\t}\n\t\t\t\n\t\t\t// check if we can find any string\n\t\t\tif(/\"|'/.test(cssText)) {\n\t\t\t\n\t\t\t\t// extract strings from the value\n\t\t\t\tvar strings = [];\n\t\t\t\tcssText = cssText.replace(/\\s*(\"(?:.*?)\"|'(?:.*?)')\\s*([-_a-zA-Z0-9]*)\\s*/g,function(data,str,size) { strings.push(str); return ' '+(size||\"auto\")+' '; });\n\t\t\t\t\n\t\t\t\t// remove duplicate line name blocks\n\t\t\t\tcssText = cssText.replace(/\\)\\s*\\(/g,\" \");\n\t\t\t\t\n\t\t\t\t// parse rows now\n\t\t\t\tif(this.parseRowsTemplate(cssText)) { return buggy=true; }\n\t\t\t\t\n\t\t\t\t// parse areas now\n\t\t\t\tif(this.parseAreasTemplate(strings.join(' '))) { return buggy=true; }\n\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// parse rows now\n\t\t\t\tif(this.parseRowsTemplate(cssText)) { return buggy=true; }\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn buggy;\n\t\t\t\n\t\t},\n\t\t\n\t\tparseAreasTemplate: function(cssText) {\n\t\t\t\n\t\t\t// parse value into tokens:\n\t\t\tvar unfiltred_value = cssSyntax.parseCSSValue(cssText);\n\t\t\tvar value = unfiltred_value.filter(function(o) { return !(o instanceof cssSyntax.WhitespaceToken); });\n\t\t\tvalue.toCSSString = function() { return unfiltred_value.toCSSString(); }\n\t\t\t\n\t\t\t// parse tokens into data:\n\t\t\tvar I = 0;\n\t\t\tvar buggy = false;\n\t\t\tvar regexp = /^([-_a-zA-Z0-9]+|[.]+)\\s*/;\n\t\t\tvar grid = [], areas = Object.create(null);\n\t\t\twhile(value[I]) {\n\t\t\t\t\n\t\t\t\tvar str = ''+value[I++].value;\n\t\t\t\t\n\t\t\t\tvar columns = [];\n\t\t\t\twhile(str!=='') {\n\t\t\t\t\t\n\t\t\t\t\t// extract next token\n\t\t\t\t\tvar data = regexp.exec(str); if(!data || data.length != 2) { return buggy=true; }\n\t\t\t\t\tstr = str.substr(data[0].length); var cell = data[1];\n\t\t\t\t\t\n\t\t\t\t\t// update cell max pos (ignore empty cells)\n\t\t\t\t\tif(cell!='.' && cell[0]!='.') {\n\t\t\t\t\t\tif(!areas[cell]) { areas[cell] = { xStart:columns.length, xEnd:columns.length+1, yStart: I-1, yEnd: I }; }\n\t\t\t\t\t\tif(areas[cell].xStart > columns.length) { return buggy=true; } \n\t\t\t\t\t\tif(areas[cell].yStart > I-1) { return buggy=true; }\n\t\t\t\t\t\tareas[cell].xEnd = Math.max(areas[cell].xEnd, columns.length+1);\n\t\t\t\t\t\tareas[cell].yEnd = Math.max(areas[cell].yEnd, I);\n\t\t\t\t\t}\n\t\t\t\t\t// add the cell to this row\n\t\t\t\t\tcolumns.push(data[1]);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tgrid.push(columns);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// validate areas\n\t\t\tfor(var a in areas) {\n\t\t\t\tvar area = areas[a];\n\t\t\t\tfor(var y = area.yStart; y<area.yEnd; y++) {\n\t\t\t\t\tfor(var x = area.xStart; x<area.xEnd; x++) {\n\t\t\t\t\t\tif(grid[y][x] != a) { return buggy=true; }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// add autogenerated line names\n\t\t\tfor(var a in areas) {\n\t\t\t\tvar area = areas[a];\n\t\t\t\t\n\t\t\t\t// make sure we have enough y lines for the areas to fit:\n\t\t\t\twhile(this.specifiedYLines.length<=area.yEnd) {\n\t\t\t\t\tthis.specifiedYLines.push([]);\n\t\t\t\t\tthis.specifiedYSizes.push(this.defaultYSize);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// add the y line name\n\t\t\t\tthis.specifiedYLines[area.yStart].push(a+\"-start\");\n\t\t\t\tthis.specifiedYLines[area.yEnd].push(a+\"-end\");\n\t\t\t\t\n\t\t\t\t// make sure we have enough x lines for the areas to fit:\n\t\t\t\twhile(this.specifiedXLines.length<=area.xEnd) {\n\t\t\t\t\tthis.specifiedXLines.push([]);\n\t\t\t\t\tthis.specifiedXSizes.push(this.defaultXSize);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// add the x line name\n\t\t\t\tthis.specifiedXLines[area.xStart].push(a+\"-start\");\n\t\t\t\tthis.specifiedXLines[area.xEnd].push(a+\"-end\");\n\t\t\t\t\n\t\t\t}\n\n\t\t},\n\t\t\n\t\tparseTrackDefinitions: function(lineNames, trackBreadths, cssText) {\n\t\t\t\n\t\t\t// replace the repeat() function by its full representation\n\t\t\tcssText = cssText.replace(/\\[/g,'(').replace(/\\]/g,')').replace(/repeat\\(\\s*([0-9]+)\\s*\\,((?:\\([^()]*\\)|[^()])+)\\)/gi, function(s, n, v) {\n\t\t\t\tvar result = ' ';\n\t\t\t\tfor(var i = parseInt(n); i--;) { \n\t\t\t\t\tresult += v + ' ';\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t});\n\t\t\t'TODO: improve the repeat support';\n\t\t\t\n\t\t\t// merge duplicate name-definitions\n\t\t\tcssText = cssText.replace(/\\)\\s*\\(/g, ' ');\n\t\t\t'TODO: improve the duplicate name-definitions support';\n\t\t\t\n\t\t\t// parse value into tokens:\n\t\t\tvar unfiltred_value = cssSyntax.parseCSSValue(cssText);\n\t\t\tvar value = unfiltred_value.filter(function(o) { return !(o instanceof cssSyntax.WhitespaceToken); });\n\t\t\tvalue.toCSSString = function() { return unfiltred_value.toCSSString(); }\n\t\t\t\n\t\t\t// parse tokens into data:\n\t\t\tvar I = 0;\n\t\t\tvar buggy = false;\n\t\t\t\n\t\t\tvar parseLineNames = function() {\n\t\t\t\t\n\t\t\t\tvar currentLineNames = []; // array of string\n\t\t\t\t\n\t\t\t\tif(value[I] instanceof cssSyntax.SimpleBlock && value[I].name == \"(\") {\n\t\t\t\t\tvar tokens = value[I].value;\n\t\t\t\t\tfor(var J=tokens.length; J--;) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (tokens[J] instanceof cssSyntax.IdentifierToken) {\n\t\t\t\t\t\t\tcurrentLineNames.push(tokens[J].value);\n\t\t\t\t\t\t} else if (tokens[J] instanceof cssSyntax.WhitespaceToken) {\n\t\t\t\t\t\t\t// ignore\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// unrecognized token, so the declaration is invalid:\n\t\t\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-template-rows/columns: \"+value.toCSSString()+\" (unrecognized line name)\");\n\t\t\t\t\t\t\tbuggy = true;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tI++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlineNames.push(currentLineNames); \n\t\t\t\tcurrentLineNames = [];\n\t\t\t\t\n\t\t\t};\n\t\t\t\n\t\t\tvar parseTrackBreadth = function() {\n\t\t\t\t\n\t\t\t\tvar data = this.parseTrackBreadth(value, I);\n\t\t\t\ttrackBreadths.push(data.result);\n\t\t\t\tI = data.I;\n\t\t\t\t\n\t\t\t};\n\t\t\t\n\t\t\tparseLineNames(); \n\t\t\twhile(value[I]) {\n\t\t\t\tparseTrackBreadth.call(this); if(buggy) { break; }\n\t\t\t\tparseLineNames(); if(buggy) { break; }\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\tparseColumnsTemplate: function(cssText) {\n\t\t\treturn this.parseTrackDefinitions(this.specifiedXLines, this.specifiedXSizes, cssText);\n\t\t},\n\t\t\n\t\tparseRowsTemplate: function(cssText) {\n\t\t\treturn this.parseTrackDefinitions(this.specifiedYLines, this.specifiedYSizes, cssText);\n\t\t},\n\t\t\n\t\tparseTracksTemplate: function(columnsTemplate, rowsTemplate, areasTemplate) {\n\t\t\tif(rowsTemplate   ) this.parseRowsTemplate(rowsTemplate);\n\t\t\tif(columnsTemplate) this.parseColumnsTemplate(columnsTemplate);\n\t\t\tif(areasTemplate  ) this.parseAreasTemplate(areasTemplate);\n\t\t},\n\n\t\tparseGridRowGap: function(cssText) {\n\t\t\tthis.rowGap = cssUnits.convertToPixels(cssText, this.element, { isHeightRelated: true });\n\t\t},\n\n\t\tparseGridColumnGap: function(cssText) {\n\t\t\tthis.colGap = cssUnits.convertToPixels(cssText, this.element, { isWidthRelated: true });\n\t\t},\n\n\t\tparseGridGap: function(cssText) {\n\t\t\tvar values = cssText.trim().split(/\\s+/);\n\t\t\tthis.parseGridRowGap(values[0]);\n\t\t\tthis.parseGridColumnGap(values[1] || cssText);\n\t\t},\n\t\t\n\t\tbuildExplicitMatrix: function() {\n\t\t\t\n\t\t\t// reset\n\t\t\tthis.resetLinesToSpecified();\n\t\t\tthis.rcMatrix = [];\n\t\t\t\n\t\t\t// simple autogrow\n\t\t\tif(this.growY) {\n\t\t\t\tthis.ensureRows(this.ySizes.length);\n\t\t\t\tthis.ensureColumns(this.xSizes.length);\n\t\t\t} else {\n\t\t\t\tthis.ensureColumns(this.xSizes.length);\n\t\t\t\tthis.ensureRows(this.ySizes.length);\n\t\t\t}\n\t\t\t\n\t\t}, \n\t\t\n\t\tbuildImplicitMatrix: function() { /* see http://dev.w3.org/csswg/css-grid/#auto-placement-algo */\n\t\t\n\t\t\t// start by building the explicit matrix\n\t\t\tthis.buildExplicitMatrix();\n\t\t\t\n\t\t\t// [1] position non-auto items\n\t\t\tthis.positionNonAutoItems();\n\t\t\t\n\t\t\t// [2] position auto-in-column-only items\n\t\t\tthis.positionAutoInColumnOnlyItems();\n\t\t\t\n\t\t\t// [3] make room for implicit tracks\n\t\t\tthis.autoGrow();\n\t\t\t\n\t\t},\n\t\t\n\t\tensureRows: function(yEnd) {\n\t\t\t\n\t\t\tif(this.growY) {\n\t\t\t\t\n\t\t\t\t// add rows as necessary\n\t\t\t\twhile(this.ySizes.length<yEnd) {\n\t\t\t\t\tthis.ySizes.push(this.defaultYSize);\n\t\t\t\t}\n\t\t\t\twhile(this.rcMatrix.length<yEnd) {\n\t\t\t\t\tthis.rcMatrix.push([]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// add rows as necessary\n\t\t\t\twhile(this.ySizes.length<yEnd) {\n\t\t\t\t\tthis.ySizes.push(this.defaultYSize);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// walk through columns\n\t\t\t\tfor(var x = this.rcMatrix.length; x--;) {\n\t\t\t\t\n\t\t\t\t\t// add rows as necessary\n\t\t\t\t\tif(this.rcMatrix[x].length < yEnd) {\n\t\t\t\t\t\tthis.rcMatrix[x].length = yEnd;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\tensureColumns: function(xEnd) {\n\t\t\t\n\t\t\tif(this.growY) {\n\t\t\t\n\t\t\t\t// add columns as necessary\n\t\t\t\twhile(this.xSizes.length<xEnd) {\n\t\t\t\t\tthis.xSizes.push(this.defaultXSize);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// walk through rows\n\t\t\t\tfor(var y = this.rcMatrix.length; y--;) {\n\t\t\t\t\n\t\t\t\t\t// add columns as necessary\n\t\t\t\t\tif(this.rcMatrix[y].length < xEnd) {\n\t\t\t\t\t\tthis.rcMatrix[y].length = xEnd;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// add columns as necessary\n\t\t\t\twhile(this.xSizes.length<xEnd) {\n\t\t\t\t\tthis.xSizes.push(this.defaultXSize);\n\t\t\t\t}\n\t\t\t\twhile(this.rcMatrix.length<xEnd) {\n\t\t\t\t\tthis.rcMatrix.push([]);\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t},\n\t\t\n\t\tmarkAsOccupied: function(item) {\n\t\t\t\n\t\t\tvar xStart = item.xStart;\n\t\t\tvar yStart = item.yStart;\n\t\t\tvar xEnd = item.xEnd;\n\t\t\tvar yEnd = item.yEnd;\n\t\t\n\t\t\t// let's check the rcMatrix mode we're in:\n\t\t\tif(this.growY) {\n\t\t\t\t\n\t\t\t\t// add rows as necessary\n\t\t\t\tthis.ensureRows(yEnd);\n\t\t\t\t\n\t\t\t\t// walk through rows\n\t\t\t\tfor(var y = yStart; y<yEnd; y++) {\n\t\t\t\t\n\t\t\t\t\t// add columns as necessary\n\t\t\t\t\tif(this.rcMatrix[y].length < xEnd-1) {\n\t\t\t\t\t\tthis.rcMatrix[y].length = xEnd-1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// walk through columns\n\t\t\t\t\tfor(var x = xStart; x<xEnd; x++) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// the cell is occupied\n\t\t\t\t\t\tthis.rcMatrix[y][x] = item;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// add columns as necessary\n\t\t\t\tthis.ensureColumns(xEnd);\n\t\t\t\t\n\t\t\t\t// walk through rows\n\t\t\t\tfor(var x = xStart; x<xEnd; x++) {\n\t\t\t\t\n\t\t\t\t\t// add rows as necessary\n\t\t\t\t\tif(this.rcMatrix[x].length < yEnd-1) {\n\t\t\t\t\t\tthis.rcMatrix[x].length = yEnd-1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// walk through rows\n\t\t\t\t\tfor(var y = yStart; y<yEnd; y++) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// the cell is occupied\n\t\t\t\t\t\tthis.rcMatrix[x][y] = item;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n\t\t},\n\t\t\n\t\tpositionNonAutoItems: function() {\n\t\t\t\n\t\t\tfor(var i=0, l=this.items.length; i<l; i++) {\n\t\t\t\tvar item = this.items[i];\n\t\t\t\t\n\t\t\t\t// if the element has a specific column associated to it\n\t\t\t\tif(item.specifiedXStart.type == LOCATE_LINE) {\n\t\t\t\t\t\n\t\t\t\t\t// if the element has a specified row associated to it\n\t\t\t\t\tif(item.specifiedYStart.type == LOCATE_LINE) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// find the start position (x axis)\n\t\t\t\t\t\tvar xStart = this.findXStart(item);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// find the start position (y axis)\n\t\t\t\t\t\tvar yStart = this.findYStart(item);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// find the end position (x axis)\n\t\t\t\t\t\tvar xEnd = this.findXEnd(item);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// find the end position (y axis)\n\t\t\t\t\t\tvar yEnd = this.findYEnd(item);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// we're done! this is so cool dude!\n\t\t\t\t\t\titem.xStart = xStart;\n\t\t\t\t\t\titem.yStart = yStart;\n\t\t\t\t\t\titem.xEnd = xEnd;\n\t\t\t\t\t\titem.yEnd = yEnd;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// we should fill the explicit matrix now!\n\t\t\t\t\t\tthis.markAsOccupied(item);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\tpositionAutoInColumnOnlyItems: function() {\n\t\t\t\n\t\t\tif(this.growY) {\n\t\t\t\t\n\t\t\t\tfor(var i=0, l=this.items.length; i<l; i++) {\n\t\t\t\t\tvar item = this.items[i];\n\t\t\t\t\t\n\t\t\t\t\t// if the element has a specified row associated to it, but is not positioned yet\n\t\t\t\t\tif(item.specifiedYStart.type == LOCATE_LINE && (item.yStart==-1)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// find the start position (y axis)\n\t\t\t\t\t\tvar yStart = this.findYStart(item);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// find the end position (y axis)\n\t\t\t\t\t\tvar yEnd = this.findYEnd(item);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// assumption: X is either AUTO + SPAN or AUTO + AUTO\n\t\t\t\t\t\tvar spanX = 1;\n\t\t\t\t\t\tif(item.specifiedXEnd.type == LOCATE_SPAN) {\n\t\t\t\t\t\t\tif(item.specifiedXEnd.name === undefined) {\n\t\t\t\t\t\t\t\t// The span is defined as this value\n\t\t\t\t\t\t\t\tspanX = item.specifiedXEnd.index;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\n\t\t\t\t\t\t\t\tspanX = 1; console.error('[CSS-GRID] UNSUPPORTED: grid-row/column: auto / span [0-9]+ [A-Z]+');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// add rows as necessary\n\t\t\t\t\t\tthis.ensureRows(yEnd);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// walk through columns to find a suitable position\n\t\t\t\t\t\tIncrementalColumnAttempts: for(var sx = 0;;sx++) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor(var x = sx+spanX-1; x>=sx; x--) {\n\t\t\t\t\t\t\t\tfor(var y = yStart; y<yEnd; y++) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// if the cell is occupied\n\t\t\t\t\t\t\t\t\tif(this.rcMatrix[y][x]) {\n\t\t\t\t\t\t\t\t\t\tcontinue IncrementalColumnAttempts;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar xStart = sx;\n\t\t\t\t\t\tvar xEnd = sx+spanX;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// we're done! this is so cool dude!\n\t\t\t\t\t\titem.xStart = xStart;\n\t\t\t\t\t\titem.yStart = yStart;\n\t\t\t\t\t\titem.xEnd = xEnd;\n\t\t\t\t\t\titem.yEnd = yEnd;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// we should fill the explicit matrix now!\n\t\t\t\t\t\tthis.markAsOccupied(item);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tfor(var i=0, l=this.items.length; i<l; i++) {\n\t\t\t\t\tvar item = this.items[i];\n\t\t\t\t\t\n\t\t\t\t\t// if the element has a specified column associated to it, but is not positioned yet\n\t\t\t\t\tif(item.specifiedXStart.type == LOCATE_LINE && (item.xStart==-1)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// find the start position (x axis)\n\t\t\t\t\t\tvar xStart = this.findXStart(item);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// find the end position (x axis)\n\t\t\t\t\t\tvar xEnd = this.findXEnd(item);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// assumption: Y is either AUTO + SPAN or AUTO + AUTO\n\t\t\t\t\t\tvar spanY = 1;\n\t\t\t\t\t\tif(item.specifiedYEnd.type == LOCATE_SPAN) {\n\t\t\t\t\t\t\tif(item.specifiedYEnd.name === undefined) {\n\t\t\t\t\t\t\t\t// The span is defined as this value\n\t\t\t\t\t\t\t\tspanY = item.specifiedYEnd.index;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\n\t\t\t\t\t\t\t\tspanY = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// add rows as necessary\n\t\t\t\t\t\tthis.ensureColumns(xEnd);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// walk through columns to find a suitable position\n\t\t\t\t\t\tIncrementalRowAttempts: for(var sy = 0;;sy++) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor(var y = sy+spanY-1; y>=sy; y--) {\n\t\t\t\t\t\t\t\tfor(var x = xStart; x<xEnd; x++) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// if the cell is occupied\n\t\t\t\t\t\t\t\t\tif(this.rcMatrix[x][y]) {\n\t\t\t\t\t\t\t\t\t\tcontinue IncrementalRowAttempts;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar yStart = sy;\n\t\t\t\t\t\tvar yEnd = sy+spanY;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// we're done! this is so cool dude!\n\t\t\t\t\t\titem.xStart = xStart;\n\t\t\t\t\t\titem.yStart = yStart;\n\t\t\t\t\t\titem.xEnd = xEnd;\n\t\t\t\t\t\titem.yEnd = yEnd;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// we should fill the explicit matrix now!\n\t\t\t\t\t\tthis.markAsOccupied(item);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\n\t\t},\n\t\t\n\t\tautoGrow: function() {\n\t\t\t\n\t\t\t// helpers\n\t\t\tvar growX = function(index) {\n\t\t\t\twhile(index >= this.xLines.length) {\n\t\t\t\t\tthis.xLines.push(['*']);\n\t\t\t\t\tthis.xSizes.push(this.defaultXSize);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar growY = function(index) {\n\t\t\t\twhile(index >= this.yLines.length) {\n\t\t\t\t\tthis.yLines.push(['*']);\n\t\t\t\t\tthis.ySizes.push(this.defaultYSize);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// reset the lines to the specified ones if necessary\n\t\t\tthis.resetLinesToSpecified(); // TODO: why?\n\t\t\t\n\t\t\t// ensure there's at least one cell\n\t\t\tgrowX.call(this,1); growY.call(this,1);\n\t\t\t\n\t\t\t// check if an item is explicitly positioned outside the explicit grid, and expand it if needed\n\t\t\tfor(var i = this.items.length; i--;) {\n\t\t\t\t\n\t\t\t\tvar item = this.items[i];\n\t\t\t\t\n\t\t\t\t// CONSIDER: items already positioned\n\t\t\t\tif(item.xEnd > 0) { growX.call(this,item.xEnd); }\n\t\t\t\tif(item.yEnd > 0) { growY.call(this,item.yEnd); }\n\t\t\t\tif(item.xEnd > 0 && item.yEnd > 0) { continue; }\n\t\t\t\t\n\t\t\t\t// CONSIDER: elements with a known location\n\t\t\t\t\n\t\t\t\t// (x axis):\n\t\t\t\tif(item.specifiedXEnd.type == LOCATE_LINE || item.specifiedXStart.type == LOCATE_LINE) {\n\t\t\t\t\t\n\t\t\t\t\tvar xStart = this.findXStart(item);\n\t\t\t\t\tvar xEnd = this.findXEnd(item);\n\t\t\t\t\tgrowX.call(this,xEnd);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// (y axis):\n\t\t\t\tif(item.specifiedYEnd.type == LOCATE_LINE || item.specifiedYStart.type == LOCATE_LINE) {\n\t\t\t\t\t\n\t\t\t\t\tvar yStart = this.findYStart(item);\n\t\t\t\t\tvar yEnd = this.findYEnd(item);\n\t\t\t\t\tif(yEnd <= yStart) { yEnd = yStart+1; }\n\t\t\t\t\tgrowY.call(this,yEnd);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// CONSIDER: known spans\n\t\t\t\t// // NOTE: I don't support \"grid-row/column-start: span X\";\n\t\t\t\tif(item.specifiedXEnd.type == LOCATE_SPAN && item.specifiedXEnd.name===undefined) {\n\t\t\t\t\tgrowX.call(this,item.specifiedXEnd.index);\n\t\t\t\t}\n\t\t\t\tif(item.specifiedYEnd.type == LOCATE_SPAN && item.specifiedYEnd.name===undefined) {\n\t\t\t\t\tgrowY.call(this,item.specifiedYEnd.index);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// grow the grid matrix:\n\t\t\tif(this.growY) {\n\t\t\t\twhile(this.ySizes.length>this.rcMatrix.length) {\n\t\t\t\t\tthis.rcMatrix.push([]);\n\t\t\t\t}\n\t\t\t\tfor(var r=this.rcMatrix.length; r--;) {\n\t\t\t\t\tthis.rcMatrix[r].length = this.xSizes.length;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile(this.xSizes.length>this.rcMatrix.length) {\n\t\t\t\t\tthis.rcMatrix.push([]);\n\t\t\t\t}\n\t\t\t\tfor(var r=this.rcMatrix.length; r--;) {\n\t\t\t\t\tthis.rcMatrix[r].length = this.ySizes.length;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\tscheduleRelayout: function() {\n\t\t\tvar This = this;\n\t\t\tif(!This.isLayoutScheduled) {\n\t\t\t\tThis.isLayoutScheduled = true;\n\t\t\t\trequestAnimationFrame(function() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar savedScrolls = getScrollStates();\n\t\t\t\t\t\tThis.revokePolyfilledStyle();\n\t\t\t\t\t\tThis.updateFromElement();\n\t\t\t\t\t\tThis.performLayout();\n\t\t\t\t\t\tThis.generatePolyfilledStyle();\n\t\t\t\t\t\tsavedScrolls.forEach(function(d) {\n\t\t\t\t\t\t\td.element.scrollTop = d.top;\n\t\t\t\t\t\t\td.element.scrollLeft = d.left;\n\t\t\t\t\t\t});\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tThis.isLayoutScheduled = false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t//-----------------------------------------------------------\n\t\t\tfunction getScrollStates() {\n\t\t\t\tvar states = [];\n\t\t\t\tvar element = This.element;\n\t\t\t\twhile(element = element.parentNode) {\n\t\t\t\t\tif(\"scrollTop\" in element) {\n\t\t\t\t\t\tstates.push({ element: element, left: element.scrollLeft, top: element.scrollTop });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn states;\n\t\t\t}\n\t\t},\n\t\t\n\t\tperformLayout: function() {\n\t\t\n\t\t\t// process non-automatic items\n\t\t\tthis.buildImplicitMatrix();\n\n\t\t\t// position the remaining grid items. \n\t\t\tvar cursor = { x: 0, y: 0 };\n\n\t\t\tif(this.growY) {\n\t\t\t\t\n\t\t\t\t//For each grid item that hasnt been positioned by the previous steps, in order-modified document order:\n\t\t\t\tfor(var i=0; i<this.items.length; i++) {\n\t\t\t\t\tvar item = this.items[i]; if(item.xEnd!=-1 && item.yEnd!=-1) { continue; }\n\t\t\t\t\t\n\t\t\t\t\t// reset the cursor if the algorithm is set to 'dense'\n\t\t\t\t\tif(this.growDense) { cursor = { x: 0, y: 0 }; }\n\t\t\t\t\t\n\t\t\t\t\t//If the item has a definite column position: \n\t\t\t\t\tif(item.specifiedXStart.type == LOCATE_LINE) {\n\t\t\t\t\t\n\t\t\t\t\t\t// 1. Set the column position of the cursor to be equal to the inline-start index of the grid item. \n\t\t\t\t\t\tvar xStart = this.findXStart(item); if(cursor.x > xStart) { cursor.y++; } cursor.x = xStart;\n\t\t\t\t\t\tvar xEnd = this.findXEnd(item); if(xStart>=xEnd) { xEnd=xStart+1}\n\t\t\t\t\t\titem.xStart=xStart; item.xEnd=xEnd;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// assumption: Y is either AUTO + SPAN or AUTO + AUTO\n\t\t\t\t\t\tvar spanY = 1;\n\t\t\t\t\t\tif(item.specifiedYEnd.type == LOCATE_SPAN) {\n\t\t\t\t\t\t\tif(item.specifiedYEnd.name === undefined) {\n\t\t\t\t\t\t\t\t// The span is defined as this value\n\t\t\t\t\t\t\t\tspanY = item.specifiedYEnd.index;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\n\t\t\t\t\t\t\t\tspanY = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// 2. Increment the auto-placement cursors row position until a value is found where the grid item does not overlap any occupied grid cells (creating new rows in the implicit grid as necessary).\n\t\t\t\t\t\tIncrementalRowAttempts: while(true) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// make room for the currently attempted position\n\t\t\t\t\t\t\tthis.ensureRows(cursor.y+spanY);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// check the non-overlap condition\n\t\t\t\t\t\t\tfor(var y = cursor.y+spanY-1; y>=cursor.y; y--) {\n\t\t\t\t\t\t\t\tfor(var x = xStart; x<xEnd; x++) {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// if the cell is occupied\n\t\t\t\t\t\t\t\t\tif(this.rcMatrix[y][x]) {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t// move to the next row\n\t\t\t\t\t\t\t\t\t\tcursor.y=y+1; continue IncrementalRowAttempts;\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// settle the position\n\t\t\t\t\t\titem.xStart = xStart;\n\t\t\t\t\t\titem.xEnd = xEnd;\n\t\t\t\t\t\titem.yStart = cursor.y;\n\t\t\t\t\t\titem.yEnd = cursor.y+spanY;\n\t\t\t\t\t\t\n\t\t\t\t\t\tthis.markAsOccupied(item);\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t} else { // If the item has an automatic grid position in both axes: \n\t\t\t\t\t\t\n\t\t\t\t\t\t// assumption: X is either AUTO + SPAN or AUTO + AUTO\n\t\t\t\t\t\tvar spanX = 1;\n\t\t\t\t\t\tif(item.specifiedXEnd.type == LOCATE_SPAN) {\n\t\t\t\t\t\t\tif(item.specifiedXEnd.name === undefined) {\n\t\t\t\t\t\t\t\t// The span is defined as this value\n\t\t\t\t\t\t\t\tspanX = item.specifiedXEnd.index;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\n\t\t\t\t\t\t\t\tspanX = 1; console.error('[CSS-GRID] UNSUPPORTED: grid-row/column: auto / span [0-9]+ [A-Z]+');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// assumption: Y is either AUTO + SPAN or AUTO + AUTO\n\t\t\t\t\t\tvar spanY = 1;\n\t\t\t\t\t\tif(item.specifiedYEnd.type == LOCATE_SPAN) {\n\t\t\t\t\t\t\tif(item.specifiedYEnd.name === undefined) {\n\t\t\t\t\t\t\t\t// The span is defined as this value\n\t\t\t\t\t\t\t\tspanY = item.specifiedYEnd.index;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\n\t\t\t\t\t\t\t\tspanY = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Increment the auto-placement cursors row/column position (creating new rows in the implicit grid as necessary)\n\t\t\t\t\t\tvar nextStep = function() {\n\t\t\t\t\t\t\tcursor.x++; if(cursor.x+spanX>this.rcMatrix[0].length) { cursor.y++; this.ensureRows(cursor.y + spanY); cursor.x=0; }\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// 1. Increment the column position of the auto-placement cursor until this items grid area does not overlap any occupied grid cells\n\t\t\t\t\t\tIncrementalYXPositionAttempts: while(true) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// make room for the currently attempted position\n\t\t\t\t\t\t\tthis.ensureRows(cursor.y+spanY);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// check the non-overlap condition\n\t\t\t\t\t\t\tfor(var y = cursor.y+spanY-1; y>=cursor.y; y--) {\n\t\t\t\t\t\t\t\tfor(var x = cursor.x+spanX-1; x>=cursor.x; x--) {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// if the cell is occupied\n\t\t\t\t\t\t\t\t\tif(this.rcMatrix[y][x]) {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t// move to the next row/column\n\t\t\t\t\t\t\t\t\t\tnextStep.call(this); continue IncrementalYXPositionAttempts;\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// settle the position\n\t\t\t\t\t\titem.xStart = cursor.x;\n\t\t\t\t\t\titem.xEnd = cursor.x+spanX;\n\t\t\t\t\t\titem.yStart = cursor.y;\n\t\t\t\t\t\titem.yEnd = cursor.y+spanY;\n\t\t\t\t\t\t\n\t\t\t\t\t\tthis.markAsOccupied(item);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t//For each grid item that hasnt been positioned by the previous steps, in order-modified document order:\n\t\t\t\tfor(var i=0; i<this.items.length; i++) {\n\t\t\t\t\tvar item = this.items[i]; if(item.xEnd!=-1 && item.yEnd!=-1) { continue; }\n\t\t\t\t\t\n\t\t\t\t\t// reset the cursor if the algorithm is set to 'dense'\n\t\t\t\t\tif(this.growDense) { cursor = { x: 0, y: 0 }; }\n\t\t\t\t\t\n\t\t\t\t\t//If the item has a definite row position: \n\t\t\t\t\tif(item.specifiedYStart.type == LOCATE_LINE) {\n\t\t\t\t\t\n\t\t\t\t\t\t// 1. Set the column position of the cursor to be equal to the inline-start index of the grid item. \n\t\t\t\t\t\tvar yStart = this.findYStart(item); if(cursor.y > yStart) { cursor.x++; } cursor.y = yStart;\n\t\t\t\t\t\tvar yEnd = this.findYEnd(item); if(yStart>=yEnd) { yEnd=yStart+1}\n\t\t\t\t\t\titem.yStart=yStart; item.yEnd=yEnd;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// assumption: X is either AUTO + SPAN or AUTO + AUTO\n\t\t\t\t\t\tvar spanX = 1;\n\t\t\t\t\t\tif(item.specifiedXEnd.type == LOCATE_SPAN) {\n\t\t\t\t\t\t\tif(item.specifiedXEnd.name === undefined) {\n\t\t\t\t\t\t\t\t// The span is defined as this value\n\t\t\t\t\t\t\t\tspanX = item.specifiedXEnd.index;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\n\t\t\t\t\t\t\t\tspanX = 1; console.error('[CSS-GRID] UNSUPPORTED: grid-row/column: auto / span [0-9]+ [A-Z]+');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// 2. Increment the auto-placement cursors row position until a value is found where the grid item does not overlap any occupied grid cells (creating new rows in the implicit grid as necessary).\n\t\t\t\t\t\tIncrementalColumnAttempts: while(true) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// make room for the currently attempted position\n\t\t\t\t\t\t\tthis.ensureColumns(cursor.x+spanX);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// check the non-overlap condition\n\t\t\t\t\t\t\tfor(var x = cursor.x+spanX-1; x>=cursor.x; x--) {\n\t\t\t\t\t\t\t\tfor(var y = yStart; y<yEnd; y++) {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// if the cell is occupied\n\t\t\t\t\t\t\t\t\tif(this.rcMatrix[x][y]) {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t// move to the next row\n\t\t\t\t\t\t\t\t\t\tcursor.x=x+1; continue IncrementalColumnAttempts;\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// settle the position\n\t\t\t\t\t\titem.yStart = yStart;\n\t\t\t\t\t\titem.yEnd = yEnd;\n\t\t\t\t\t\titem.xStart = cursor.x;\n\t\t\t\t\t\titem.yEnd = cursor.x+spanX;\n\t\t\t\t\t\t\n\t\t\t\t\t\tthis.markAsOccupied(item);\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t} else { // If the item has an automatic grid position in both axes: \n\t\t\t\t\t\t\n\t\t\t\t\t\t// assumption: Y is either AUTO + SPAN or AUTO + AUTO\n\t\t\t\t\t\tvar spanY = 1;\n\t\t\t\t\t\tif(item.specifiedYEnd.type == LOCATE_SPAN) {\n\t\t\t\t\t\t\tif(item.specifiedYEnd.name === undefined) {\n\t\t\t\t\t\t\t\t// The span is defined as this value\n\t\t\t\t\t\t\t\tspanY = item.specifiedYEnd.index;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\n\t\t\t\t\t\t\t\tspanY = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// assumption: X is either AUTO + SPAN or AUTO + AUTO\n\t\t\t\t\t\tvar spanX = 1;\n\t\t\t\t\t\tif(item.specifiedXEnd.type == LOCATE_SPAN) {\n\t\t\t\t\t\t\tif(item.specifiedXEnd.name === undefined) {\n\t\t\t\t\t\t\t\t// The span is defined as this value\n\t\t\t\t\t\t\t\tspanX = item.specifiedXEnd.index;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\n\t\t\t\t\t\t\t\tspanX = 1; console.error('[CSS-GRID] UNSUPPORTED: grid-row/column: auto / span [0-9]+ [A-Z]+');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Increment the auto-placement cursors row/column position (creating new rows in the implicit grid as necessary)\n\t\t\t\t\t\tvar nextStep = function() {\n\t\t\t\t\t\t\tcursor.y++; if(cursor.y+spanY>this.rcMatrix[0].length) { cursor.x++; this.ensureRows(cursor.x + spanX); cursor.y=0; }\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// 1. Increment the column position of the auto-placement cursor until this items grid area does not overlap any occupied grid cells\n\t\t\t\t\t\tIncrementalXYPositionAttempts: while(true) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// make room for the currently attempted position\n\t\t\t\t\t\t\tthis.ensureColumns(cursor.x+spanX);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// check the non-overlap condition\n\t\t\t\t\t\t\tfor(var x = cursor.x+spanX-1; x>=cursor.x; x--) {\n\t\t\t\t\t\t\t\tfor(var y = cursor.y+spanY-1; y>=cursor.y; y--) {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// if the cell is occupied\n\t\t\t\t\t\t\t\t\tif(this.rcMatrix[x][y]) {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t// move to the next row/column\n\t\t\t\t\t\t\t\t\t\tnextStep.call(this); continue IncrementalXYPositionAttempts;\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// settle the position\n\t\t\t\t\t\titem.xStart = cursor.x;\n\t\t\t\t\t\titem.xEnd = cursor.x+spanX;\n\t\t\t\t\t\titem.yStart = cursor.y;\n\t\t\t\t\t\titem.yEnd = cursor.y+spanY;\n\t\t\t\t\t\t\n\t\t\t\t\t\tthis.markAsOccupied(item);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tthis.computeAbsoluteTrackBreadths();\n\n\t\t\t\n\t\t\t\n\t\t},\n\t\t\n\t\tcomputeAbsoluteTrackBreadths: function() {\n\t\t\n\t\t\t///////////////////////////////////////////////////////////\n\t\t\t// hide child elements, to get free width/height\n\t\t\t///////////////////////////////////////////////////////////\n\t\t\tvar runtimeStyle = createRuntimeStyle('no-children', this.element);\n\t\t\truntimeStyle.set(this.element, {\n\t\t\t\t\"border\"       : \"none\",\n\t\t\t\t\"padding\"      : \"0px\",\n\t\t\t\t\"min-height\"   : \"0px\",\n\t\t\t});\n\t\t\tfor(var i = this.items.length; i--;) {\n\t\t\t\truntimeStyle.set(this.items[i],{\"display\":\"none\"});\n\t\t\t}\n\t\t\t\n\t\t\t///////////////////////////////////////////////////////////\n\t\t\t// hide child elements, to get free width/height\n\t\t\t///////////////////////////////////////////////////////////\n\t\t\tvar LIMIT_IS_INFINITE = 1;\t\t\n\t\t\tvar infinity = 9999999.0;\n\t\t\tvar rowCount = this.growY ? this.rcMatrix.length : this.rcMatrix[0].length;\n\t\t\tvar colCount = this.growY ? this.rcMatrix[0].length : this.rcMatrix.length;\n\t\t\tvar fullWidth = this.element.offsetWidth - this.hlPadding - this.hrPadding;\n\t\t\tvar fullHeight = this.element.offsetHeight - this.vtPadding - this.vbPadding;\n\t\t\tvar fullDistributableWidth = Math.max(0, fullWidth - Math.max(0, colCount - 1) * this.colGap);\n\t\t\tvar fullDistributableHeight = Math.max(0, fullHeight - Math.max(0, rowCount - 1) * this.rowGap);\n\t\t\t\n\t\t\t///////////////////////////////////////////////////////////\n\t\t\t// show child elements again\n\t\t\t///////////////////////////////////////////////////////////\n\t\t\truntimeStyle.revoke();\n\t\t\t\n\t\t\t// \n\t\t\t// 10.3  Initialize Track Sizes\n\t\t\t// \n\t\t\tvar initializeFromConstraints = function(v) {\n\t\t\t\t\n\t\t\t\tvar base = 0, limit = infinity;\n\t\t\t\tswitch(v.minType) {\n\t\t\t\t\t\n\t\t\t\t\t// For fixed track sizes, resolve to an absolute length and use that size. \n\t\t\t\t\tcase TRACK_BREADTH_LENGTH:      base = v.minValue; break;\n\t\t\t\t\tcase TRACK_BREADTH_PERCENTAGE:  base = v.minValue*fullSize/100; break;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tswitch(v.maxType) {\n\t\t\t\t\t\n\t\t\t\t\t// For fixed track sizes, resolve to an absolute length and use that size. \n\t\t\t\t\tcase TRACK_BREADTH_LENGTH:      limit = v.minValue; break;\n\t\t\t\t\tcase TRACK_BREADTH_PERCENTAGE:  limit = v.minValue*fullSize/100; break;\n\t\t\t\t\t\n\t\t\t\t\t// For flexible track sizes, use the tracks initial base size as its initial growth limit.  \n\t\t\t\t\tcase TRACK_BREADTH_FRACTION:    limit = base; break;\n\t\t\t\t\t\n\t\t\t\t\t// For intrinsic track sizes, use an initial growth limit of infinity. \n\t\t\t\t\tdefault:                        limit = infinity; break;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn { base:base, limit:limit, breadth:0, flags:((limit==infinity)?LIMIT_IS_INFINITE:0)|0 };\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t//\n\t\t\t// Equal distribution algorithm\n\t\t\t//\n\t\t\tvar distributeEquallyAmongTracks = function distributeEquallyAmongTracks(xSizes, kind, tracks, spaceToDistribute, enforceLimit) {\n\t\t\t\t// Distribute space to base sizes\n\t\t\t\tvar trackAmount = tracks.length;\n\t\t\t\tvar spacePerTrack = spaceToDistribute/trackAmount;\n\t\t\t\tif(kind=='base') {\n\t\t\t\t\n\t\t\t\t\t// if we enforce the limit, grow up to the most limitating track\n\t\t\t\t\tif(enforceLimit) {\n\t\t\t\t\t\tfor(var t = tracks.length; t--;) { var cx = tracks[t].x;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// find the lowest acceptable increase for all tracks\n\t\t\t\t\t\t\tvar newBase = xSizes[cx].base + spacePerTrack;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// if limits are enfo\n\t\t\t\t\t\t\tif(enforceLimit && (xSizes[cx].flags & LIMIT_IS_INFINITE == 0) && newBase > xSizes[cx].limit) {\n\t\t\t\t\t\t\t\tspacePerTrack -= newBase - xSizes[cx].limit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(var t = tracks.length; t--;) { var cx = tracks[t].x;\n\t\t\t\t\t\txSizes[cx].base += spacePerTrack;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else if(kind == 'limit') {\n\t\t\t\t\n\t\t\t\t\t// Update the tracks' affected sizes by folding in the calculated increase so that the next round of space distribution will account for the increase.\n\t\t\t\t\tfor(var t = tracks.length; t--;) { var cx = tracks[t].x;\n\t\t\t\t\t\t// If the growth limit is infinite...\n\t\t\t\t\t\tif(xSizes[cx].flags & LIMIT_IS_INFINITE) {\n\t\t\t\t\t\t\t// set it to the tracks base size plus the calculated increase\n\t\t\t\t\t\t\tif(xSizes[cx].limit == infinity) {\n\t\t\t\t\t\t\t\txSizes[cx].limit = xSizes[cx].base + spacePerTrack;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\txSizes[cx].limit += spacePerTrack; // TODO: THERE IS A BUG HERE ?\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// otherwise just increase the limit\n\t\t\t\t\t\t\txSizes[cx].limit += spacePerTrack;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t\t// \n\t\t\t// 10.4  Resolve Content-Based Track Sizing Functions\n\t\t\t// \n\t\t\tvar computeTrackBreadth = function(xSizes, specifiedSizes, getMinWidthOf, getMaxWidthOf, getXStartOf, getXEndOf) {\n\t\t\t\t\n\t\t\t\t// For each track\n\t\t\t\tvar items_done = 0; // items already consumed for this algorithm\n\t\t\t\tfor(var x = specifiedSizes.length; x--;) {\n\t\t\t\t\n\t\t\t\t\tvar dontCountMaxItems = false;\n\t\t\t\t\t\n\t\t\t\t\t// If the track has a min-content min track sizing function\n\t\t\t\t\tif(specifiedSizes[x].minType == TRACK_BREADTH_MIN_CONTENT || specifiedSizes[x].minType == TRACK_BREADTH_AUTO) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Consider the items in it with a span of 1: \n\t\t\t\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i]; var item_xStart = getXStartOf(item); var item_xEnd = getXEndOf(item);\n\t\t\t\t\t\t\tif(item_xStart>x || item_xEnd<=x || item_xEnd-item_xStart != 1) continue;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Set its base size to the maximum of the items min-content contributions. \n\t\t\t\t\t\t\txSizes[x].base = Math.max(xSizes[x].base, getMinWidthOf(item)); items_done++; dontCountMaxItems=true;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// If the track has a max-content min track sizing function\n\t\t\t\t\telse if(specifiedSizes[x].minType == TRACK_BREADTH_MAX_CONTENT) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Consider the items in it with a span of 1: \n\t\t\t\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i]; var item_xStart = getXStartOf(item); var item_xEnd = getXEndOf(item);\n\t\t\t\t\t\t\tif(item_xStart>x || item_xEnd<=x || item_xEnd-item_xStart != 1) continue;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Set its base size to the maximum of the items max-content contributions. \n\t\t\t\t\t\t\txSizes[x].base = Math.max(xSizes[x].base, getMaxWidthOf(item)); items_done++; dontCountMaxItems=true;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// If the track has a min-content max track sizing function\n\t\t\t\t\tif(specifiedSizes[x].maxType == TRACK_BREADTH_MIN_CONTENT) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Consider the items in it with a span of 1: \n\t\t\t\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i]; var item_xStart = getXStartOf(item); var item_xEnd = getXEndOf(item);\n\t\t\t\t\t\t\tif(item_xStart>x || item_xEnd<=x || item_xEnd-item_xStart != 1) continue;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Set its growth limit to the maximum of the items min-content contributions. \n\t\t\t\t\t\t\tif(xSizes[x].limit == infinity) { xSizes[x].limit = getMinWidthOf(item); }\n\t\t\t\t\t\t\telse { xSizes[x].limit = Math.max(xSizes[x].limit, getMinWidthOf(item)); }\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(!dontCountMaxItems) { items_done++; }\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} \n\t\t\t\t\t\n\t\t\t\t\t// If the track has a max-content max track sizing function\n\t\t\t\t\telse if(specifiedSizes[x].maxType == TRACK_BREADTH_MAX_CONTENT || specifiedSizes[x].minType == TRACK_BREADTH_AUTO) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Consider the items in it with a span of 1: \n\t\t\t\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i]; var item_xStart = getXStartOf(item); var item_xEnd = getXEndOf(item);\n\t\t\t\t\t\t\tif(item_xStart>x || item_xEnd<=x || item_xEnd-item_xStart != 1) continue;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Set its growth limit to the maximum of the items max-content contributions. \n\t\t\t\t\t\t\tif(xSizes[x].limit == infinity) { xSizes[x].limit = getMaxWidthOf(item); }\n\t\t\t\t\t\t\telse { xSizes[x].limit = Math.max(xSizes[x].limit, getMaxWidthOf(item)); }\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(!dontCountMaxItems) { items_done++; }\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// update infinity flag\n\t\t\t\t\tif(xSizes[x].limit != infinity) {\n\t\t\t\t\t\txSizes[x].flags = xSizes[x].flags & ~LIMIT_IS_INFINITE;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Next, consider the items with a span of 2 that do not span a track with a flexible sizing function: \n\t\t\t\t// Repeat incrementally for items with greater spans until all items have been considered.\n\t\t\t\tfor(var span = 2; items_done < this.items.length && span <= specifiedSizes.length; span++) {\n\t\t\t\t\tItemLoop: for(var i = this.items.length; i--;) { var item = this.items[i]; var item_xStart = getXStartOf(item); var item_xEnd = getXEndOf(item);\n\t\t\t\t\t\tif(item_xEnd-item_xStart != span) continue ItemLoop;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// gather some pieces of data about the tracks\n\t\t\t\t\t\tvar full_base = 0; var full_limit = 0;\n\t\t\t\t\t\tfor(var cx = item_xStart; cx<item_xEnd; cx++) { \n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// 1. we want to make sure none is flexible\n\t\t\t\t\t\t\tif(specifiedSizes[cx].maxType == TRACK_BREADTH_FRACTION) continue ItemLoop;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// 2. compute aggregated sizes\n\t\t\t\t\t\t\tfull_base += xSizes[cx].base;\n\t\t\t\t\t\t\tfull_limit += xSizes[cx].limit;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(full_limit > infinity) full_limit=infinity;\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar distributeFreeSpace = function(requiredSpace, kind /*'base'|'limit'*/, target /*'min-content'|'max-content'*/) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// compute the required extra space\n\t\t\t\t\t\t\t\tvar spaceToDistribute = requiredSpace;\n\t\t\t\t\t\t\t\tfor(var cx = item_xStart; cx<item_xEnd; cx++) {\n\t\t\t\t\t\t\t\t\tspaceToDistribute -= xSizes[cx][kind];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// if no space to distribute, just lock auto columns:\n\t\t\t\t\t\t\t\tif(spaceToDistribute <= 1/1024) { //due to double precision, this may never reach perfect 0\n\t\t\t\t\t\t\t\t\tfor(var cx = item_xStart; cx<item_xEnd; cx++) {\n\t\t\t\t\t\t\t\t\t\tif(xSizes[cx].limit == infinity) {\n\t\t\t\t\t\t\t\t\t\t\txSizes[cx].limit = xSizes[cx].base;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// sort rows by growth limit\n\t\t\t\t\t\t\t\tvar rows_and_limits = [];\n\t\t\t\t\t\t\t\tfor(var cx = item_xStart; cx<item_xEnd; cx++) {\n\t\t\t\t\t\t\t\t\trows_and_limits.push({ \n\t\t\t\t\t\t\t\t\t\tx:cx, \n\t\t\t\t\t\t\t\t\t\tbase:xSizes[cx].base,\n\t\t\t\t\t\t\t\t\t\tlimit:xSizes[cx].limit,\n\t\t\t\t\t\t\t\t\t\tminIsMinContent: specifiedSizes[cx].minType == TRACK_BREADTH_MIN_CONTENT || specifiedSizes[cx].minType == TRACK_BREADTH_AUTO,\n\t\t\t\t\t\t\t\t\t\tminIsMaxContent: specifiedSizes[cx].minType == TRACK_BREADTH_MAX_CONTENT,\n\t\t\t\t\t\t\t\t\t\tmaxIsMinContent: specifiedSizes[cx].maxType == TRACK_BREADTH_MIN_CONTENT,\n\t\t\t\t\t\t\t\t\t\tmaxIsMaxContent: specifiedSizes[cx].maxType == TRACK_BREADTH_MAX_CONTENT || specifiedSizes[cx].maxType == TRACK_BREADTH_AUTO\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trows_and_limits.sort(function(a,b) { return a.limit-b.limit; });\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// remove non-affected tracks\n\t\t\t\t\t\t\t\trows_and_limits = rows_and_limits.filter(function(b) {\n\t\t\t\t\t\t\t\t\tif(kind=='base') {\n\t\t\t\t\t\t\t\t\t\tif(target=='min-content') {\n\t\t\t\t\t\t\t\t\t\t\treturn b.minIsMinContent||b.minIsMaxContent;\n\t\t\t\t\t\t\t\t\t\t} else if(target=='max-content') {\n\t\t\t\t\t\t\t\t\t\t\treturn b.minIsMaxContent;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (kind == 'limit') {\n\t\t\t\t\t\t\t\t\t\tif(target=='min-content') {\n\t\t\t\t\t\t\t\t\t\t\treturn b.maxIsMinContent||b.maxIsMaxContent;\n\t\t\t\t\t\t\t\t\t\t} else if(target=='max-content') {\n\t\t\t\t\t\t\t\t\t\t\treturn b.maxIsMaxContent;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// check that there is at least one affected track\n\t\t\t\t\t\t\t\tif(rows_and_limits.length == 0) { return; }\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// apply the algorithm\n\t\t\t\t\t\t\t\tif(kind=='base') {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// Distribute space up to growth limits\n\t\t\t\t\t\t\t\t\tvar tracks = rows_and_limits.filter(function(b) { return b.base<b.limit; }, 0);\n\t\t\t\t\t\t\t\t\tvar trackAmount = tracks.length;\n\t\t\t\t\t\t\t\t\tif(trackAmount > 0) {\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, kind, tracks, spaceToDistribute, /*enforceLimit:*/true);\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t// Distribute space beyond growth limits\n\t\t\t\t\t\t\t\t\t\t// If space remains after all tracks are frozen, unfreeze and continue to distribute space to\n \n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t// - when handling min-content base sizes: \n\t\t\t\t\t\t\t\t\t\tif(target=='min-content') {\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t// any affected track that happens to also have an intrinsic max track sizing function; \n\t\t\t\t\t\t\t\t\t\t\tvar tracks = rows_and_limits.filter(function(b) { return b.maxIsMinContent||b.maxIsMaxContent; }, 0);\n\t\t\t\t\t\t\t\t\t\t\tvar trackAmount = tracks.length;\n\t\t\t\t\t\t\t\t\t\t\tif(trackAmount>=1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t// (such tracks exist:)\n\t\t\t\t\t\t\t\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, kind, tracks, spaceToDistribute, /*enforceLimit:*/false);\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t// if there are no such tracks, then all affected tracks. \n\t\t\t\t\t\t\t\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, kind, rows_and_limits, spaceToDistribute, /*enforceLimit:*/false);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t// - when handling max-content base sizes: \n\t\t\t\t\t\t\t\t\t\telse if(target=='max-content') {\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t// any affected track that happens to also have a max-content max track sizing function;\n\t\t\t\t\t\t\t\t\t\t\tvar tracks = rows_and_limits.filter(function(b) { return b.maxIsMaxContent; }, 0);\n\t\t\t\t\t\t\t\t\t\t\tvar trackAmount = tracks.length;\n\t\t\t\t\t\t\t\t\t\t\tif(trackAmount>=1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t// (such tracks exist:)\n\t\t\t\t\t\t\t\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, kind, tracks, spaceToDistribute, /*enforceLimit:*/false);\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t// if there are no such tracks, then all affected tracks. \n\t\t\t\t\t\t\t\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, kind, rows_and_limits, spaceToDistribute, /*enforceLimit:*/false);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\telse if (kind == 'limit') {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// distribute among all tracks\n\t\t\t\t\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, kind, rows_and_limits, spaceToDistribute);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar updateInfiniteLimitFlag = function() {\n\t\t\t\t\t\t\tfor(var x = xSizes.length; x--;) {\n\t\t\t\t\t\t\t\tif(xSizes[x].limit != infinity) {\n\t\t\t\t\t\t\t\t\txSizes[x].flags = xSizes[x].flags & ~LIMIT_IS_INFINITE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// 1. For intrinsic minimums: First increase the base size of tracks with a min track sizing function of min-content or max-content by distributing extra space as needed to account for these items' min-content contributions. \n\t\t\t\t\t\t//\n\t\t\t\t\t\tdistributeFreeSpace(getMinWidthOf(item), 'base', 'min-content');\n\t\t\t\t\t\tupdateInfiniteLimitFlag();\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// 2. For max-content minimums: Next continue to increase the base size of tracks with a min track sizing function of max-content by distributing extra space as needed to account for these items' max-content contributions. \n\t\t\t\t\t\t//\n\t\t\t\t\t\tdistributeFreeSpace(getMaxWidthOf(item), 'base', 'max-content');\n\t\t\t\t\t\tupdateInfiniteLimitFlag();\n\t\t\t\t\t\t\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// 3. For intrinsic maximums: Third increase the growth limit of tracks with a max track sizing function of min-content or max-content by distributing extra space as needed to account for these items' min-content contributions. \n\t\t\t\t\t\t// Mark any tracks whose growth limit changed from infinite to finite in this step as infinitely growable for the next step. \n\t\t\t\t\t\t// (aka do not update infinity flag)\n\t\t\t\t\t\t//\n\t\t\t\t\t\tdistributeFreeSpace(getMinWidthOf(item), 'limit', 'min-content');\n\t\t\t\t\t\t\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// 4. For max-content maximums: Lastly continue to increase the growth limit of tracks with a max track sizing function of max-content by distributing extra space as needed to account for these items' max-content contributions. \n\t\t\t\t\t\t//\n\t\t\t\t\t\tdistributeFreeSpace(getMaxWidthOf(item), 'limit', 'max-content');\n\t\t\t\t\t\tupdateInfiniteLimitFlag();\n\t\t\t\t\t\t\n\t\t\t\t\t\titems_done++;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\n\t\t\tvar computeTrackBreadthIncrease = function(xSizes, specifiedSizes, fullSize, fullDistributableSize, getMinWidthOf, getMaxWidthOf, getXStartOf, getXEndOf) {\n\t\t\t\t\n\t\t\t\t// sort rows by growth limit\n\t\t\t\tvar rows_and_limits = xSizes.map(function(item, cx) { \n\t\t\t\t\treturn { \n\t\t\t\t\t\tx:cx, \n\t\t\t\t\t\tbase:xSizes[cx].base,\n\t\t\t\t\t\tlimit:xSizes[cx].limit,\n\t\t\t\t\t\tminIsMinContent: specifiedSizes[cx].minType == TRACK_BREADTH_MIN_CONTENT || specifiedSizes[cx].minType == TRACK_BREADTH_AUTO,\n\t\t\t\t\t\tminIsMaxContent: specifiedSizes[cx].minType == TRACK_BREADTH_MAX_CONTENT,\n\t\t\t\t\t\tmaxIsMinContent: specifiedSizes[cx].maxType == TRACK_BREADTH_MIN_CONTENT,\n\t\t\t\t\t\tmaxIsMaxContent: specifiedSizes[cx].maxType == TRACK_BREADTH_MAX_CONTENT || specifiedSizes[cx].maxType == TRACK_BREADTH_AUTO\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t\trows_and_limits.sort(function(a,b) { return a.limit-b.limit; });\n\t\t\t\t\n\t\t\t\twhile(true) {\n\t\t\t\t\t\n\t\t\t\t\t// compute size to distribute\n\t\t\t\t\tvar spaceToDistribute = fullDistributableSize;\n\t\t\t\t\tfor(var cx = xSizes.length; cx--;) {\n\t\t\t\t\t\tspaceToDistribute -= xSizes[cx].base;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// check that there is some space to distribute\n\t\t\t\t\tif(spaceToDistribute <= 1/1024) { return; } // NOTE: the space may never become 0 due to a rounding issue\n\t\t\t\t\t\n\t\t\t\t\t// Distribute space up to growth limits\n\t\t\t\t\tvar tracks = rows_and_limits = rows_and_limits.filter(function(b) { return ((b.minIsMinContent||b.minIsMaxContent) && b.base<b.limit); }, 0);\n\t\t\t\t\tvar trackAmount = tracks.length; if(trackAmount <= 0) { return; }\n\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, 'base', tracks, spaceToDistribute, /*enforceLimit:*/true);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar computeFlexibleTrackBreadth = function(xSizes, specifiedSizes, fullSize, fullDistributableSize, getMinWidthOf, getMaxWidthOf, getXStartOf, getXEndOf) {\n\t\t\t\t\n\t\t\t\t// If the free space is an indefinite length: \n\t\t\t\tif(fullSize==0) {\n\t\t\t\t\t\n\t\t\t\t\t//The used flex fraction is the maximum of: \n\t\t\t\t\tvar currentFraction = 0;\n\t\t\t\t\t\n\t\t\t\t\t//  Each flexible tracks base size divided by its flex factor. \n\t\t\t\t\t'TODO: I believe this is completely useless, but CSSWG will not change it.';\n\t\t\t\t\t\n\t\t\t\t\t//  The result of finding the size of an fr for each grid item that crosses a flexible track, using all the grid tracks that the item crosses and a space to fill of the items max-content contribution. \n\t\t\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i]; var item_xStart = getXStartOf(item); var item_xEnd = getXEndOf(item);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// gather some pieces of data about the tracks\n\t\t\t\t\t\tvar spaceToDistribute = getMaxWidthOf(item); var flexFactorSum = 0;\n\t\t\t\t\t\tfor(var cx = item_xStart; cx<item_xEnd; cx++) { \n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(specifiedSizes[cx].maxType == TRACK_BREADTH_FRACTION) {\n\t\t\t\t\t\t\t\t// compute how much flexible tracks are required\n\t\t\t\t\t\t\t\tflexFactorSum += specifiedSizes[cx].maxValue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// deduce non-flexible tracks from the space to distribute\n\t\t\t\t\t\t\t\tspaceToDistribute -= xSizes[cx].base;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// compute the minimum flex fraction for this item\n\t\t\t\t\t\tif(spaceToDistribute > 0 && flexFactorSum > 0) {\n\t\t\t\t\t\t\tcurrentFraction = Math.max(currentFraction, spaceToDistribute / flexFactorSum)\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// for each flexible track\n\t\t\t\t\tfor(var x = xSizes.length; x--;) {\n\t\t\t\t\t\tif(specifiedSizes[x].maxType == TRACK_BREADTH_FRACTION) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Compute the product of the hypothetical flex fraction and the tracks flex factor\n\t\t\t\t\t\t\tvar trackSize = currentFraction * specifiedSizes[x].maxValue;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// If that size is less than the tracks base size:\n\t\t\t\t\t\t\tif(xSizes[x].base < trackSize) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// set its base size to that product.\n\t\t\t\t\t\t\t\txSizes[x].breadth = trackSize;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\txSizes[x].breadth = xSizes[x].base;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\txSizes[x].breadth = xSizes[x].base;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\n\t\t\t\t\t// compute the leftover space\n\t\t\t\t\tvar spaceToDistribute = fullDistributableSize;\n\t\t\t\t\tvar tracks = []; var fractionSum = 0;\n\t\t\t\t\tfor(var x = xSizes.length; x--;) {\n\t\t\t\t\t\tif(specifiedSizes[x].maxType == TRACK_BREADTH_FRACTION) {\n\t\t\t\t\t\t\ttracks.push(x); fractionSum += specifiedSizes[x].maxValue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tspaceToDistribute -= (xSizes[x].breadth = xSizes[x].base);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// while there are flexible tracks to size\n\t\t\t\t\twhile(tracks.length>0) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Let the hypothetical flex fraction be the leftover space divided by the sum of the flex factors of the flexible tracks.\n\t\t\t\t\t\tvar currentFraction = spaceToDistribute / fractionSum; var restart = false;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// for each flexible track\n\t\t\t\t\t\tfor(var i = tracks.length; i--;) { var x = tracks[i];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Compute the product of the hypothetical flex fraction and the tracks flex factor\n\t\t\t\t\t\t\tvar trackSize = currentFraction * specifiedSizes[x].maxValue;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// If that size is less than the tracks base size:\n\t\t\t\t\t\t\tif(xSizes[x].base < trackSize) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// set its base size to that product.\n\t\t\t\t\t\t\t\txSizes[x].breadth = trackSize;\n\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// mark as non-flexible\n\t\t\t\t\t\t\t\txSizes[x].breadth = xSizes[x].base;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// remove from computation\n\t\t\t\t\t\t\t\tfractionSum -= specifiedSizes[x].maxValue;\n\t\t\t\t\t\t\t\ttracks.splice(i,1);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// restart\n\t\t\t\t\t\t\t\trestart=true;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!restart) { tracks.length = 0; }\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar computeFinalTrackBreadth = function(xSizes, this_xSizes, fullWidth, fullDistributableWidth, getMinWidthOf, getMaxWidthOf, getXStartOf, getXEndOf) {\n\t\t\t\t\n\t\t\t\t// compute base and limit\n\t\t\t\tcomputeTrackBreadth.call(\n\t\t\t\t\tthis,\n\t\t\t\t\txSizes,\n\t\t\t\t\tthis_xSizes,\n\t\t\t\t\tgetMinWidthOf,\n\t\t\t\t\tgetMaxWidthOf,\n\t\t\t\t\tgetXStartOf,\n\t\t\t\t\tgetXEndOf\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\t// ResolveContentBasedTrackSizingFunctions (step 4)\n\t\t\t\tfor(var x = this_xSizes.length; x--;) {\n\t\t\t\t\tif(xSizes[x].limit == infinity) { xSizes[x].limit = xSizes[x].base; }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// grow tracks up to their max\n\t\t\t\tcomputeTrackBreadthIncrease.call(\n\t\t\t\t\tthis,\n\t\t\t\t\txSizes,\n\t\t\t\t\tthis_xSizes,\n\t\t\t\t\tfullWidth,\n\t\t\t\t\tfullDistributableWidth,\n\t\t\t\t\tgetMinWidthOf,\n\t\t\t\t\tgetMaxWidthOf,\n\t\t\t\t\tgetXStartOf,\n\t\t\t\t\tgetXEndOf\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\t// handle flexible things\n\t\t\t\tcomputeFlexibleTrackBreadth.call(\n\t\t\t\t\tthis,\n\t\t\t\t\txSizes,\n\t\t\t\t\tthis_xSizes,\n\t\t\t\t\tfullWidth,\n\t\t\t\t\tfullDistributableWidth,\t\t\t\t\t\n\t\t\t\t\tgetMinWidthOf,\n\t\t\t\t\tgetMaxWidthOf,\n\t\t\t\t\tgetXStartOf,\n\t\t\t\t\tgetXEndOf\n\t\t\t\t);\n\n\t\t\t}\n\t\t\t\n\t\t\t///////////////////////////////////////////////////////////\n\t\t\t// compute breadth of columns\n\t\t\t///////////////////////////////////////////////////////////\n\t\t\tvar mode = 'x';\n\t\t\tvar fullSize = fullWidth;\n\t\t\tvar fullDistributableSize = fullDistributableWidth;\n\t\t\tvar xSizes = this.xSizes.map(initializeFromConstraints);\n\t\t\tvar colGap = this.colGap;\n\n\t\t\tvar getMinWidthOf = function(item) { return item.minWidth + item.hMargins - Math.max(0, item.xEnd - item.xStart - 1) * colGap; };\n\t\t\tvar getMaxWidthOf = function(item) { return item.maxWidth + item.hMargins - Math.max(0, item.xEnd - item.xStart - 1) * colGap; };\n\t\t\tvar getXStartOf = function(item) { return item.xStart; }; \n\t\t\tvar getXEndOf = function(item) { return item.xEnd; };\n\t\t\t\n\t\t\t// compute base and limit\n\t\t\tcomputeFinalTrackBreadth.call(\n\t\t\t\tthis,\n\t\t\t\txSizes,\n\t\t\t\tthis.xSizes,\n\t\t\t\tfullWidth,\n\t\t\t\tfullDistributableWidth,\t\t\t\t\n\t\t\t\tgetMinWidthOf,\n\t\t\t\tgetMaxWidthOf,\n\t\t\t\tgetXStartOf,\n\t\t\t\tgetXEndOf\n\t\t\t);\n\t\t\t\n\t\t\t///////////////////////////////////////////////////////////\n\t\t\t// position each element absolutely, and set width to compute height\n\t\t\t///////////////////////////////////////////////////////////\n\t\t\tvar usedStyle = usedStyleOf(this.element);\n\t\t\tvar runtimeStyle = createRuntimeStyle('temp-position', this.element);\n\t\t\t\n\t\t\tif(usedStyle.getPropertyValue('position')=='static') { \n\t\t\t\truntimeStyle.set(this.element, {\"position\":\"relative\"});\n\t\t\t}\n\t\t\t\n\t\t\tthis.items.forEach(function(item) {\n\t\t\t\t\n\t\t\t\t// firstly, compute the total breadth of the spanned tracks\n\t\t\t\tvar totalBreadth = 0;\n\t\t\t\tfor(var cx = item.xStart; cx<item.xEnd; cx++) {\n\t\t\t\t\ttotalBreadth += xSizes[cx].breadth;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// secondly, adapt to the alignment properties\n\t\t\t\t\"TODO: alignment\";\n\t\t\t\t\n\t\t\t\t// finally, set the style\n\t\t\t\truntimeStyle.set(item.element, {\n\t\t\t\t\t\"position\"   : \"absolute\",\n\t\t\t\t\t\"width\"      : \"\"+totalBreadth+\"px\",\n\t\t\t\t\t\"box-sizing\" : \"border-box\"\n\t\t\t\t});\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t\t///////////////////////////////////////////////////////////\n\t\t\t// compute breadth of rows\n\t\t\t///////////////////////////////////////////////////////////\n\t\t\tvar mode = 'y';\n\t\t\tvar fullSize = fullHeight;\n\t\t\tvar fullDistributableSize = fullDistributableHeight;\n\t\t\tvar ySizes = this.ySizes.map(initializeFromConstraints);\n\t\t\tvar rowGap = this.rowGap;\n\n\t\t\tvar getMinHeightOf = function(item) { return item.element.offsetHeight + item.vMargins - Math.max(0, item.yEnd - item.yStart - 1) * rowGap; };\n\t\t\tvar getMaxHeightOf = function(item) { return item.element.offsetHeight + item.vMargins - Math.max(0, item.yEnd - item.yStart - 1) * rowGap; };\n\t\t\tvar getYStartOf = function(item) { return item.yStart; };\n\t\t\tvar getYEndOf = function(item) { return item.yEnd; };\n\t\t\t\n\t\t\tcomputeFinalTrackBreadth.call(\n\t\t\t\tthis,\n\t\t\t\tySizes,\n\t\t\t\tthis.ySizes,\n\t\t\t\tfullHeight,\n\t\t\t\tfullDistributableHeight,\t\t\t\t\n\t\t\t\tgetMinHeightOf,\n\t\t\t\tgetMaxHeightOf,\n\t\t\t\tgetYStartOf,\n\t\t\t\tgetYEndOf\n\t\t\t);\n\t\t\t\t\t\t\t\t\t\n\t\t\t///////////////////////////////////////////////////////////\n\t\t\t// release the override style of elements\n\t\t\t///////////////////////////////////////////////////////////\n\t\t\truntimeStyle.revoke();\n\t\t\t\n\t\t\t///////////////////////////////////////////////////////////\n\t\t\t// save the results\n\t\t\t////\n\t\t\tthis.finalXSizes = xSizes;\n\t\t\tthis.finalYSizes = ySizes;\n\t\t\t\n\t\t\t///////////////////////////////////////////////////////////\n\t\t\t// log the results\n\t\t\t///////////////////////////////////////////////////////////\n\t\t\t/*console.log({\n\t\t\t\tx: xSizes,\n\t\t\t\txBreadths: xSizes.map(function(e) { return e.breadth; }),\n\t\t\t\ty: ySizes,\n\t\t\t\tyBreadths: ySizes.map(function(e) { return e.breadth; }),\n\t\t\t});*/\n\t\t\n\t\t},\n\t\t\n\t\tgenerateMSGridStyle: function() {\n\t\t\t\n\t\t\tthis.element.style.setProperty(\"display\",\"-ms-grid\");\n\t\t\tthis.element.style.setProperty(\"-ms-grid-rows\",this.ySizes.join(' '));\n\t\t\tthis.element.style.setProperty(\"-ms-grid-columns\",this.xSizes.join(' '));\n\t\t\t\n\t\t\tfor(var i=this.items.length; i--;) { var item = this.items[i]; \n\t\t\t\t\n\t\t\t\titem.element.style.setProperty(\"-ms-grid-row\", item.yStart+1);\n\t\t\t\titem.element.style.setProperty(\"-ms-grid-column\", item.xStart+1);\n\t\t\t\titem.element.style.setProperty(\"-ms-grid-row-span\", item.yEnd-item.yStart);\n\t\t\t\titem.element.style.setProperty(\"-ms-grid-column-span\", item.xEnd-item.xStart);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\tgeneratePolyfilledStyle: function() {\n\t\t\n\t\t\tvar usedStyle = usedStyleOf(this.element);\n\t\t\tvar runtimeStyle = createRuntimeStyle(\"css-grid\", this.element);\n\t\t\n\t\t\tvar xSizes = this.finalXSizes;\n\t\t\tvar ySizes = this.finalYSizes;\n\t\t\t\n\t\t\tvar grid_width = 0;\n\t\t\tfor(var x = 0; x<xSizes.length; x++) {\n\t\t\t\tgrid_width += xSizes[x].breadth;\n\t\t\t}\n\t\t\tgrid_width += this.colGap * (xSizes.length - 1);\n\t\t\t\n\t\t\tvar grid_height = 0;\n\t\t\tfor(var y = 0; y<ySizes.length; y++) {\n\t\t\t\tgrid_height += ySizes[y].breadth;\n\t\t\t}\n\t\t\tgrid_height += this.rowGap * (ySizes.length - 1);\n\t\t\t\n\t\t\tvar runtimeStyleData = {};\n\t\t\tif([\"block\",\"inline-block\"].indexOf(usedStyle.getPropertyValue(\"display\")) == -1) {\n\t\t\t\truntimeStyleData[\"display\"] = \"block\";\n\t\t\t}\n\t\t\tif(usedStyle.getPropertyValue('position')=='static') {\n\t\t\t\truntimeStyleData[\"position\"] = \"relative\";\n\t\t\t}\n\t\t\t\n\t\t\truntimeStyle.set(this.element, runtimeStyleData);\n\t\t\t\n\n\t\t\t// set the position and sizing of each elements\n\t\t\tvar width = grid_width; var height = grid_height;\n\t\t\tvar items_widths = []; var items_heights = []; \n\t\t\titems_widths.length = items_heights.length = this.items.length;\n\t\t\tfor(var i=this.items.length; i--;) { var item = this.items[i]; \n\t\t\t\t\n\t\t\t\tvar left = this.hlPadding;\n\t\t\t\tfor(var x = 0; x<item.xStart; x++) {\n\t\t\t\t\tleft += xSizes[x].breadth;\n\t\t\t\t}\n\t\t\t\tleft += this.colGap * item.xStart;\n\t\t\t\t\n\t\t\t\tvar width = 0;\n\t\t\t\tfor(var x = item.xStart; x<item.xEnd; x++) {\n\t\t\t\t\twidth += xSizes[x].breadth;\n\t\t\t\t}\n\t\t\t\twidth += Math.max(0, item.xEnd - item.xStart - 1) * this.colGap;\n\t\t\t\t\n\t\t\t\tvar top = this.vtPadding;\n\t\t\t\tfor(var y = 0; y<item.yStart; y++) {\n\t\t\t\t\ttop += ySizes[y].breadth;\n\t\t\t\t}\n\t\t\t\ttop += this.rowGap * item.yStart;\n\t\t\t\t\n\t\t\t\tvar height = 0;\n\t\t\t\tfor(var y = item.yStart; y<item.yEnd; y++) {\n\t\t\t\t\theight += ySizes[y].breadth;\n\t\t\t\t}\n\t\t\t\theight += Math.max(0, item.yEnd - item.yStart - 1) * this.rowGap;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\truntimeStyle.set(item.element, {\n\t\t\t\t\t\"position\"    : \"absolute\",\n\t\t\t\t\t\"box-sizing\"  : \"border-box\",\n\t\t\t\t\t\"top\"         : \"\"+top +\"px\",\n\t\t\t\t\t\"left\"        : \"\"+left+'px'\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\titems_widths[i] = width-item.hMargins;\n\t\t\t\titems_heights[i] = height-item.vMargins;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tvar isReplaced = /^(SVG|MATH|IMG|VIDEO|PICTURE|OBJECT|EMBED|IFRAME)$/i;\n\t\t\t\n\t\t\t// if horizontal stretch\n\t\t\tif(true) { // TODO: horizontal stretch\n\t\t\t\tfor(var i=this.items.length; i--;) { var item = this.items[i]; var width = items_widths[i];\n\t\t\t\t\tif(item.minWidth <= width || isReplaced.test(item.element.tagName)) { // TODO: fix that... (should only do it for auto elements with stretch enabled)\n\t\t\t\t\t\truntimeStyle.set(item.element, {\"width\": width +'px'});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// if vertical stretch\n\t\t\tif(true) { // TODO: vertical stretch\n\t\t\t\tfor(var i=this.items.length; i--;) { var item = this.items[i]; var height = items_heights[i];\n\t\t\t\t\tif(item.element.offsetHeight <= height || isReplaced.test(item.element.tagName)) {\n\t\t\t\t\t\truntimeStyle.set(item.element, {\"height\": height+'px'});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// make sure the final size is right:\n\t\t\tvar runtimeStyleData = {};\n\t\t\t//if([\"absolute\",\"fixed\"].indexOf(usedStyle.getPropertyValue(\"position\")) >= 0) { runtimeStyleData[\"width\"] = grid_width+'px'; }\n\t\t\tif([\"auto\",\"0px\"].indexOf(usedStyle.getPropertyValue(\"width\")) >= 0) { runtimeStyleData[\"width\"] = grid_width+'px'; }\n\t\t\tif([\"auto\",\"0px\"].indexOf(usedStyle.getPropertyValue(\"height\")) >= 0) { runtimeStyleData[\"height\"] = grid_height+'px'; }\n\t\t\truntimeStyle.set(this.element, runtimeStyleData);\n\n\t\t\t\n\t\t},\n\t\t\n\t\trevokePolyfilledStyle: function() {\n\t\t\t\n\t\t\tcreateRuntimeStyle('css-grid', this.element).revoke();\n\t\t\t\n\t\t},\n\t\t\n\t\tfindXStart: function(item) {\n\t\t\n\t\t\t//////////////////////////////////////////////////////////////////////////////\n\t\t\t// TODO: this doesn't reflect the spec after the changes made at my request //\n\t\t\t//////////////////////////////////////////////////////////////////////////////\n\t\t\t\n\t\t\tvar xStart = -1;\n\t\t\tif(item.specifiedXStart.type !== LOCATE_LINE) return 0;\n\t\t\t\n\t\t\tif(item.specifiedXStart.name) {\n\t\t\t\t\n\t\t\t\t//\n\t\t\t\t// <integer>? <custom-ident>\n\t\t\t\t//\n\t\t\t\t\n\t\t\t\tif(item.specifiedXStart.index === undefined) {\n\t\t\t\t\t\n\t\t\t\t\t// First attempts to match the grid areas edge to a named grid area\n\t\t\t\t\txStart = this.findXLine(item.specifiedXStart.name+\"-start\", 0, 0, /*dontFallback*/true);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(xStart==-1) {\n\t\t\t\t\n\t\t\t\t\t// Otherwise, contributes the first named line with the specified name to the grid items placement. \n\t\t\t\t\txStart = this.findXLine(item.specifiedXStart.name, 0, (item.specifiedXStart.index||1)-1);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t//\n\t\t\t\t// <integer>\n\t\t\t\t//\n\t\t\t\txStart = (item.specifiedXStart.index||1)-1;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// correct impossible values\n\t\t\tif(xStart < 0) { xStart=0; }\n\t\t\t\n\t\t\t// return the final result\n\t\t\treturn item.xStart = xStart;\n\t\t\t\n\t\t},\n\t\t\n\t\tfindYStart: function(item) {\n\t\t\t\n\t\t\tvar yStart = -1;\n\t\t\tif(item.specifiedYStart.type !== LOCATE_LINE) return 0;\n\n\t\t\tif(item.specifiedYStart.name) {\n\t\t\t\t\n\t\t\t\t//\n\t\t\t\t// <interger>? <custom-ident>\n\t\t\t\t//\n\t\t\t\t\n\t\t\t\tif(item.specifiedYStart.index === undefined) {\n\t\t\t\t\t\n\t\t\t\t\t// First attempts to match the grid areas edge to a named grid area\n\t\t\t\t\tyStart = this.findYLine(item.specifiedYStart.name+\"-start\", 0, 0, /*dontFallback*/true);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(yStart == -1) {\n\t\t\t\t\t\n\t\t\t\t\t// Otherwise, contributes the first named line with the specified name to the grid items placement. \n\t\t\t\t\tyStart = this.findYLine(item.specifiedYStart.name, 0,(item.specifiedYStart.index||1)-1);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t//\n\t\t\t\t// <integer>\n\t\t\t\t//\n\t\t\t\tyStart = (item.specifiedYStart.index||1)-1;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// correct impossible values\n\t\t\tif(yStart < 0) { yStart=0; }\n\t\t\t\n\t\t\t// return the final result\n\t\t\treturn item.yStart = yStart;\n\t\t\t\n\t\t},\n\t\t\n\t\tfindXEnd: function(item) {\n\t\t\t\n\t\t\tvar xEnd = -1;\n\t\t\tvar xStart = item.xStart;\n\t\t\tswitch(item.specifiedXEnd.type) {\n\t\t\t\t\n\t\t\t\tcase LOCATE_LINE:\n\t\t\t\t\tif(item.specifiedXEnd.name) {\n\t\t\t\t\t\tif(item.specifiedXEnd.index === undefined) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// First attempts to match the grid areas edge to a named grid area\n\t\t\t\t\t\t\txEnd = this.findXLine(item.specifiedXEnd.name+\"-end\", 0, 0, /*dontFallback*/true);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xEnd == -1) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Otherwise, contributes the first named line with the specified name to the grid items placement. \n\t\t\t\t\t\t\txEnd = this.findXLine(item.specifiedXEnd.name, 0, (item.specifiedXEnd.index||1)-1);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\txEnd = (item.specifiedXEnd.index||1)-1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase LOCATE_SPAN:\n\t\t\t\t\tif(item.specifiedXEnd.name) {\n\t\t\t\t\t\n\t\t\t\t\t\t// Set the corresponding edge N lines apart from its opposite edge. \n\t\t\t\t\t\txEnd = this.findXLine(item.specifiedXEnd.name, xStart+1, (item.specifiedXEnd.index||1)-1);\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Set the corresponding edge N lines apart from its opposite edge. \n\t\t\t\t\t\txEnd = xStart+((item.specifiedXEnd.index|0)||1);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase LOCATE_AUTO:\n\t\t\t\t\t// I don't support subgrids, so this is always true:\n\t\t\t\t\txEnd = xStart+1;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(xEnd <= xStart) { xEnd = xStart+1; }\n\t\t\treturn item.xEnd = xEnd;\n\t\t\t\n\t\t},\n\t\t\n\t\tfindYEnd: function(item) {\n\t\t\t\n\t\t\tvar yEnd = -1;\n\t\t\tvar yStart = item.yStart;\n\t\t\tswitch(item.specifiedYEnd.type) {\n\t\t\t\t\n\t\t\t\tcase LOCATE_LINE:\n\t\t\t\t\tif(item.specifiedYEnd.name) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// <integer>? <identifier>\n\t\t\t\t\t\t// \n\t\t\t\t\t\tif(item.specifiedYEnd.index === undefined) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// First attempts to match the grid areas edge to a named grid area\n\t\t\t\t\t\t\tyEnd = this.findYLine(item.specifiedYEnd.name+\"-end\", 0, 0, /*dontFallback*/true);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(yEnd == -1) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Otherwise, contributes the first named line with the specified name to the grid items placement. \n\t\t\t\t\t\t\tyEnd = this.findYLine(item.specifiedYEnd.name, 0, (item.specifiedYEnd.index||1)-1);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// <integer>\n\t\t\t\t\t\t//\n\t\t\t\t\t\tyEnd = (item.specifiedYEnd.index||1)-1;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase LOCATE_SPAN:\n\t\t\t\t\tif(item.specifiedYEnd.name) {\n\t\t\t\t\t\n\t\t\t\t\t\t// Set the corresponding edge N lines apart from its opposite edge. \n\t\t\t\t\t\tyEnd = this.findYLine(item.specifiedYEnd.name, yStart+1, (item.specifiedYEnd.index||1)-1);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// TODO: I'm having the wrong behavior here, I sent a mail to csswg to get the spec changed\n\t\t\t\t\t\t// \"The spec is more what you'd call 'guidelines' than actual rules\"\n\t\t\t\t\t\tif(yEnd==-1) { yEnd = 0; }\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Set the corresponding edge N lines apart from its opposite edge. \n\t\t\t\t\t\tyEnd = yStart+((item.specifiedYEnd.index|0)||1);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase LOCATE_AUTO:\n\t\t\t\t\t// I don't support subgrids, so this is always true:\n\t\t\t\t\tyEnd = yStart+1;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// correct impossible end values\n\t\t\tif(yEnd <= yStart) { yEnd = yStart+1; }\n\t\t\t\n\t\t\t// return the final result\n\t\t\treturn item.yEnd = yEnd;\n\n\t\t},\n\t\t\n\t\tfindXLine: function(name, startIndex, skipCount, dontFallback) {\n\t\t\n\t\t\tstartIndex=startIndex|0;\n\t\t\tskipCount=skipCount|0;\n\t\t\t\n\t\t\t// special case for cases where the name isn't provided\n\t\t\tif(!name) {\n\t\t\t\tif(startIndex+skipCount < this.xLines.length) {\n\t\t\t\t\treturn startIndex+skipCount;\n\t\t\t\t} else {\n\t\t\t\t\treturn this.xLines.length;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// find the 1+skipCount'th line to match the right name\n\t\t\tvar last = -1;\n\t\t\tfor(var i = startIndex; i<this.xLines.length; i++) {\n\t\t\t\tif(this.xLines[i].indexOf(name) >= 0 || (!dontFallback && this.xLines[i].indexOf('*') >= 0)) { \n\t\t\t\t\tif(skipCount>0) { last=i; skipCount--; }\n\t\t\t\t\telse { return i; }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if we still have lines to find, we know that lines of the implicit grid match all names\n\t\t\tif(!dontFallback) { console.warn('[CSS-GRID] Missing '+(skipCount+1)+' lines named \"'+name+'\" after line '+startIndex+'.'); last = this.xLines.length+skipCount+1; this.ensureRows(last); }\n\t\t\treturn last;\n\t\t\t\n\t\t},\n\t\t\n\t\tfindYLine: function(name, startIndex, skipCount, dontFallback) {\n\n\t\t\tstartIndex=startIndex|0;\n\t\t\tskipCount=skipCount|0;\n\t\t\t\n\t\t\t// special case for cases where the name isn't provided\n\t\t\tif(!name) {\n\t\t\t\tif(startIndex+skipCount < this.yLines.length) {\n\t\t\t\t\treturn startIndex+skipCount;\n\t\t\t\t} else {\n\t\t\t\t\treturn this.yLines.length;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// find the 1+skipCount'th line to match the right name\n\t\t\tvar last = -1;\n\t\t\tfor(var i = startIndex; i<this.yLines.length; i++) {\n\t\t\t\tif(this.yLines[i].indexOf(name) >= 0 || (!dontFallback && this.yLines[i].indexOf('*') >= 0)) { \n\t\t\t\t\tif(skipCount>0) { last=i; skipCount--; }\n\t\t\t\t\telse { return i; }\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// if we still have lines to find, we know that lines of the implicit grid match all names\n\t\t\tif(!dontFallback) { console.warn('[CSS-GRID] Missing '+(skipCount+1)+' lines named \"'+name+'\" after line '+startIndex+'.'); last = this.yLines.length+skipCount+1; this.ensureColumns(last); }\n\t\t\treturn last;\n\t\t\t\n\t\t},\n\t\t\n\t}\n\t\n\tvar cssGrid = {\n\t\t\n\t\tLOCATE_LINE   :  LOCATE_LINE,\n\t\tLOCATE_SPAN   :  LOCATE_SPAN,\n\t\tLOCATE_AREA   :  LOCATE_AREA,\n\t\tLOCATE_AUTO   :  LOCATE_AUTO,\n\t\t\n\t\tALIGN_START   :  ALIGN_START,\n\t\tALIGN_CENTER  :  ALIGN_CENTER,\n\t\tALIGN_END     :  ALIGN_END,\n\t\tALIGN_FIT     :  ALIGN_FIT,  \n\t\t\n\t\tTRACK_BREADTH_AUTO        : TRACK_BREADTH_AUTO,\n\t\tTRACK_BREADTH_LENGTH      : TRACK_BREADTH_LENGTH,\n\t\tTRACK_BREADTH_FRACTION    : TRACK_BREADTH_FRACTION,\n\t\tTRACK_BREADTH_PERCENTAGE  : TRACK_BREADTH_PERCENTAGE,\n\t\tTRACK_BREADTH_MIN_CONTENT : TRACK_BREADTH_MIN_CONTENT,\n\t\tTRACK_BREADTH_MAX_CONTENT : TRACK_BREADTH_MAX_CONTENT,\n\n\t\tGridLayout: GridLayout, \n\t\tGridItem: GridItem, \n\t\tGridItemPosition: GridItemPosition,\n\t\tGridTrackBreadth: GridTrackBreadth,\n\t\t\n\t};\n\treturn cssGrid;\n\t\n})(window, document)\n\nrequire.define('src/css-grid/lib/grid-layout.js');","// TODO: document the \"no_auto_css_grid\" flag?\n// TOOD: document the \"no_ms_grid_implementation\" flag?\n\n!(function(window, document) { \"use strict\";\n\n\tif(\"gridRow\" in document.body.style) { console.warn('Polyfill skipped'); return; }\n\n\trequire('src/core/polyfill-dom-console.js');\n\tvar cssCascade = require('src/core/css-cascade.js');\n\tvar cssGrid = require('src/css-grid/lib/grid-layout.js');\n\t\n\tvar enabled = false;\n\tvar enablePolyfill = function() { if(enabled) { return; } else { enabled = true; }\n\n\t\t//\n\t\t// [0] define css properties\n\t\t// those properties can now be set using Element.myStyle.xyz if they weren't already\n\t\t//\n\t\t\n\t\tvar gridProperties = ['grid','grid-template','grid-template-rows','grid-template-columns','grid-template-areas','grid-areas','grid-auto-flow','grid-row-gap','grid-column-gap','grid-gap'];\n\t\tvar gridItemProperties = ['grid-area','grid-row','grid-column','grid-row-start','grid-row-end','grid-column-start','grid-column-end','order'];\n\t\tfor(var i=gridProperties.length; i--;)     { cssCascade.polyfillStyleInterface(gridProperties[i]); }\n\t\tfor(var i=gridItemProperties.length; i--;) { cssCascade.polyfillStyleInterface(gridItemProperties[i]); }\n\t\t\n\t\t// \n\t\t// [1] when any update happens:\n\t\t// construct new content and region flow pairs\n\t\t// restart the region layout algorithm for the modified pairs\n\t\t// \n\t\t\n\t\tcssCascade.startMonitoringProperties(\n\t\t\tgridProperties, \n\t\t\t{\n\t\t\t\tonupdate: function onupdate(element, rule) {\n\n\t\t\t\t\t// log some message in the console for debug\n\t\t\t\t\tcssConsole.dir({message:\"onupdate\",element:element,selector:rule.selector.toCSSString(),rule:rule});\n\t\t\t\t\t\n\t\t\t\t\t// check if the element already has a grid or grid-item layout\n\t\t\t\t\tif(element.gridLayout) {\n\t\t\t\t\t\n\t\t\t\t\t\t// the layout must be recomputed\n\t\t\t\t\t\telement.gridLayout.scheduleRelayout();\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\t\t// setup a new grid model, and schedule a relayout\n\t\t\t\t\t\telement.gridLayout = new cssGrid.GridLayout(element);\n\t\t\t\t\t\telement.gridLayout.scheduleRelayout();\n\t\t\t\t\t\n\t\t\t\t\t\t// TODO: watch DOM for updates in the element?\n\t\t\t\t\t\tif(\"MutationObserver\" in window) {\n\t\t\t\t\t\t\t// non-attribute-related changes\n\t\t\t\t\t\t\tvoid function() {\n\t\t\t\t\t\t\t\tvar observer = new MutationObserver(function(e) {\n\t\t\t\t\t\t\t\t\telement.gridLayout.scheduleRelayout(); return;\n\t\t\t\t\t\t\t\t\t//debugger; console.log(e);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tvar target = document.documentElement;\n\t\t\t\t\t\t\t\tvar config = {\n\t\t\t\t\t\t\t\t\tsubtree: true, \n\t\t\t\t\t\t\t\t\tattributes: false, \n\t\t\t\t\t\t\t\t\tchildList: true, \n\t\t\t\t\t\t\t\t\tcharacterData: true\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tobserver.observe(target, config);\n\t\t\t\t\t\t\t}();\n\t\t\t\t\t\t\t// attribute-related changes\n\t\t\t\t\t\t\tvoid function() {\n\t\t\t\t\t\t\t\tvar observer = new MutationObserver(function(e) {\n\t\t\t\t\t\t\t\t\telement.gridLayout.scheduleRelayout(); return;\n\t\t\t\t\t\t\t\t\t//debugger; console.log(e);\n\t\t\t\t\t\t\t\t\t//for(var i = e.length; i--;) {\n\t\t\t\t\t\t\t\t\t//\tvar attr = e[i].attributeName;\n\t\t\t\t\t\t\t\t\t//\tif(attr=='class' || attr=='style') {\n\t\t\t\t\t\t\t\t\t//\t\telement.gridLayout.scheduleRelayout(); return;\n\t\t\t\t\t\t\t\t\t//\t}\n\t\t\t\t\t\t\t\t\t//}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tvar target = element;\n\t\t\t\t\t\t\t\tvar config = { \n\t\t\t\t\t\t\t\t\tsubtree: true, \n\t\t\t\t\t\t\t\t\tattributes: true, \n\t\t\t\t\t\t\t\t\tattributeFilter: ['class', 'style', 'width', 'height', 'src'],\n\t\t\t\t\t\t\t\t\tchildList: false, \n\t\t\t\t\t\t\t\t\tcharacterData: false\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else if(\"MutationEvent\" in window) {\n\t\t\t\t\t\t\telement.addEventListener('DOMSubtreeModified', function() {\n\t\t\t\t\t\t\t\tif(!element.gridLayout.isLayoutScheduled) { element.gridLayout.scheduleRelayout(); }\n\t\t\t\t\t\t\t}, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// TODO: watch resize events for relayout?\n\t\t\t\t\t\tvar lastWidth = element.offsetWidth;\n\t\t\t\t\t\tvar lastHeight = element.offsetHeight;\n\t\t\t\t\t\tvar updateOnResize = function() {\n\t\t\t\t\t\t\tif(!element.gridLayout) { return; }\n\t\t\t\t\t\t\tif(lastWidth != element.offsetWidth || lastHeight != element.offsetHeight) {\n\t\t\t\t\t\t\t\t// update last known size\n\t\t\t\t\t\t\t\tlastWidth = element.offsetWidth;\n\t\t\t\t\t\t\t\tlastHeight = element.offsetHeight;\n\t\t\t\t\t\t\t\t// relayout (and prevent double-dispatch)\n\t\t\t\t\t\t\t\telement.gridLayout.scheduleRelayout();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trequestAnimationFrame(updateOnResize);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trequestAnimationFrame(updateOnResize);\n\t\t\t\t\t\t// TODO: watch the load event for relayout?\n\t\t\t\t\t\twindow.addEventListener('load', function(){element.gridLayout&&element.gridLayout.scheduleRelayout()});\n\t\t\t\t\t\tvar images = element.querySelectorAll('img');\n\t\t\t\t\t\tfor(var i = images.length; i--;) {\n\t\t\t\t\t\t\timages[i].addEventListener('load', function(){element.gridLayout&&element.gridLayout.scheduleRelayout()});\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\t\n\t\tcssCascade.startMonitoringProperties(\n\t\t\tgridItemProperties, \n\t\t\t{\n\t\t\t\tonupdate: function onupdate(element, rule) {\n\n\t\t\t\t\t// log some message in the console for debug\n\t\t\t\t\tcssConsole.dir({message:\"onupdate\",element:element,selector:rule.selector.toCSSString(),rule:rule});\n\t\t\t\t\t\n\t\t\t\t\t// check if the element already has a grid or grid-item layout\n\t\t\t\t\tif(element.parentGridLayout) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// the parent layout must be recomputed\n\t\t\t\t\t\telement.parentGridLayout.scheduleRelayout();\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\t\n\t}\n\n\t// expose the enabler\n\tcssGrid.enablePolyfill = enablePolyfill;\n\t\n\t// enable the polyfill automatically\n\ttry {\n\t\tif(!(\"no_auto_css_grid\" in window)) { enablePolyfill(); }\n\t} catch (ex) {\n\t\tsetImmediate(function() { throw ex; });\n\t}\n\t\n\t// return the module\n\treturn cssGrid;\n\t\n})(window, document);\nrequire.define('src/css-grid/polyfill.js');","//require('core:dom-matchMedia-polyfill');\n//require('core:dom-classList-polyfill');\nrequire('src/css-grid/polyfill.js');\nrequire.define('src/requirements.js');"]}