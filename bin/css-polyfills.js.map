{"version":3,"sources":["..\\src\\core\\css-syntax.js","..\\src\\core\\css-sizing.js","..\\src\\core\\css-box.js","..\\src\\core\\css-units.js","..\\src\\css-grid\\lib\\grid-layout.js","..\\src\\css-grid\\polyfill.js","..\\src\\requirements.js"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;ACvzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kD;;;;AChzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;ACtFA;AACA;AACA;AACA,sC","file":"css-polyfills.js","sourcesContent":["//\r\n// note: this file is based on Tab Atkins's CSS Parser\r\n// please include him (@tabatkins) if you open any issue for this file\r\n// \r\nmodule.exports = (function() { \"use strict\";\r\n\r\n// \r\n// exports\r\n//\r\nvar cssSyntax = { \r\n\ttokenize: function(string) {/*filled later*/}, \r\n\tparse: function(tokens) {/*filled later*/}\r\n};\r\n\r\n//\r\n// css tokenizer\r\n//\r\n\r\n// Add support for token lists (superclass of array)\r\nfunction TokenList() {\r\n\tvar array = []; \r\n\tarray.toCSSString=TokenListToCSSString;\r\n\treturn array;\r\n}\r\nfunction TokenListToCSSString(sep) {\r\n\tif(sep) {\r\n\t\treturn this.map(function(o) { return o.toCSSString(); }).join(sep);\r\n\t} else {\r\n\t\treturn this.asCSSString || (this.asCSSString = (\r\n\t\t\tthis.map(function(o) { return o.toCSSString(); }).join(\"/**/\")\r\n\t\t\t\t.replace(/( +\\/\\*\\*\\/ *| * | *\\/\\*\\*\\/ +)/g,\" \")\r\n\t\t\t\t.replace(/( +\\/\\*\\*\\/ *| * | *\\/\\*\\*\\/ +)/g,\" \")\r\n\t\t\t\t.replace(/(\\!|\\:|\\;|\\@|\\.|\\,|\\*|\\=|\\&|\\\\|\\/|\\<|\\>|\\[|\\{|\\(|\\]|\\}|\\)|\\|)\\/\\*\\*\\//g,\"$1\")\r\n\t\t\t\t.replace(/\\/\\*\\*\\/(\\!|\\:|\\;|\\@|\\.|\\,|\\*|\\=|\\&|\\\\|\\/|\\<|\\>|\\[|\\{|\\(|\\]|\\}|\\)|\\|)/g,\"$1\")\r\n\t\t));\r\n\t}\r\n}\r\ncssSyntax.TokenList = TokenList;\r\ncssSyntax.TokenListToCSSString = TokenListToCSSString;\r\n\r\nfunction between(num, first, last) { return num >= first && num <= last; }\r\nfunction digit(code) { return between(code, 0x30,0x39); }\r\nfunction hexdigit(code) { return digit(code) || between(code, 0x41,0x46) || between(code, 0x61,0x66); }\r\nfunction uppercaseletter(code) { return between(code, 0x41,0x5a); }\r\nfunction lowercaseletter(code) { return between(code, 0x61,0x7a); }\r\nfunction letter(code) { return uppercaseletter(code) || lowercaseletter(code); }\r\nfunction nonascii(code) { return code >= 0x80; }\r\nfunction namestartchar(code) { return letter(code) || nonascii(code) || code == 0x5f; }\r\nfunction namechar(code) { return namestartchar(code) || digit(code) || code == 0x2d; }\r\nfunction nonprintable(code) { return between(code, 0,8) || code == 0xb || between(code, 0xe,0x1f) || code == 0x7f; }\r\nfunction newline(code) { return code == 0xa; }\r\nfunction whitespace(code) { return newline(code) || code == 9 || code == 0x20; }\r\nfunction badescape(code) { return newline(code) || isNaN(code); }\r\n\r\nvar maximumallowedcodepoint = 0x10ffff;\r\n\r\nfunction InvalidCharacterError(message) {\r\n\tthis.message = message;\r\n};\r\nInvalidCharacterError.prototype = new Error;\r\nInvalidCharacterError.prototype.name = 'InvalidCharacterError';\r\n\r\nfunction preprocess(str) {\r\n\t// Turn a string into an array of code points,\r\n\t// following the preprocessing cleanup rules.\r\n\tvar codepoints = [];\r\n\tfor(var i = 0; i < str.length; i++) {\r\n\t\tvar code = str.charCodeAt(i);\r\n\t\tif(code == 0xd && str.charCodeAt(i+1) == 0xa) {\r\n\t\t\tcode = 0xa; i++;\r\n\t\t}\r\n\t\tif(code == 0xd || code == 0xc) code = 0xa;\r\n\t\tif(code == 0x0) code = 0xfffd;\r\n\t\tif(between(code, 0xd800, 0xdbff) && between(str.charCodeAt(i+1), 0xdc00, 0xdfff)) {\r\n\t\t\t// Decode a surrogate pair into an astral codepoint.\r\n\t\t\tvar lead = code - 0xd800;\r\n\t\t\tvar trail = str.charCodeAt(i+1) - 0xdc00;\r\n\t\t\tcode = Math.pow(2, 21) + lead * Math.pow(2, 10) + trail;\r\n\t\t}\r\n\t\tcodepoints.push(code);\r\n\t}\r\n\treturn codepoints;\r\n}\r\n\r\nfunction stringFromCode(code) {\r\n\tif(code <= 0xffff) return String.fromCharCode(code);\r\n\t// Otherwise, encode astral char as surrogate pair.\r\n\tcode -= Math.pow(2, 21);\r\n\tvar lead = Math.floor(code/Math.pow(2, 10)) + 0xd800;\r\n\tvar trail = code % Math.pow(2, 10); + 0xdc00;\r\n\treturn String.fromCharCode(lead) + String.fromCharCode(trail);\r\n}\r\n\r\nfunction tokenize(str) {\r\n\tstr = preprocess(str);\r\n\tvar i = -1;\r\n\tvar tokens = new TokenList();\r\n\tvar code;\r\n\r\n\t// Line number information.\r\n\tvar line = 0;\r\n\tvar column = 0;\r\n\t// The only use of lastLineLength is in reconsume().\r\n\tvar lastLineLength = 0;\r\n\tvar incrLineno = function() {\r\n\t\tline += 1;\r\n\t\tlastLineLength = column;\r\n\t\tcolumn = 0;\r\n\t};\r\n\tvar locStart = {line:line, column:column};\r\n\r\n\tvar codepoint = function(i) {\r\n\t\tif(i >= str.length) {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\treturn str[i];\r\n\t}\r\n\tvar next = function(num) {\r\n\t\tif(num === undefined) { num = 1; }\r\n\t\tif(num > 3) { throw \"Spec Error: no more than three codepoints of lookahead.\"; }\r\n\t\treturn codepoint(i+num);\r\n\t};\r\n\tvar consume = function(num) {\r\n\t\tif(num === undefined)\r\n\t\t\tnum = 1;\r\n\t\ti += num;\r\n\t\tcode = codepoint(i);\r\n\t\tif(newline(code)) incrLineno();\r\n\t\telse column += num;\r\n\t\t//console.log('Consume '+i+' '+String.fromCharCode(code) + ' 0x' + code.toString(16));\r\n\t\treturn true;\r\n\t};\r\n\tvar reconsume = function() {\r\n\t\ti -= 1;\r\n\t\tif (newline(code)) {\r\n\t\t\tline -= 1;\r\n\t\t\tcolumn = lastLineLength;\r\n\t\t} else {\r\n\t\t\tcolumn -= 1;\r\n\t\t}\r\n\t\tlocStart.line = line;\r\n\t\tlocStart.column = column;\r\n\t\treturn true;\r\n\t};\r\n\tvar eof = function(codepoint) {\r\n\t\tif(codepoint === undefined) codepoint = code;\r\n\t\treturn codepoint == -1;\r\n\t};\r\n\tvar donothing = function() {};\r\n\tvar tokenizeerror = function() { console.log(\"Parse error at index \" + i + \", processing codepoint 0x\" + code.toString(16) + \".\");return true; };\r\n\r\n\tvar consumeAToken = function() {\r\n\t\tconsumeComments();\r\n\t\tconsume();\r\n\t\tif(whitespace(code)) {\r\n\t\t\twhile(whitespace(next())) consume();\r\n\t\t\treturn new WhitespaceToken;\r\n\t\t}\r\n\t\telse if(code == 0x22) return consumeAStringToken();\r\n\t\telse if(code == 0x23) {\r\n\t\t\tif(namechar(next()) || areAValidEscape(next(1), next(2))) {\r\n\t\t\t\tvar token = new HashToken();\r\n\t\t\t\tif(wouldStartAnIdentifier(next(1), next(2), next(3))) token.type = \"id\";\r\n\t\t\t\ttoken.value = consumeAName();\r\n\t\t\t\treturn token;\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x24) {\r\n\t\t\tif(next() == 0x3d) {\r\n\t\t\t\tconsume();\r\n\t\t\t\treturn new SuffixMatchToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x27) return consumeAStringToken();\r\n\t\telse if(code == 0x28) return new OpenParenToken();\r\n\t\telse if(code == 0x29) return new CloseParenToken();\r\n\t\telse if(code == 0x2a) {\r\n\t\t\tif(next() == 0x3d) {\r\n\t\t\t\tconsume();\r\n\t\t\t\treturn new SubstringMatchToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x2b) {\r\n\t\t\tif(startsWithANumber()) {\r\n\t\t\t\treconsume();\r\n\t\t\t\treturn consumeANumericToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x2c) return new CommaToken();\r\n\t\telse if(code == 0x2d) {\r\n\t\t\tif(startsWithANumber()) {\r\n\t\t\t\treconsume();\r\n\t\t\t\treturn consumeANumericToken();\r\n\t\t\t} else if(next(1) == 0x2d && next(2) == 0x3e) {\r\n\t\t\t\tconsume(2);\r\n\t\t\t\treturn new CDCToken();\r\n\t\t\t} else if(startsWithAnIdentifier()) {\r\n\t\t\t\treconsume();\r\n\t\t\t\treturn consumeAnIdentlikeToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x2e) {\r\n\t\t\tif(startsWithANumber()) {\r\n\t\t\t\treconsume();\r\n\t\t\t\treturn consumeANumericToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x3a) return new ColonToken;\r\n\t\telse if(code == 0x3b) return new SemicolonToken;\r\n\t\telse if(code == 0x3c) {\r\n\t\t\tif(next(1) == 0x21 && next(2) == 0x2d && next(3) == 0x2d) {\r\n\t\t\t\tconsume(3);\r\n\t\t\t\treturn new CDOToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x40) {\r\n\t\t\tif(wouldStartAnIdentifier(next(1), next(2), next(3))) {\r\n\t\t\t\treturn new AtKeywordToken(consumeAName());\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x5b) return new OpenSquareToken();\r\n\t\telse if(code == 0x5c) {\r\n\t\t\tif(startsWithAValidEscape()) {\r\n\t\t\t\treconsume();\r\n\t\t\t\treturn consumeAnIdentlikeToken();\r\n\t\t\t} else {\r\n\t\t\t\ttokenizeerror();\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x5d) return new CloseSquareToken();\r\n\t\telse if(code == 0x5e) {\r\n\t\t\tif(next() == 0x3d) {\r\n\t\t\t\tconsume();\r\n\t\t\t\treturn new PrefixMatchToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x7b) return new OpenCurlyToken();\r\n\t\telse if(code == 0x7c) {\r\n\t\t\tif(next() == 0x3d) {\r\n\t\t\t\tconsume();\r\n\t\t\t\treturn new DashMatchToken();\r\n\t\t\t} else if(next() == 0x7c) {\r\n\t\t\t\tconsume();\r\n\t\t\t\treturn new ColumnToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x7d) return new CloseCurlyToken();\r\n\t\telse if(code == 0x7e) {\r\n\t\t\tif(next() == 0x3d) {\r\n\t\t\t\tconsume();\r\n\t\t\t\treturn new IncludeMatchToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(digit(code)) {\r\n\t\t\treconsume();\r\n\t\t\treturn consumeANumericToken();\r\n\t\t}\r\n\t\telse if(namestartchar(code)) {\r\n\t\t\treconsume();\r\n\t\t\treturn consumeAnIdentlikeToken();\r\n\t\t}\r\n\t\telse if(eof()) return new EOFToken();\r\n\t\telse return new DelimToken(code);\r\n\t};\r\n\r\n\tvar consumeComments = function() {\r\n\t\twhile(next(1) == 0x2f && next(2) == 0x2a) {\r\n\t\t\tconsume(2);\r\n\t\t\twhile(true) {\r\n\t\t\t\tconsume();\r\n\t\t\t\tif(code == 0x2a && next() == 0x2f) {\r\n\t\t\t\t\tconsume();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else if(eof()) {\r\n\t\t\t\t\ttokenizeerror();\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tvar consumeANumericToken = function() {\r\n\t\tvar num = consumeANumber();\r\n\t\tif(wouldStartAnIdentifier(next(1), next(2), next(3))) {\r\n\t\t\tvar token = new DimensionToken();\r\n\t\t\ttoken.value = num.value;\r\n\t\t\ttoken.repr = num.repr;\r\n\t\t\ttoken.type = num.type;\r\n\t\t\ttoken.unit = consumeAName();\r\n\t\t\treturn token;\r\n\t\t} else if(next() == 0x25) {\r\n\t\t\tconsume();\r\n\t\t\tvar token = new PercentageToken();\r\n\t\t\ttoken.value = num.value;\r\n\t\t\ttoken.repr = num.repr;\r\n\t\t\treturn token;\r\n\t\t} else {\r\n\t\t\tvar token = new NumberToken();\r\n\t\t\ttoken.value = num.value;\r\n\t\t\ttoken.repr = num.repr;\r\n\t\t\ttoken.type = num.type;\r\n\t\t\treturn token;\r\n\t\t}\r\n\t};\r\n\r\n\tvar consumeAnIdentlikeToken = function() {\r\n\t\tvar str = consumeAName();\r\n\t\tif(str.toLowerCase() == \"url\" && next() == 0x28) {\r\n\t\t\tconsume();\r\n\t\t\twhile(whitespace(next(1)) && whitespace(next(2))) consume();\r\n\t\t\tif(next() == 0x22 || next() == 0x27) {\r\n\t\t\t\treturn new FunctionToken(str);\r\n\t\t\t} else if(whitespace(next()) && (next(2) == 0x22 || next(2) == 0x27)) {\r\n\t\t\t\treturn new FunctionToken(str);\r\n\t\t\t} else {\r\n\t\t\t\treturn consumeAURLToken();\r\n\t\t\t}\r\n\t\t} else if(next() == 0x28) {\r\n\t\t\tconsume();\r\n\t\t\treturn new FunctionToken(str);\r\n\t\t} else {\r\n\t\t\treturn new IdentifierToken(str);\r\n\t\t}\r\n\t};\r\n\r\n\tvar consumeAStringToken = function(endingCodePoint) {\r\n\t\tif(endingCodePoint === undefined) endingCodePoint = code;\r\n\t\tvar string = \"\";\r\n\t\twhile(consume()) {\r\n\t\t\tif(code == endingCodePoint || eof()) {\r\n\t\t\t\treturn new StringToken(string);\r\n\t\t\t} else if(newline(code)) {\r\n\t\t\t\ttokenizeerror();\r\n\t\t\t\treconsume();\r\n\t\t\t\treturn new BadStringToken();\r\n\t\t\t} else if(code == 0x5c) {\r\n\t\t\t\tif(eof(next())) {\r\n\t\t\t\t\tdonothing();\r\n\t\t\t\t} else if(newline(next())) {\r\n\t\t\t\t\tconsume();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstring += stringFromCode(consumeEscape())\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tstring += stringFromCode(code);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tvar consumeAURLToken = function() {\r\n\t\tvar token = new URLToken(\"\");\r\n\t\twhile(whitespace(next())) consume();\r\n\t\tif(eof(next())) return token;\r\n\t\twhile(consume()) {\r\n\t\t\tif(code == 0x29 || eof()) {\r\n\t\t\t\treturn token;\r\n\t\t\t} else if(whitespace(code)) {\r\n\t\t\t\twhile(whitespace(next())) consume();\r\n\t\t\t\tif(next() == 0x29 || eof(next())) {\r\n\t\t\t\t\tconsume();\r\n\t\t\t\t\treturn token;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconsumeTheRemnantsOfABadURL();\r\n\t\t\t\t\treturn new BadURLToken();\r\n\t\t\t\t}\r\n\t\t\t} else if(code == 0x22 || code == 0x27 || code == 0x28 || nonprintable(code)) {\r\n\t\t\t\ttokenizeerror();\r\n\t\t\t\tconsumeTheRemnantsOfABadURL();\r\n\t\t\t\treturn new BadURLToken();\r\n\t\t\t} else if(code == 0x5c) {\r\n\t\t\t\tif(startsWithAValidEscape()) {\r\n\t\t\t\t\ttoken.value += stringFromCode(consumeEscape());\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttokenizeerror();\r\n\t\t\t\t\tconsumeTheRemnantsOfABadURL();\r\n\t\t\t\t\treturn new BadURLToken();\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\ttoken.value += stringFromCode(code);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tvar consumeEscape = function() {\r\n\t\t// Assume the the current character is the \\\r\n\t\t// and the next code point is not a newline.\r\n\t\tconsume();\r\n\t\tif(hexdigit(code)) {\r\n\t\t\t// Consume 1-6 hex digits\r\n\t\t\tvar digits = [code];\r\n\t\t\tfor(var total = 0; total < 5; total++) {\r\n\t\t\t\tif(hexdigit(next())) {\r\n\t\t\t\t\tconsume();\r\n\t\t\t\t\tdigits.push(code);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(whitespace(next())) consume();\r\n\t\t\tvar value = parseInt(digits.map(function(x){return String.fromCharCode(x);}).join(''), 16);\r\n\t\t\tif( value > maximumallowedcodepoint ) value = 0xfffd;\r\n\t\t\treturn value;\r\n\t\t} else if(eof()) {\r\n\t\t\treturn 0xfffd;\r\n\t\t} else {\r\n\t\t\treturn code;\r\n\t\t}\r\n\t};\r\n\r\n\tvar areAValidEscape = function(c1, c2) {\r\n\t\tif(c1 != 0x5c) return false;\r\n\t\tif(newline(c2)) return false;\r\n\t\treturn true;\r\n\t};\r\n\tvar startsWithAValidEscape = function() {\r\n\t\treturn areAValidEscape(code, next());\r\n\t};\r\n\r\n\tvar wouldStartAnIdentifier = function(c1, c2, c3) {\r\n\t\tif(c1 == 0x2d) {\r\n\t\t\treturn namestartchar(c2) || c2 == 0x2d || areAValidEscape(c2, c3);\r\n\t\t} else if(namestartchar(c1)) {\r\n\t\t\treturn true;\r\n\t\t} else if(c1 == 0x5c) {\r\n\t\t\treturn areAValidEscape(c1, c2);\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n\tvar startsWithAnIdentifier = function() {\r\n\t\treturn wouldStartAnIdentifier(code, next(1), next(2));\r\n\t};\r\n\r\n\tvar wouldStartANumber = function(c1, c2, c3) {\r\n\t\tif(c1 == 0x2b || c1 == 0x2d) {\r\n\t\t\tif(digit(c2)) return true;\r\n\t\t\tif(c2 == 0x2e && digit(c3)) return true;\r\n\t\t\treturn false;\r\n\t\t} else if(c1 == 0x2e) {\r\n\t\t\tif(digit(c2)) return true;\r\n\t\t\treturn false;\r\n\t\t} else if(digit(c1)) {\r\n\t\t\treturn true;\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n\tvar startsWithANumber = function() {\r\n\t\treturn wouldStartANumber(code, next(1), next(2));\r\n\t};\r\n\r\n\tvar consumeAName = function() {\r\n\t\tvar result = \"\";\r\n\t\twhile(consume()) {\r\n\t\t\tif(namechar(code)) {\r\n\t\t\t\tresult += stringFromCode(code);\r\n\t\t\t} else if(startsWithAValidEscape()) {\r\n\t\t\t\tresult += stringFromCode(consumeEscape());\r\n\t\t\t} else {\r\n\t\t\t\treconsume();\r\n\t\t\t\treturn result;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tvar consumeANumber = function() {\r\n\t\tvar repr = '';\r\n\t\tvar type = \"integer\";\r\n\t\tif(next() == 0x2b || next() == 0x2d) {\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t}\r\n\t\twhile(digit(next())) {\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t}\r\n\t\tif(next(1) == 0x2e && digit(next(2))) {\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t\ttype = \"number\";\r\n\t\t\twhile(digit(next())) {\r\n\t\t\t\tconsume();\r\n\t\t\t\trepr += stringFromCode(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar c1 = next(1), c2 = next(2), c3 = next(3);\r\n\t\tif((c1 == 0x45 || c1 == 0x65) && digit(c2)) {\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t\ttype = \"number\";\r\n\t\t\twhile(digit(next())) {\r\n\t\t\t\tconsume();\r\n\t\t\t\trepr += stringFromCode(code);\r\n\t\t\t}\r\n\t\t} else if((c1 == 0x45 || c1 == 0x65) && (c2 == 0x2b || c2 == 0x2d) && digit(c3)) {\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t\ttype = \"number\";\r\n\t\t\twhile(digit(next())) {\r\n\t\t\t\tconsume();\r\n\t\t\t\trepr += stringFromCode(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar value = convertAStringToANumber(repr);\r\n\t\treturn {type:type, value:value, repr:repr};\r\n\t};\r\n\r\n\tvar convertAStringToANumber = function(string) {\r\n\t\t// CSS's number rules are identical to JS, afaik.\r\n\t\treturn +string;\r\n\t};\r\n\r\n\tvar consumeTheRemnantsOfABadURL = function() {\r\n\t\twhile(consume()) {\r\n\t\t\tif(code == 0x2d || eof()) {\r\n\t\t\t\treturn;\r\n\t\t\t} else if(startsWithAValidEscape()) {\r\n\t\t\t\tconsumeEscape();\r\n\t\t\t\tdonothing();\r\n\t\t\t} else {\r\n\t\t\t\tdonothing();\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\r\n\r\n\tvar iterationCount = 0;\r\n\twhile(!eof(next())) {\r\n\t\ttokens.push(consumeAToken());\r\n\t\tif(iterationCount++ > str.length*2) throw new Error(\"The CSS Tokenizer is infinite-looping\");\r\n\t}\r\n\treturn tokens;\r\n}\r\n\r\nfunction CSSParserToken() { return this; }\r\nCSSParserToken.prototype.toJSON = function() {\r\n\treturn {token: this.tokenType};\r\n}\r\nCSSParserToken.prototype.toString = function() { return this.tokenType; }\r\nCSSParserToken.prototype.toCSSString = function() { return ''+this; }\r\n\r\nfunction BadStringToken() { return this; }\r\nBadStringToken.prototype = new CSSParserToken;\r\nBadStringToken.prototype.tokenType = \"BADSTRING\";\r\nBadStringToken.prototype.toCSSString = function() { return \"'\"; }\r\n\r\nfunction BadURLToken() { return this; }\r\nBadURLToken.prototype = new CSSParserToken;\r\nBadURLToken.prototype.tokenType = \"BADURL\";\r\nBadURLToken.prototype.toCSSString = function() { return \"url(\"; }\r\n\r\nfunction WhitespaceToken() { return this; }\r\nWhitespaceToken.prototype = new CSSParserToken;\r\nWhitespaceToken.prototype.tokenType = \"WHITESPACE\";\r\nWhitespaceToken.prototype.toString = function() { return \"WS\"; }\r\nWhitespaceToken.prototype.toCSSString = function() { return \" \"; }\r\n\r\nfunction CDOToken() { return this; }\r\nCDOToken.prototype = new CSSParserToken;\r\nCDOToken.prototype.tokenType = \"CDO\";\r\nCDOToken.prototype.toCSSString = function() { return \"<!--\"; }\r\n\r\nfunction CDCToken() { return this; }\r\nCDCToken.prototype = new CSSParserToken;\r\nCDCToken.prototype.tokenType = \"CDC\";\r\nCDCToken.prototype.toCSSString = function() { return \"-->\"; }\r\n\r\nfunction ColonToken() { return this; }\r\nColonToken.prototype = new CSSParserToken;\r\nColonToken.prototype.tokenType = \":\";\r\n\r\nfunction SemicolonToken() { return this; }\r\nSemicolonToken.prototype = new CSSParserToken;\r\nSemicolonToken.prototype.tokenType = \";\";\r\n\r\nfunction CommaToken() { return this; }\r\nCommaToken.prototype = new CSSParserToken;\r\nCommaToken.prototype.tokenType = \",\";\r\nCommaToken.prototype.value = \";\"; // backwards-compat with DELIM token\r\n\r\nfunction GroupingToken() { return this; }\r\nGroupingToken.prototype = new CSSParserToken;\r\n\r\nfunction OpenCurlyToken() { this.value = \"{\"; this.mirror = \"}\"; return this; }\r\nOpenCurlyToken.prototype = new GroupingToken;\r\nOpenCurlyToken.prototype.tokenType = \"{\";\r\n\r\nfunction CloseCurlyToken() { this.value = \"}\"; this.mirror = \"{\"; return this; }\r\nCloseCurlyToken.prototype = new GroupingToken;\r\nCloseCurlyToken.prototype.tokenType = \"}\";\r\n\r\nfunction OpenSquareToken() { this.value = \"[\"; this.mirror = \"]\"; return this; }\r\nOpenSquareToken.prototype = new GroupingToken;\r\nOpenSquareToken.prototype.tokenType = \"[\";\r\n\r\nfunction CloseSquareToken() { this.value = \"]\"; this.mirror = \"[\"; return this; }\r\nCloseSquareToken.prototype = new GroupingToken;\r\nCloseSquareToken.prototype.tokenType = \"]\";\r\n\r\nfunction OpenParenToken() { this.value = \"(\"; this.mirror = \")\"; return this; }\r\nOpenParenToken.prototype = new GroupingToken;\r\nOpenParenToken.prototype.tokenType = \"(\";\r\n\r\nfunction CloseParenToken() { this.value = \")\"; this.mirror = \"(\"; return this; }\r\nCloseParenToken.prototype = new GroupingToken;\r\nCloseParenToken.prototype.tokenType = \")\";\r\n\r\nfunction IncludeMatchToken() { return this; }\r\nIncludeMatchToken.prototype = new CSSParserToken;\r\nIncludeMatchToken.prototype.tokenType = \"~=\";\r\n\r\nfunction DashMatchToken() { return this; }\r\nDashMatchToken.prototype = new CSSParserToken;\r\nDashMatchToken.prototype.tokenType = \"|=\";\r\n\r\nfunction PrefixMatchToken() { return this; }\r\nPrefixMatchToken.prototype = new CSSParserToken;\r\nPrefixMatchToken.prototype.tokenType = \"^=\";\r\n\r\nfunction SuffixMatchToken() { return this; }\r\nSuffixMatchToken.prototype = new CSSParserToken;\r\nSuffixMatchToken.prototype.tokenType = \"$=\";\r\n\r\nfunction SubstringMatchToken() { return this; }\r\nSubstringMatchToken.prototype = new CSSParserToken;\r\nSubstringMatchToken.prototype.tokenType = \"*=\";\r\n\r\nfunction ColumnToken() { return this; }\r\nColumnToken.prototype = new CSSParserToken;\r\nColumnToken.prototype.tokenType = \"||\";\r\n\r\nfunction EOFToken() { return this; }\r\nEOFToken.prototype = new CSSParserToken;\r\nEOFToken.prototype.tokenType = \"EOF\";\r\nEOFToken.prototype.toCSSString = function() { return \"\"; }\r\n\r\nfunction DelimToken(code) {\r\n\tthis.value = stringFromCode(code);\r\n\treturn this;\r\n}\r\nDelimToken.prototype = new CSSParserToken;\r\nDelimToken.prototype.tokenType = \"DELIM\";\r\nDelimToken.prototype.toString = function() { return \"DELIM(\"+this.value+\")\"; }\r\nDelimToken.prototype.toCSSString = function() {\r\n\treturn (this.value == \"\\\\\") ? \"\\\\\\n\" : this.value;\r\n}\r\n\r\nfunction StringValuedToken() { return this; }\r\nStringValuedToken.prototype = new CSSParserToken;\r\nStringValuedToken.prototype.ASCIIMatch = function(str) {\r\n\treturn this.value.toLowerCase() == str.toLowerCase();\r\n}\r\n\r\nfunction IdentifierToken(val) {\r\n\tthis.value = val;\r\n}\r\nIdentifierToken.prototype = new StringValuedToken;\r\nIdentifierToken.prototype.tokenType = \"IDENT\";\r\nIdentifierToken.prototype.toString = function() { return \"IDENT(\"+this.value+\")\"; }\r\nIdentifierToken.prototype.toCSSString = function() {\r\n\treturn escapeIdent(this.value);\r\n}\r\n\r\nfunction FunctionToken(val) {\r\n\tthis.value = val;\r\n\tthis.mirror = \")\";\r\n}\r\nFunctionToken.prototype = new StringValuedToken;\r\nFunctionToken.prototype.tokenType = \"FUNCTION\";\r\nFunctionToken.prototype.toString = function() { return \"FUNCTION(\"+this.value+\")\"; }\r\nFunctionToken.prototype.toCSSString = function() {\r\n\treturn escapeIdent(this.value) + \"(\";\r\n}\r\n\t\r\nfunction AtKeywordToken(val) {\r\n\tthis.value = val;\r\n}\r\nAtKeywordToken.prototype = new StringValuedToken;\r\nAtKeywordToken.prototype.tokenType = \"AT-KEYWORD\";\r\nAtKeywordToken.prototype.toString = function() { return \"AT(\"+this.value+\")\"; }\r\nAtKeywordToken.prototype.toCSSString = function() {\r\n\treturn \"@\" + escapeIdent(this.value);\r\n}\r\n\r\nfunction HashToken(val) {\r\n\tthis.value = val;\r\n\tthis.type = \"unrestricted\";\r\n}\r\nHashToken.prototype = new StringValuedToken;\r\nHashToken.prototype.tokenType = \"HASH\";\r\nHashToken.prototype.toString = function() { return \"HASH(\"+this.value+\")\"; }\r\nHashToken.prototype.toCSSString = function() {\r\n\tvar escapeValue = (this.type == \"id\") ? escapeIdent : escapeHash;\r\n\treturn \"#\" + escapeValue(this.value);\r\n}\r\n\r\nfunction StringToken(val) {\r\nthis.value = val;\r\n}\r\nStringToken.prototype = new StringValuedToken;\r\nStringToken.prototype.tokenType = \"STRING\";\r\nStringToken.prototype.toString = function() {\r\n\treturn '\"' + escapeString(this.value) + '\"';\r\n}\r\n\r\nfunction URLToken(val) {\r\n\tthis.value = val;\r\n}\r\nURLToken.prototype = new StringValuedToken;\r\nURLToken.prototype.tokenType = \"URL\";\r\nURLToken.prototype.toString = function() { return \"URL(\"+this.value+\")\"; }\r\nURLToken.prototype.toCSSString = function() {\r\n\treturn 'url(\"' + escapeString(this.value) + '\")';\r\n}\r\n\r\nfunction NumberToken() {\r\n\tthis.value = null;\r\n\tthis.type = \"integer\";\r\n\tthis.repr = \"\";\r\n}\r\nNumberToken.prototype = new CSSParserToken;\r\nNumberToken.prototype.tokenType = \"NUMBER\";\r\nNumberToken.prototype.toString = function() {\r\n\tif(this.type == \"integer\")\r\n\t\treturn \"INT(\"+this.value+\")\";\r\n\treturn \"NUMBER(\"+this.value+\")\";\r\n}\r\nNumberToken.prototype.toJSON = function() {\r\n\tvar json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\r\n\tjson.value = this.value;\r\n\tjson.type = this.type;\r\n\tjson.repr = this.repr;\r\n\treturn json;\r\n}\r\nNumberToken.prototype.toCSSString = function() { return this.repr; };\r\n\r\nfunction PercentageToken() {\r\n\tthis.value = null;\r\n\tthis.repr = \"\";\r\n}\r\nPercentageToken.prototype = new CSSParserToken;\r\nPercentageToken.prototype.tokenType = \"PERCENTAGE\";\r\nPercentageToken.prototype.toString = function() { return \"PERCENTAGE(\"+this.value+\")\"; }\r\nPercentageToken.prototype.toCSSString = function() { return this.repr + \"%\"; }\r\n\r\nfunction DimensionToken() {\r\n\tthis.value = null;\r\n\tthis.type = \"integer\";\r\n\tthis.repr = \"\";\r\n\tthis.unit = \"\";\r\n}\r\nDimensionToken.prototype = new CSSParserToken;\r\nDimensionToken.prototype.tokenType = \"DIMENSION\";\r\nDimensionToken.prototype.toString = function() { return \"DIM(\"+this.value+\",\"+this.unit+\")\"; }\r\nDimensionToken.prototype.toCSSString = function() {\r\n\tvar source = this.repr;\r\n\tvar unit = escapeIdent(this.unit);\r\n\tif(unit[0].toLowerCase() == \"e\" && (unit[1] == \"-\" || between(unit.charCodeAt(1), 0x30, 0x39))) {\r\n\t\t// Unit is ambiguous with scinot\r\n\t\t// Remove the leading \"e\", replace with escape.\r\n\t\tunit = \"\\\\65 \" + unit.slice(1, unit.length);\r\n\t}\r\n\treturn source+unit;\r\n}\r\n\r\nfunction escapeIdent(string) {\r\n\tstring = ''+string;\r\n\tvar result = '';\r\n\tvar firstcode = string.charCodeAt(0);\r\n\tfor(var i = 0; i < string.length; i++) {\r\n\t\tvar code = string.charCodeAt(i);\r\n\t\tif(code == 0x0) {\r\n\t\t\tthrow new InvalidCharacterError('Invalid character: the input contains U+0000.');\r\n\t\t}\r\n\r\n\t\tif(\r\n\t\t\tbetween(code, 0x1, 0x1f) || code == 0x7f ||\r\n\t\t\t(i == 0 && between(code, 0x30, 0x39)) ||\r\n\t\t\t(i == 1 && between(code, 0x30, 0x39) && firstcode == 0x2d)\r\n\t\t) {\r\n\t\t\tresult += '\\\\' + code.toString(16) + ' ';\r\n\t\t} else if(\r\n\t\t\tcode >= 0x80 ||\r\n\t\t\tcode == 0x2d ||\r\n\t\t\tcode == 0x5f ||\r\n\t\t\tbetween(code, 0x30, 0x39) ||\r\n\t\t\tbetween(code, 0x41, 0x5a) ||\r\n\t\t\tbetween(code, 0x61, 0x7a)\r\n\t\t) {\r\n\t\t\tresult += string[i];\r\n\t\t} else {\r\n\t\t\tresult += '\\\\' + string[i];\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nfunction escapeHash(string) {\r\n\t// Escapes the contents of \"unrestricted\"-type hash tokens.\r\n\t// Won't preserve the ID-ness of \"id\"-type hash tokens;\r\n\t// use escapeIdent() for that.\r\n\tstring = ''+string;\r\n\tvar result = '';\r\n\tvar firstcode = string.charCodeAt(0);\r\n\tfor(var i = 0; i < string.length; i++) {\r\n\t\tvar code = string.charCodeAt(i);\r\n\t\tif(code == 0x0) {\r\n\t\t\tthrow new InvalidCharacterError('Invalid character: the input contains U+0000.');\r\n\t\t}\r\n\r\n\t\tif(\r\n\t\t\tcode >= 0x80 ||\r\n\t\t\tcode == 0x2d ||\r\n\t\t\tcode == 0x5f ||\r\n\t\t\tbetween(code, 0x30, 0x39) ||\r\n\t\t\tbetween(code, 0x41, 0x5a) ||\r\n\t\t\tbetween(code, 0x61, 0x7a)\r\n\t\t) {\r\n\t\t\tresult += string[i];\r\n\t\t} else {\r\n\t\t\tresult += '\\\\' + code.toString(16) + ' ';\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nfunction escapeString(string) {\r\n\tstring = ''+string;\r\n\tvar result = '';\r\n\tfor(var i = 0; i < string.length; i++) {\r\n\t\tvar code = string.charCodeAt(i);\r\n\r\n\t\tif(code == 0x0) {\r\n\t\t\tthrow new InvalidCharacterError('Invalid character: the input contains U+0000.');\r\n\t\t}\r\n\r\n\t\tif(between(code, 0x1, 0x1f) || code == 0x7f) {\r\n\t\t\tresult += '\\\\' + code.toString(16) + ' ';\r\n\t\t} else if(code == 0x22 || code == 0x5c) {\r\n\t\t\tresult += '\\\\' + string[i];\r\n\t\t} else {\r\n\t\t\tresult += string[i];\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n// Exportation.\r\ncssSyntax.tokenize = tokenize;\r\ncssSyntax.IdentToken = IdentifierToken;\r\ncssSyntax.IdentifierToken = IdentifierToken;\r\ncssSyntax.FunctionToken = FunctionToken;\r\ncssSyntax.AtKeywordToken = AtKeywordToken;\r\ncssSyntax.HashToken = HashToken;\r\ncssSyntax.StringToken = StringToken;\r\ncssSyntax.BadStringToken = BadStringToken;\r\ncssSyntax.URLToken = URLToken;\r\ncssSyntax.BadURLToken = BadURLToken;\r\ncssSyntax.DelimToken = DelimToken;\r\ncssSyntax.NumberToken = NumberToken;\r\ncssSyntax.PercentageToken = PercentageToken;\r\ncssSyntax.DimensionToken = DimensionToken;\r\ncssSyntax.IncludeMatchToken = IncludeMatchToken;\r\ncssSyntax.DashMatchToken = DashMatchToken;\r\ncssSyntax.PrefixMatchToken = PrefixMatchToken;\r\ncssSyntax.SuffixMatchToken = SuffixMatchToken;\r\ncssSyntax.SubstringMatchToken = SubstringMatchToken;\r\ncssSyntax.ColumnToken = ColumnToken;\r\ncssSyntax.WhitespaceToken = WhitespaceToken;\r\ncssSyntax.CDOToken = CDOToken;\r\ncssSyntax.CDCToken = CDCToken;\r\ncssSyntax.ColonToken = ColonToken;\r\ncssSyntax.SemicolonToken = SemicolonToken;\r\ncssSyntax.CommaToken = CommaToken;\r\ncssSyntax.OpenParenToken = OpenParenToken;\r\ncssSyntax.CloseParenToken = CloseParenToken;\r\ncssSyntax.OpenSquareToken = OpenSquareToken;\r\ncssSyntax.CloseSquareToken = CloseSquareToken;\r\ncssSyntax.OpenCurlyToken = OpenCurlyToken;\r\ncssSyntax.CloseCurlyToken = CloseCurlyToken;\r\ncssSyntax.EOFToken = EOFToken;\r\ncssSyntax.CSSParserToken = CSSParserToken;\r\ncssSyntax.GroupingToken = GroupingToken;\r\n\r\n//\r\n// css parser\r\n//\r\n\r\nfunction TokenStream(tokens) {\r\n\t// Assume that tokens is an array.\r\n\tthis.tokens = tokens;\r\n\tthis.i = -1;\r\n}\r\nTokenStream.prototype.tokenAt = function(i) {\r\n\tif(i < this.tokens.length)\r\n\t\treturn this.tokens[i];\r\n\treturn new EOFToken();\r\n}\r\nTokenStream.prototype.consume = function(num) {\r\n\tif(num === undefined) num = 1;\r\n\tthis.i += num;\r\n\tthis.token = this.tokenAt(this.i);\r\n\t//console.log(this.i, this.token);\r\n\treturn true;\r\n}\r\nTokenStream.prototype.next = function() {\r\n\treturn this.tokenAt(this.i+1);\r\n}\r\nTokenStream.prototype.reconsume = function() {\r\n\tthis.i--;\r\n}\r\n\r\nfunction parseerror(s, msg) {\r\n\tconsole.log(\"Parse error at token \" + s.i + \": \" + s.token + \".\\n\" + msg);\r\n\treturn true;\r\n}\r\nfunction donothing(){ return true; };\r\n\r\nfunction consumeAListOfRules(s, topLevel) {\r\n\tvar rules = new TokenList();\r\n\tvar rule;\r\n\twhile(s.consume()) {\r\n\t\tif(s.token instanceof WhitespaceToken) {\r\n\t\t\tcontinue;\r\n\t\t} else if(s.token instanceof EOFToken) {\r\n\t\t\treturn rules;\r\n\t\t} else if(s.token instanceof CDOToken || s.token instanceof CDCToken) {\r\n\t\t\tif(topLevel == \"top-level\") continue;\r\n\t\t\ts.reconsume();\r\n\t\t\tif(rule = consumeAStyleRule(s)) rules.push(rule);\r\n\t\t} else if(s.token instanceof AtKeywordToken) {\r\n\t\t\ts.reconsume();\r\n\t\t\tif(rule = consumeAnAtRule(s)) rules.push(rule);\r\n\t\t} else {\r\n\t\t\ts.reconsume();\r\n\t\t\tif(rule = consumeAStyleRule(s)) rules.push(rule);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction consumeAnAtRule(s) {\r\n\ts.consume();\r\n\tvar rule = new AtRule(s.token.value);\r\n\twhile(s.consume()) {\r\n\t\tif(s.token instanceof SemicolonToken || s.token instanceof EOFToken) {\r\n\t\t\treturn rule;\r\n\t\t} else if(s.token instanceof OpenCurlyToken) {\r\n\t\t\trule.value = consumeASimpleBlock(s);\r\n\t\t\treturn rule;\r\n\t\t} else if(s.token instanceof SimpleBlock && s.token.name == \"{\") {\r\n\t\t\trule.value = s.token;\r\n\t\t\treturn rule;\r\n\t\t} else {\r\n\t\t\ts.reconsume();\r\n\t\t\trule.prelude.push(consumeAComponentValue(s));\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction consumeAStyleRule(s) {\r\n\tvar rule = new StyleRule();\r\n\twhile(s.consume()) {\r\n\t\tif(s.token instanceof EOFToken) {\r\n\t\t\tparseerror(s, \"Hit EOF when trying to parse the prelude of a qualified rule.\");\r\n\t\t\treturn;\r\n\t\t} else if(s.token instanceof OpenCurlyToken) {\r\n\t\t\trule.value = consumeASimpleBlock(s);\r\n\t\t\treturn rule;\r\n\t\t} else if(s.token instanceof SimpleBlock && s.token.name == \"{\") {\r\n\t\t\trule.value = s.token;\r\n\t\t\treturn rule;\r\n\t\t} else {\r\n\t\t\ts.reconsume();\r\n\t\t\trule.prelude.push(consumeAComponentValue(s));\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction consumeAListOfDeclarations(s) {\r\n\tvar decls = new TokenList();\r\n\twhile(s.consume()) {\r\n\t\tif(s.token instanceof WhitespaceToken || s.token instanceof SemicolonToken) {\r\n\t\t\tdonothing();\r\n\t\t} else if(s.token instanceof EOFToken) {\r\n\t\t\treturn decls;\r\n\t\t} else if(s.token instanceof AtKeywordToken) {\r\n\t\t\ts.reconsume();\r\n\t\t\tdecls.push(consumeAnAtRule(s));\r\n\t\t} else if(s.token instanceof IdentifierToken) {\r\n\t\t\tvar temp = [s.token];\r\n\t\t\twhile(!(s.next() instanceof SemicolonToken || s.next() instanceof EOFToken))\r\n\t\t\t\ttemp.push(consumeAComponentValue(s));\r\n\t\t\tvar decl;\r\n\t\t\tif(decl = consumeADeclaration(new TokenStream(temp))) decls.push(decl);\r\n\t\t} else {\r\n\t\t\tparseerror(s);\r\n\t\t\ts.reconsume();\r\n\t\t\twhile(!(s.next() instanceof SemicolonToken || s.next() instanceof EOFToken))\r\n\t\t\t\tconsumeAComponentValue(s);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction consumeADeclaration(s) {\r\n\t// Assumes that the next input token will be an ident token.\r\n\ts.consume();\r\n\tvar decl = new Declaration(s.token.value);\r\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\r\n\tif(!(s.next() instanceof ColonToken)) {\r\n\t\tparseerror(s);\r\n\t\treturn;\r\n\t} else {\r\n\t\ts.consume();\r\n\t}\r\n\twhile(!(s.next() instanceof EOFToken)) {\r\n\t\tdecl.value.push(consumeAComponentValue(s));\r\n\t}\r\n\tvar foundImportant = false;\r\n\tfor(var i = decl.value.length - 1; i >= 0; i--) {\r\n\t\tif(decl.value[i] instanceof WhitespaceToken) {\r\n\t\t\tcontinue;\r\n\t\t} else if(decl.value[i] instanceof IdentifierToken && decl.value[i].ASCIIMatch(\"important\")) {\r\n\t\t\tfoundImportant = true;\r\n\t\t} else if(foundImportant && decl.value[i] instanceof DelimToken && decl.value[i].value == \"!\") {\r\n\t\t\tdecl.value.splice(i, decl.value.length);\r\n\t\t\tdecl.important = true;\r\n\t\t\tbreak;\r\n\t\t} else {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn decl;\r\n}\r\n\r\nfunction consumeAComponentValue(s) {\r\n\ts.consume();\r\n\tif(s.token instanceof OpenCurlyToken || s.token instanceof OpenSquareToken || s.token instanceof OpenParenToken)\r\n\t\treturn consumeASimpleBlock(s);\r\n\tif(s.token instanceof FunctionToken)\r\n\t\treturn consumeAFunction(s);\r\n\treturn s.token;\r\n}\r\n\r\nfunction consumeASimpleBlock(s) {\r\n\tvar mirror = s.token.mirror;\r\n\tvar block = new SimpleBlock(s.token.value);\r\n\twhile(s.consume()) {\r\n\t\tif(s.token instanceof EOFToken || (s.token instanceof GroupingToken && s.token.value == mirror))\r\n\t\t\treturn block;\r\n\t\telse {\r\n\t\t\ts.reconsume();\r\n\t\t\tblock.value.push(consumeAComponentValue(s));\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction consumeAFunction(s) {\r\n\tvar func = new Func(s.token.value);\r\n\twhile(s.consume()) {\r\n\t\tif(s.token instanceof EOFToken || s.token instanceof CloseParenToken)\r\n\t\t\treturn func;\r\n\t\telse {\r\n\t\t\ts.reconsume();\r\n\t\t\tfunc.value.push(consumeAComponentValue(s));\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction normalizeInput(input) {\r\n\tif(typeof input == \"string\")\r\n\t\treturn new TokenStream(tokenize(input));\r\n\tif(input instanceof TokenStream)\r\n\t\treturn input;\r\n\tif(input.length !== undefined)\r\n\t\treturn new TokenStream(input);\r\n\telse throw SyntaxError(input);\r\n}\r\n\r\nfunction parseAStylesheet(s) {\r\n\ts = normalizeInput(s);\r\n\tvar sheet = new Stylesheet();\r\n\tsheet.value = consumeAListOfRules(s, \"top-level\");\r\n\treturn sheet;\r\n}\r\n\r\nfunction parseAListOfRules(s) {\r\n\ts = normalizeInput(s);\r\n\treturn consumeAListOfRules(s);\r\n}\r\n\r\nfunction parseARule(s) {\r\n\ts = normalizeInput(s);\r\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\r\n\tif(s.next() instanceof EOFToken) throw SyntaxError();\r\n\tif(s.next() instanceof AtKeywordToken) {\r\n\t\tvar rule = consumeAnAtRule(s);\r\n\t} else {\r\n\t\tvar rule = consumeAStyleRule(s);\r\n\t\tif(!rule) throw SyntaxError();\r\n\t}\r\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\r\n\tif(s.next() instanceof EOFToken)\r\n\t\treturn rule;\r\n\tthrow SyntaxError();\r\n}\r\n\r\nfunction parseADeclaration(s) {\r\n\ts = normalizeInput(s);\r\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\r\n\tif(!(s.next() instanceof IdentifierToken)) throw SyntaxError();\r\n\tvar decl = consumeADeclaration(s);\r\n\tif(!decl) { throw new SyntaxError() }\r\n\treturn decl;\r\n}\r\n\r\nfunction parseAListOfDeclarations(s) {\r\n\ts = normalizeInput(s);\r\n\treturn consumeAListOfDeclarations(s);\r\n}\r\n\r\nfunction parseAComponentValue(s) {\r\n\ts = normalizeInput(s);\r\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\r\n\tif(s.next() instanceof EOFToken) throw SyntaxError();\r\n\tvar val = consumeAComponentValue(s);\r\n\tif(!val) throw SyntaxError();\r\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\r\n\tif(!(s.next() instanceof EOFToken)) throw new SyntaxError();\r\n\treturn val;\r\n}\r\n\r\nfunction parseAListOfComponentValues(s) {\r\n\ts = normalizeInput(s);\r\n\tvar vals = new TokenList();\r\n\twhile(true) {\r\n\t\tvar val = consumeAComponentValue(s);\r\n\t\tif(val instanceof EOFToken)\r\n\t\t\treturn vals\r\n\t\telse\r\n\t\t\tvals.push(val);\r\n\t}\r\n}\r\n\r\nfunction parseACommaSeparatedListOfComponentValues(s) {\r\n\ts = normalizeInput(s);\r\n\tvar listOfCVLs = new TokenList();\r\n\twhile(true) {\r\n\t\tvar vals = new TokenList();\r\n\t\twhile(true) {\r\n\t\t\tvar val = consumeAComponentValue(s);\r\n\t\t\tif(val instanceof EOFToken) {\r\n\t\t\t\tlistOfCVLs.push(vals);\r\n\t\t\t\treturn listOfCVLs;\r\n\t\t\t} else if(val instanceof CommaToken) {\r\n\t\t\t\tlistOfCVLs.push(vals);\r\n\t\t\t\tbreak;\r\n\t\t\t} else {\r\n\t\t\t\tvals.push(val);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction CSSParserRule() { return this; }\r\nCSSParserRule.prototype.toString = function(indent) {\r\n\treturn JSON.stringify(this,null,indent);\r\n}\r\n\r\nfunction Stylesheet() {\r\n\tthis.value = new TokenList();\r\n\treturn this;\r\n}\r\nStylesheet.prototype = new CSSParserRule;\r\nStylesheet.prototype.type = \"STYLESHEET\";\r\nStylesheet.prototype.toCSSString = function() { return this.value.toCSSString(\"\\n\"); }\r\n\r\nfunction AtRule(name) {\r\n\tthis.name = name;\r\n\tthis.prelude = new TokenList();\r\n\tthis.value = null;\r\n\treturn this;\r\n}\r\nAtRule.prototype = new CSSParserRule;\r\nAtRule.prototype.toCSSString = function() { \r\n\tif(this.value) {\r\n\t\treturn \"@\" + escapeIdent(this.name) + \" \" + this.prelude.toCSSString() + this.value.toCSSString(); \r\n\t} else {\r\n\t\treturn \"@\" + escapeIdent(this.name) + \" \" + this.prelude.toCSSString() + '; '; \r\n\t}\r\n}\r\nAtRule.prototype.toStylesheet = function() {\r\n\treturn this.asStylesheet || (this.asStylesheet = this.value ? parseAStylesheet(this.value.value) : new Stylesheet());\r\n}\r\n\r\nfunction StyleRule() {\r\n\tthis.prelude = new TokenList(); this.selector = this.prelude;\r\n\tthis.value = null;\r\n\treturn this;\r\n}\r\nStyleRule.prototype = new CSSParserRule;\r\nStyleRule.prototype.type = \"STYLE-RULE\";\r\nStyleRule.prototype.toCSSString = function() {\r\n\treturn this.prelude.toCSSString() + this.value.toCSSString();\r\n}\r\nStyleRule.prototype.getSelector = function() {\r\n\treturn this.prelude;\r\n}\r\nStyleRule.prototype.getDeclarations = function() {\r\n\tif(!(this.value instanceof SimpleBlock)) { return new TokenList(); }\r\n\tvar value = this.value.value; return parseAListOfDeclarations(value);\r\n}\r\n\r\n\r\nfunction Declaration(name) {\r\n\tthis.name = name;\r\n\tthis.value = new TokenList();\r\n\tthis.important = false;\r\n\treturn this;\r\n}\r\nDeclaration.prototype = new CSSParserRule;\r\nDeclaration.prototype.type = \"DECLARATION\";\r\nDeclaration.prototype.toCSSString = function() {\r\n\treturn this.name + ':' + this.value.toCSSString() + '; ';\r\n}\r\n\r\nfunction SimpleBlock(type) {\r\n\tthis.name = type;\r\n\tthis.value = new TokenList();\r\n\treturn this;\r\n}\r\nSimpleBlock.prototype = new CSSParserRule;\r\nSimpleBlock.prototype.type = \"BLOCK\";\r\nSimpleBlock.prototype.toCSSString = function() {\r\n\tswitch(this.name) {\r\n\t\tcase \"(\":\r\n\t\t\treturn \"(\" + this.value.toCSSString() + \")\";\r\n\t\t\t\r\n\t\tcase \"[\":\r\n\t\t\treturn \"[\" + this.value.toCSSString() + \"]\";\r\n\t\t\t\r\n\t\tcase \"{\":\r\n\t\t\treturn \"{\" + this.value.toCSSString() + \"}\";\r\n\t\t\r\n\t\tdefault: //best guess\r\n\t\t\treturn this.name + this.value.toCSSString() + this.name;\r\n\t}\r\n}\r\n\r\nfunction Func(name) {\r\n\tthis.name = name;\r\n\tthis.value = new TokenList();\r\n\treturn this;\r\n}\r\nFunc.prototype = new CSSParserRule;\r\nFunc.prototype.type = \"FUNCTION\";\r\nFunc.prototype.toCSSString = function() {\r\n\treturn this.name+'('+this.value.toCSSString()+')';\r\n}\r\nFunc.prototype.getArguments = function() {\r\n\tvar args = new TokenList(); var arg = new TokenList(); var value = this.value;\r\n\tfor(var i = 0; i<value.length; i++) {\r\n\t\tif(value[i].tokenType == ',') {\r\n\t\t\targs.push(arg); arg = new TokenList();\r\n\t\t} else {\r\n\t\t\targ.push(value[i])\r\n\t\t}\r\n\t}\r\n\tif(args.length > 0 || arg.length > 0) { args.push(arg); }\r\n\treturn args;\r\n}\r\n\r\nfunction FuncArg() {\r\n\tthis.value = new TokenList();\r\n\treturn this;\r\n}\r\nFuncArg.prototype = new CSSParserRule;\r\nFuncArg.prototype.type = \"FUNCTION-ARG\";\r\nFuncArg.prototype.toCSSString = function() {\r\n\treturn this.value.toCSSString()+', ';\r\n}\r\n\r\n// Exportation.\r\ncssSyntax.CSSParserRule = CSSParserRule;\r\ncssSyntax.Stylesheet = Stylesheet;\r\ncssSyntax.AtRule = AtRule;\r\ncssSyntax.StyleRule = StyleRule;\r\ncssSyntax.Declaration = Declaration;\r\ncssSyntax.SimpleBlock = SimpleBlock;\r\ncssSyntax.Func = Func;\r\ncssSyntax.parseAStylesheet = parseAStylesheet;\r\ncssSyntax.parseAListOfRules = parseAListOfRules;\r\ncssSyntax.parseARule = parseARule;\r\ncssSyntax.parseADeclaration = parseADeclaration;\r\ncssSyntax.parseAListOfDeclarations = parseAListOfDeclarations;\r\ncssSyntax.parseAComponentValue = parseAComponentValue;\r\ncssSyntax.parseAListOfComponentValues = parseAListOfComponentValues;\r\ncssSyntax.parseACommaSeparatedListOfComponentValues = parseACommaSeparatedListOfComponentValues;\r\ncssSyntax.parse = parseAStylesheet;\r\ncssSyntax.parseCSSValue = parseAListOfComponentValues;\r\n\r\nreturn cssSyntax;\r\n\r\n}());\nrequire.define('src/core/css-syntax.js');","module.exports = (function() {\r\n\t\r\n\tvar infinity = 9999999.0;\r\n\r\n\t// define the module\r\n\tvar cssSizing = {\r\n\t\t\r\n\t\tminWidthOf: function*(element) {\r\n\t\t\r\n\t\t\t//\r\n\t\t\t// make the parent an infinite relative container (if necessary)\r\n\t\t\t//\r\n\t\t\tvar fragment = yield element.layoutNextFragment({ });\r\n\r\n\t\t\t//\r\n\t\t\t// return the result\r\n\t\t\t//\r\n\t\t\treturn fragment.inlineSize;\r\n\r\n\t\t},\r\n\t\t\r\n\t\tmaxWidthOf: function*(element) {\r\n\r\n\t\t\treturn yield* this.minWidthOf(element); // TODO: remove this when Ian fixes Blink\r\n\t\t\r\n\t\t\t//\r\n\t\t\t// make the parent a relative container (if necessary)\r\n\t\t\t//\r\n\t\t\tvar fragment = yield element.layoutNextFragment({ availableInlineSize: infinity });\r\n\r\n\t\t\t//\r\n\t\t\t// return the result\r\n\t\t\t//\r\n\t\t\treturn fragment.inlineSize;\r\n\t\t},\r\n\r\n\t};\r\n\t\r\n\treturn cssSizing;\r\n\t\r\n})();\nrequire.define('src/core/css-sizing.js');","//\r\n// The Box module defines algorithms for dealing with css boxes\r\n//\r\nmodule.exports = (function() {\r\n\t\r\n\t// Original code licensed by Adobe Systems Incorporated under the Apache License 2.0. \r\n\t// https://github.com/adobe-webplatform/brackets-css-shapes-editor/blob/master/thirdparty/CSSShapesEditor.js#L442\r\n\r\n\tvar cssBox = cssBox || {};\r\n\tcssBox.getBox = \r\n\t\t\r\n\t\t// returns {top/left/bottom/right} for 'content/padding/border/margin-box' relative to the border box top-left corner.\r\n\t\tfunction getBox(element, boxType){\r\n\t\t\tvar width = element.offsetWidth,\r\n\t\t\t\theight = element.offsetHeight,\r\n\r\n\t\t\t\tstyle = getComputedStyle(element),\r\n\r\n\t\t\t\tleftBorder = parseFloat(style.borderLeftWidth),\r\n\t\t\t\trightBorder = parseFloat(style.borderRightWidth),\r\n\t\t\t\ttopBorder = parseFloat(style.borderTopWidth),\r\n\t\t\t\tbottomBorder = parseFloat(style.borderBottomWidth),\r\n\r\n\t\t\t\tleftPadding = parseFloat(style.paddingLeft),\r\n\t\t\t\trightPadding = parseFloat(style.paddingRight),\r\n\t\t\t\ttopPadding = parseFloat(style.paddingTop),\r\n\t\t\t\tbottomPadding = parseFloat(style.paddingBottom),\r\n\r\n\t\t\t\tleftMargin = parseFloat(style.marginLeft),\r\n\t\t\t\trightMargin = parseFloat(style.marginRight),\r\n\t\t\t\ttopMargin = parseFloat(style.marginTop),\r\n\t\t\t\tbottomMargin = parseFloat(style.marginBottom);\r\n\r\n\t\t\tvar box = {\r\n\t\t\t\ttop: 0,\r\n\t\t\t\tleft: 0,\r\n\t\t\t\twidth: 0,\r\n\t\t\t\theight: 0\r\n\t\t\t};\r\n\r\n\t\t\tswitch (boxType||'border-box'){\r\n\t\t\tcase 'content-box':\r\n\t\t\t\tbox.top = topBorder + topPadding;\r\n\t\t\t\tbox.left = leftBorder + leftPadding;\r\n\t\t\t\tbox.width = width - leftBorder - leftPadding - rightPadding - rightBorder;\r\n\t\t\t\tbox.height = height - topBorder - topPadding - bottomPadding - bottomBorder;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'padding-box':\r\n\t\t\t\tbox.top = topPadding;\r\n\t\t\t\tbox.left = leftPadding;\r\n\t\t\t\tbox.width = width - leftBorder - rightBorder;\r\n\t\t\t\tbox.height = height - topBorder - bottomBorder;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'border-box':\r\n\t\t\t\tbox.top = 0;\r\n\t\t\t\tbox.left = 0;\r\n\t\t\t\tbox.width = width;\r\n\t\t\t\tbox.height = height;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'margin-box':\r\n\t\t\t\tbox.top = 0 - topMargin;\r\n\t\t\t\tbox.left = 0 - leftMargin;\r\n\t\t\t\tbox.width = width + leftMargin + rightMargin;\r\n\t\t\t\tbox.height = height + topMargin + bottomMargin;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new TypeError('Invalid parameter, boxType: ' + boxType);\r\n\t\t\t}\r\n\r\n\t\t\treturn box;\r\n\t\t};\r\n\t\r\n\treturn cssBox;\r\n\t\r\n})();\nrequire.define('src/core/css-box.js');","//\r\n// The CSS Units module is handling conversions between units\r\n//\r\nmodule.exports = (function() {\r\n\t\r\n\t// import dependencies\r\n\tvar getBox = require('src/core/css-box.js').getBox;\r\n\t\r\n\t// define the module\r\n\tvar cssUnits = {\r\n\t\t\r\n\t\t// converts \"cssLength\" from its inherent unit to pixels, and returns the result as a float\r\n\t\tconvertToPixels: function convertToPixels(cssLength, element, opts) {\r\n\t\t\t\r\n\t\t\tif(typeof cssLength == \"string\") {\r\n\t\t\t\r\n\t\t\t\tvar match = cssLength.match(/^\\s*(-?\\d+(?:\\.\\d+)?)(\\S*)\\s*$/);\r\n\t\t\t\tvar currentLength = match ? parseFloat(match[1]) : 0.0;\r\n\t\t\t\tvar currentUnit = match ? match[2] : '';\r\n\t\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\tvar currentLength = cssLength.value;\r\n\t\t\t\tvar currentUnit = cssLength.unit;\r\n\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\t\tvar converter = convertToPixels.converters[currentUnit];\r\n\t\t\tif (!converter) throw new Error(\"No suitable conversion from unit '\"+currentUnit+\"' to unit 'px'\");\r\n\t\t\t\r\n\t\t\tvar convertedLength = converter.call(null, currentLength, element||document.documentElement, opts)\r\n\t\t\treturn Math.round(20*convertedLength)/20;\r\n\t\t\t\r\n\t\t},\r\n\r\n\t\t// converts \"pixelLength\" from pixels to \"destinUnit\", and returns the result as a float\r\n\t\tconvertFromPixels: function convertFromPixels(pixelLength, destinUnit, element, opts) {\r\n\r\n\t\t\tvar converter = convertFromPixels.converters[destinUnit];\r\n\t\t\tif (!converter) throw new Error(\"No suitable conversion to unit '\"+destinUnit+\"' from unit 'px'\");\r\n\r\n\t\t\tvar convertedLength = converter.call(null, pixelLength, element||document.documentElement, opts)\r\n\t\t\treturn Math.round(20*convertedLength)/20;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t}\r\n\t\r\n\tcssUnits.convertToPixels.converters = {\r\n\t\t'px' : function(x) { return x; },\r\n\t\t'in' : function(x) { return x * 96; },\r\n\t\t'cm' : function(x) { return x / 0.02645833333; },\r\n\t\t'mm' : function(x) { return x / 0.26458333333; },\r\n\t\t'pt' : function(x) { return x / 0.75; },\r\n\t\t'pc' : function(x) { return x / 0.0625; },\r\n\t\t'em' : function(x, e) { return x*parseFloat(e?getComputedStyle(e).fontSize:16); },\r\n\t\t'rem': function(x, e) { return x*parseFloat(e?getComputedStyle(e.ownerDocument.documentElement).fontSize:16); },\r\n\t\t'vw' : function(x, e) { return x/100*window.innerWidth; },\r\n\t\t'vh' : function(x, e) { return x/100*window.innerHeight; },\r\n\t\t'%'  : function(x, e, opts) {\r\n\t\t\topts = opts || {};\r\n\r\n\t\t\t// get the box from which to compute the percentages\r\n\t\t\tvar box = e ? cssUtils.getBox(e, opts.boxType) : {\r\n\t\t\t\ttop: 0,\r\n\t\t\t\tleft: 0,\r\n\t\t\t\twidth: 0,\r\n\t\t\t\theight: 0\r\n\t\t\t};\r\n\r\n\t\t\t// now apply the conversion algorithm\r\n\t\t\tswitch(true) {\r\n\t\t\t\tcase opts.isRadius:\r\n\t\t\t\t\tvar radius = Math.sqrt( box.height*box.height + box.width*box.width ) / Math.sqrt(2);\r\n\t\t\t\t\treturn Math.round(x/100*radius);\r\n\t\t\t\t\t\r\n\t\t\t\tcase opts.isHeightRelated:\r\n\t\t\t\t\treturn x/100*box.height;\r\n\t\t\t\t\t\r\n\t\t\t\tcase opts.isWidthRelated: default:\r\n\t\t\t\t\treturn x/100*box.width;\r\n\t\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tcssUnits.convertFromPixels.converters = {\r\n\t\t'px' : function(x) { return x; },\r\n\t\t'in' : function(x) { return x / 96; },\r\n\t\t'cm' : function(x) { return x * 0.02645833333; },\r\n\t\t'mm' : function(x) { return x * 0.26458333333; },\r\n\t\t'pt' : function(x) { return x * 0.75; },\r\n\t\t'pc' : function(x) { return x * 0.0625; },\r\n\t\t'em' : function(x, e) { return x/parseFloat(e?getComputedStyle(e).fontSize:16); },\r\n\t\t'rem': function(x, e) { return x/parseFloat(e?getComputedStyle(e.ownerDocument.documentElement).fontSize:16); },\r\n\t\t'vw' : function(x, e) { return x*100/window.innerWidth; },\r\n\t\t'vh' : function(x, e) { return x*100/window.innerHeight; },\r\n\t\t'%'  : function(x, e, opts) {\r\n\t\t\topts = opts || {};\r\n\r\n\t\t\t// get the box from which to compute the percentages\r\n\t\t\tvar box = e ? cssUtils.getBox(e, opts.boxType) : {\r\n\t\t\t\ttop: 0,\r\n\t\t\t\tleft: 0,\r\n\t\t\t\twidth: 0,\r\n\t\t\t\theight: 0\r\n\t\t\t};\r\n\r\n\t\t\t// now apply the conversion algorithm\r\n\t\t\tswitch(true) {\r\n\t\t\t\tcase opts.isRadius:\r\n\t\t\t\t\tvar radius = Math.sqrt( box.height*box.height + box.width*box.width ) / Math.sqrt(2);\r\n\t\t\t\t\treturn Math.round(x*100/radius);\r\n\t\t\t\t\t\r\n\t\t\t\tcase opts.isHeightRelated:\r\n\t\t\t\t\treturn x*100/box.height;\r\n\t\t\t\t\t\r\n\t\t\t\tcase opts.isWidthRelated: default:\r\n\t\t\t\t\treturn x*100/box.width;\r\n\t\t\t\t\t\r\n\t\t\t}\r\n\r\n\r\n\t\t}\r\n\t};\r\n\t\r\n\treturn cssUnits;\r\n\r\n})();\nrequire.define('src/core/css-units.js');","module.exports = (function() { \"use strict\";\r\n\t\r\n\t// import dependencies\r\n\tvar cssSyntax = require('src/core/css-syntax.js');\r\n\t\r\n\tvar cssSizing = require('src/core/css-sizing.js');\r\n\t\r\n\tvar cssUnits = require('src/core/css-units.js');\r\n\r\n\tStylePropertyMapReadOnly.prototype.getPropertyValue=function(propertyName) {\r\n\t\tvar value = this.get(propertyName);\r\n\t\tif(value === null) return \"\"\r\n\t\treturn value.toString();\r\n\t}\r\n\t\r\n\t// define the module\r\n\tvar LOCATE_AUTO = 0;\r\n\tvar LOCATE_LINE = 1;\r\n\tvar LOCATE_SPAN = 2;\r\n\tvar LOCATE_AREA = 3;\r\n\tvar LOCATE_SUBGRID = 4;\r\n\t\r\n\tvar ALIGN_START  = 0;\r\n\tvar ALIGN_CENTER = 1;\r\n\tvar ALIGN_END    = 2;\r\n\tvar ALIGN_FIT    = 3;\r\n\t\r\n\tvar TRACK_BREADTH_AUTO        = 0;\r\n\tvar TRACK_BREADTH_LENGTH      = 1;\r\n\tvar TRACK_BREADTH_FRACTION    = 2;\r\n\tvar TRACK_BREADTH_PERCENTAGE  = 3;\r\n\tvar TRACK_BREADTH_MIN_CONTENT = 4;\r\n\tvar TRACK_BREADTH_MAX_CONTENT = 5;\r\n\t\r\n\tfunction GridTrackBreadth() {\r\n\t\tthis.minType = TRACK_BREADTH_AUTO;\r\n\t\tthis.minValue = \"auto\";\r\n\t\tthis.maxType = TRACK_BREADTH_AUTO;\r\n\t\tthis.maxValue = \"auto\";\r\n\t}\r\n\t\r\n\tGridTrackBreadth.prototype = {\r\n\t\ttoString: function() {\r\n\t\t\tif(this.minType==this.maxType && this.minValue==this.maxValue) {\r\n\t\t\t\tswitch(this.minType) {\r\n\t\t\t\t\tcase TRACK_BREADTH_AUTO: return \"auto\";\r\n\t\t\t\t\tcase TRACK_BREADTH_LENGTH: return this.minValue+\"px\";\r\n\t\t\t\t\tcase TRACK_BREADTH_FRACTION: return this.minValue+\"fr\";\r\n\t\t\t\t\tcase TRACK_BREADTH_PERCENTAGE: return this.minValue+\"%\";\r\n\t\t\t\t\tcase TRACK_BREADTH_MIN_CONTENT: return \"min-content\";\r\n\t\t\t\t\tcase TRACK_BREADTH_MAX_CONTENT: return \"max-content\";\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar min = \"auto\";\r\n\t\t\t\tvar max = \"auto\";\r\n\t\t\t\tswitch(this.minType) {\r\n\t\t\t\t\tcase TRACK_BREADTH_AUTO: min = \"auto\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_LENGTH: min = this.minValue+\"px\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_FRACTION: min = this.minValue+\"fr\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_PERCENTAGE: min = this.minValue+\"%\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_MIN_CONTENT: min = \"min-content\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_MAX_CONTENT: min = \"max-content\"; break;\r\n\t\t\t\t}\r\n\t\t\t\tswitch(this.maxType) {\r\n\t\t\t\t\tcase TRACK_BREADTH_AUTO: max = \"auto\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_LENGTH: max = this.maxValue+\"px\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_FRACTION: max = this.maxValue+\"fr\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_PERCENTAGE: max = this.maxValue+\"%\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_MIN_CONTENT: max = \"min-content\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_MAX_CONTENT: max = \"max-content\"; break;\r\n\t\t\t\t}\r\n\t\t\t\treturn \"minmax(\" + min + \", \" + max + \")\";\r\n\t\t\t}\r\n\t\t},\r\n\t\tsetValue: function(type, val) {\r\n\t\t\tthis.minType  = this.maxType  = type;\r\n\t\t\tthis.minValue = this.maxValue = val;\r\n\t\t},\r\n\t\tsetMaxValue: function(type, val) {\r\n\t\t\tthis.maxType  = type;\r\n\t\t\tthis.maxValue = val;\r\n\t\t},\r\n\t\tsetMinValue: function(type, val) {\r\n\t\t\tthis.minType  = type;\r\n\t\t\tthis.minValue = val;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction GridItemPosition(type, name, index) {\r\n\t\tthis.type = type|LOCATE_AUTO;\r\n\t\tthis.name = name;\r\n\t\tthis.index = index|0;\r\n\t}\r\n\t\r\n\tGridItemPosition.prototype = {\r\n\t\textractXLineIndex: function(grid, TODO_args) {\r\n\t\t\tthrow \"Not implemented\";\r\n\t\t},\r\n\t\textractYLineIndex: function(grid, TODO_args) {\r\n\t\t\tthrow \"Not implemented\";\r\n\t\t},\r\n\t\ttoString: function() {\r\n\t\t\t\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction GridItem(element, parentGrid) {\r\n\t\t\r\n\t\tthis.element = element;\r\n\t\tthis.parentGrid = element.parentGridLayout = parentGrid;\r\n\t\t\r\n\t\tthis.reset();\r\n\t\tthis.buggy = true;\r\n\t\t\r\n\t}\r\n\t\r\n\tGridItem.prototype = {\r\n\t\t\r\n\t\tdispose: function() {\r\n\t\t\t// there is nothing to do anymore when a grid item is disposed since we don't cache on the DOM\r\n\t\t},\r\n\t\t\r\n\t\treset: function() {\r\n\t\t\t\r\n\t\t\tthis.order = 0;\r\n\t\t\t\r\n\t\t\tthis.minWidth = 0;\r\n\t\t\tthis.maxWidth = 0;\r\n\t\t\t\r\n\t\t\tthis.hlMargin = 0;\r\n\t\t\tthis.hrMargin = 0;\r\n\t\t\tthis.vtMargin = 0;\r\n\t\t\tthis.vbMargin = 0;\r\n\r\n\t\t\tthis.hlPadding = 0;\r\n\t\t\tthis.hrPadding = 0;\r\n\t\t\tthis.vtPadding = 0;\r\n\t\t\tthis.vbPadding = 0;\r\n\r\n\t\t\tthis.hlBorder = 0;\r\n\t\t\tthis.hrBorder = 0;\r\n\t\t\tthis.vtBorder = 0;\r\n\t\t\tthis.vbBorder = 0;\r\n\t\t\t\r\n\t\t\tthis.hMargins = 0;\r\n\t\t\tthis.vMargins = 0;\r\n\t\t\tthis.hPaddings = 0;\r\n\t\t\tthis.vPaddings = 0;\r\n\t\t\tthis.hBorders = 0;\r\n\t\t\tthis.vBorders = 0;\r\n\t\t\t\r\n\t\t\tthis.xStart = -1;\r\n\t\t\tthis.xEnd = -1;\r\n\t\t\t\r\n\t\t\tthis.specifiedXStart = this.specifiedXStart || new GridItemPosition();\r\n\t\t\tthis.specifiedXStart.type = LOCATE_AUTO;\r\n\t\t\tthis.specifiedXStart.name = undefined;\r\n\t\t\tthis.specifiedXStart.index = undefined;\r\n\t\t\t\r\n\t\t\tthis.specifiedXEnd = this.specifiedXEnd || new GridItemPosition();\r\n\t\t\tthis.specifiedXEnd.type = LOCATE_AUTO;\r\n\t\t\tthis.specifiedXEnd.name = undefined;\r\n\t\t\tthis.specifiedXEnd.index = undefined;\r\n\r\n\t\t\t\r\n\t\t\tthis.yStart = -1;\r\n\t\t\tthis.yEnd = -1;\r\n\t\t\t\r\n\t\t\tthis.specifiedYStart = this.specifiedYStart || new GridItemPosition();\r\n\t\t\tthis.specifiedYStart.type = LOCATE_AUTO;\r\n\t\t\tthis.specifiedYStart.name = undefined;\r\n\t\t\tthis.specifiedYStart.index = undefined;\r\n\t\t\t\r\n\t\t\tthis.specifiedYEnd = this.specifiedYEnd || new GridItemPosition();\r\n\t\t\tthis.specifiedYEnd.type = LOCATE_AUTO;\r\n\t\t\tthis.specifiedYEnd.name = undefined;\r\n\t\t\tthis.specifiedYEnd.index = undefined;\r\n\t\t\t\r\n\t\t\tthis.marginAlignX = ALIGN_CENTER;\r\n\t\t\tthis.marginAlignY = ALIGN_CENTER;\r\n\t\t\t\r\n\t\t\tthis.paddingAlignX = ALIGN_FIT;\r\n\t\t\tthis.paddingAlignY = ALIGN_FIT;\r\n\t\t\t\r\n\t\t\t\r\n\t\t},\r\n\t\r\n\t\tupdateFromElement: function*() {\r\n\t\t\t\r\n\t\t\tvar element = this.element;\r\n\t\t\tvar usedStyle = element.styleMap;\r\n\t\t\t\r\n\t\t\tthis.reset(); \r\n\t\t\tthis.buggy = false;\r\n\t\t\t\r\n\t\t\t// compute order property\r\n\t\t\tthis.order = parseInt(usedStyle.getPropertyValue('order'))|0;\r\n\t\t\t\r\n\t\t\t// compute size\r\n\t\t\tthis.minWidth = yield* cssSizing.minWidthOf(element);\r\n\t\t\tthis.maxWidth = yield* cssSizing.maxWidthOf(element);\r\n\r\n\t\t\tthis.hlMargin = parseInt(usedStyle.getPropertyValue(\"margin-left\"))|0; // TODO: should convert units here, not assume pixels\r\n\t\t\tthis.hrMargin = parseInt(usedStyle.getPropertyValue(\"margin-right\"))|0;\r\n\t\t\tthis.vtMargin = parseInt(usedStyle.getPropertyValue(\"margin-top\"))|0;\r\n\t\t\tthis.vbMargin = parseInt(usedStyle.getPropertyValue(\"margin-bottom\"))|0;\r\n\r\n\t\t\tthis.hlPadding = parseInt(usedStyle.getPropertyValue(\"padding-left\"))|0;\r\n\t\t\tthis.hrPadding = parseInt(usedStyle.getPropertyValue(\"padding-right\"))|0;\r\n\t\t\tthis.vtPadding = parseInt(usedStyle.getPropertyValue(\"padding-top\"))|0;\r\n\t\t\tthis.vbPadding = parseInt(usedStyle.getPropertyValue(\"padding-bottom\"))|0;\r\n\r\n\t\t\tthis.hlBorder = parseInt(usedStyle.getPropertyValue(\"border-left-width\"))|0;\r\n\t\t\tthis.hrBorder = parseInt(usedStyle.getPropertyValue(\"border-right-width\"))|0;\r\n\t\t\tthis.vtBorder = parseInt(usedStyle.getPropertyValue(\"border-top-width\"))|0;\r\n\t\t\tthis.vbBorder = parseInt(usedStyle.getPropertyValue(\"border-bottom-width\"))|0;\r\n\r\n\t\t\tthis.hMargins = this.hlMargin + this.hrMargin;\r\n\t\t\tthis.vMargins = this.vtMargin + this.vbMargin;\r\n\t\t\tthis.hPaddings = this.hlPadding + this.hrPadding;\r\n\t\t\tthis.vPaddings = this.vtPadding + this.vbPadding;\r\n\t\t\tthis.hBorders = this.hlBorder + this.hrBorder;\r\n\t\t\tthis.vBorders = this.vtBorder + this.vbBorder;\r\n\t\t\t\r\n\t\t\t// locate x and y lines together\r\n\t\t\tif(usedStyle.getPropertyValue(\"--grid-area\")) {\r\n\t\t\t\tvar parts = usedStyle.getPropertyValue(\"--grid-area\").split('/');\r\n\t\t\t\tvar is_ident = /^\\s*([a-z][-_a-z0-9]*)\\s*$/i;\r\n\t\t\t\tvar row_start = parts[0] || 'auto';\r\n\t\t\t\tvar col_start = parts[1] || (is_ident.test(row_start) ? row_start : 'auto');\r\n\t\t\t\tvar row_end = parts[2] || (is_ident.test(row_start) ? row_start : 'auto');\r\n\t\t\t\tvar col_end = parts[3] || (is_ident.test(col_start) ? col_start : 'auto');\r\n\t\t\t\tthis.parseLocationInstructions(this.specifiedXStart, this.specifiedXEnd, col_start + \" / \" + col_end);\r\n\t\t\t\tthis.parseLocationInstructions(this.specifiedYStart, this.specifiedYEnd, row_start + \" / \" + row_end);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// locate x lines\r\n\t\t\tif(usedStyle.getPropertyValue(\"--grid-column\") || usedStyle.getPropertyValue(\"--grid-column-start\") || usedStyle.getPropertyValue(\"--grid-column-end\")) {\r\n\t\t\t\tvar parts = usedStyle.getPropertyValue(\"--grid-column\").split('/');\r\n\t\t\t\tvar start = usedStyle.getPropertyValue(\"--grid-column-start\") || parts[0] || 'auto';\r\n\t\t\t\tvar end   = usedStyle.getPropertyValue(\"--grid-column-end\") || parts[1] || parts[0] || start;\r\n\t\t\t\tthis.parseLocationInstructions(this.specifiedXStart, this.specifiedXEnd, start + \" / \" + end);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// locate y lines\r\n\t\t\tif(usedStyle.getPropertyValue(\"--grid-row\") || usedStyle.getPropertyValue(\"--grid-row-start\") || usedStyle.getPropertyValue(\"--grid-row-end\")) {\r\n\t\t\t\tvar parts = usedStyle.getPropertyValue(\"--grid-row\").split('/');\r\n\t\t\t\tvar start = usedStyle.getPropertyValue(\"--grid-row-start\") || parts[0];\r\n\t\t\t\tvar end   = usedStyle.getPropertyValue(\"--grid-row-end\") || parts[1] || parts[0];\r\n\t\t\t\tthis.parseLocationInstructions(this.specifiedYStart, this.specifiedYEnd, start + \" / \" + end);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// FIXME: is it possible to understand cascading here, and not use a fixed order?\r\n\t\t\t// TODO: other positioning methods\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tparseLocationInstructions: function(specifiedStart, specifiedEnd, cssText) {\r\n\t\t\t\r\n\t\t\tvar unfiltred_value = cssSyntax.parseCSSValue(cssText);\r\n\t\t\tvar value = unfiltred_value.filter(function(o) { return !(o instanceof cssSyntax.WhitespaceToken); });\r\n\t\t\tvalue.toCSSString = function() { return unfiltred_value.toCSSString(); }\r\n\t\t\tvar I = 0;\r\n\t\t\t\r\n\t\t\tvar updateNameOrIndex = function(data) {\r\n\t\t\t\tif(value[I] instanceof cssSyntax.IdentifierToken) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// grid-column: C;\r\n\t\t\t\t\tif(data.name) { \r\n\t\t\t\t\t\t// duplicate line-name value\r\n\t\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (duplicate line name)\");\r\n\t\t\t\t\t\tthis.buggy = true;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdata.name = value[I++].value;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(value[I] instanceof cssSyntax.NumberToken) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// grid-column: 3\r\n\t\t\t\t\tdata.index = value[I].value|0;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// only accept integer values\r\n\t\t\t\t\tif(value[I].value != data.index) {\r\n\t\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (non-integer number)\");\r\n\t\t\t\t\t\tthis.buggy = true;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// do not accept zero\r\n\t\t\t\t\tif(data.index == 0) {\r\n\t\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (line index can't be zero)\");\r\n\t\t\t\t\t\tthis.buggy = true;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// do not accept negative spans\r\n\t\t\t\t\tif(data.index <= 0 && data.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (negative spans not allowed)\");\r\n\t\t\t\t\t\tthis.buggy = true;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tI++;\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(value[I] instanceof cssSyntax.DelimToken && value[I].value == \"/\") {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// break grid-column-start detection\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// this is wrong\r\n\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (invalid token)\");\r\n\t\t\t\t\tthis.buggy = true;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tvar gatherNameIndexPair = function(data) {\r\n\r\n\t\t\t\t// first token to be analyzed (may be either kind)\r\n\t\t\t\tupdateNameOrIndex.call(this, data);\r\n\t\t\t\t\r\n\t\t\t\t// abort if no second token or buggy\r\n\t\t\t\tif(this.buggy || !value[I]) { return; }\r\n\t\t\t\r\n\t\t\t\t// second token to be analyzed (will have to be the other kind)\r\n\t\t\t\tupdateNameOrIndex.call(this, data);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(!value[I]) { console.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (empty declaration)\"); this.buggy = true; return; }\r\n\t\t\t\r\n\r\n\t\t\t// first part\r\n\t\t\tgridColumnStart: while(true) {\r\n\t\t\t\tif(value[I] instanceof cssSyntax.IdentifierToken) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(value[I].value == \"span\") {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif(!value[++I]) {console.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (span is not a valid line name, more tokens expected)\"); this.buggy = true; return; }\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tspecifiedStart.type = LOCATE_SPAN;\r\n\t\t\t\t\t\tspecifiedStart.name = undefined;\r\n\t\t\t\t\t\tspecifiedStart.index = undefined;\r\n\t\t\t\t\t\tgatherNameIndexPair.call(this, specifiedStart);\r\n\t\t\t\t\t\tif(this.buggy) { return; }\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\t\t} else if(value[I].value == \"auto\") {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tspecifiedStart.type = LOCATE_AUTO;\r\n\t\t\t\t\t\tspecifiedStart.name = undefined;\r\n\t\t\t\t\t\tspecifiedStart.index = undefined;\r\n\t\t\t\t\t\tI++; break;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// grid-column: start-line...\r\n\t\t\t\t\t\tspecifiedStart.type = LOCATE_LINE;\r\n\t\t\t\t\t\tspecifiedStart.name = undefined;\r\n\t\t\t\t\t\tspecifiedStart.index = undefined;\r\n\t\t\t\t\t\tgatherNameIndexPair.call(this, specifiedStart);\r\n\t\t\t\t\t\tif(this.buggy) { return; }\r\n\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(value[I] instanceof cssSyntax.DelimToken && value[I].value == \"/\") {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// this is wrong\r\n\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (no token to analyze before the slash token)\");\r\n\t\t\t\t\tthis.buggy = true;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\tspecifiedStart.type = LOCATE_LINE;\r\n\t\t\t\t\tgatherNameIndexPair.call(this, specifiedStart);\r\n\t\t\t\t\tif(this.buggy) { return; }\r\n\t\t\t\t\t\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// test whether there is a second part\r\n\t\t\tif(value[I]) {\r\n\t\t\t\t\r\n\t\t\t\tif(value[I] instanceof cssSyntax.DelimToken && value[I].value == \"/\") {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// second part will start now\r\n\t\t\t\t\tif(!value[++I]) {\r\n\t\t\t\t\t\t// unexpected lack token at the start of the second part\r\n\t\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (expected at least one more token after the slash token)\");\r\n\t\t\t\t\t\tthis.buggy = true; \r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t\t// unexpected token at the end of the first part\r\n\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (expected slash / or end of declaration)\");\r\n\t\t\t\t\tthis.buggy = true; \r\n\t\t\t\t\treturn;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// end of declaration\r\n\t\t\t\tif(specifiedStart.type == LOCATE_LINE && specifiedStart.name != undefined && specifiedStart.index == undefined) {\r\n\t\t\t\t\t// a value consisting of a custom ident is duplicated to the other side\r\n\t\t\t\t\tspecifiedEnd.type = LOCATE_LINE;\r\n\t\t\t\t\tspecifiedEnd.name = specifiedStart.name;\r\n\t\t\t\t\tspecifiedEnd.index = undefined;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// the default value (auto) is a 1-line span in all other cases\r\n\t\t\t\t\tspecifiedEnd.type = LOCATE_AUTO;\r\n\t\t\t\t\tspecifiedEnd.name = undefined;\r\n\t\t\t\t\tspecifiedEnd.index = undefined;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// second part (after the \"/\" token)\r\n\t\t\tgridColumnEnd: while(value[I]) {\r\n\t\t\t\t\r\n\t\t\t\tif(value[I] instanceof cssSyntax.IdentifierToken) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(value[I].value == \"span\") {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif(!value[++I]) {console.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (span is not a valid line name, more tokens expected)\"); this.buggy = true; return; }\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tspecifiedEnd.type = LOCATE_SPAN;\r\n\t\t\t\t\t\tspecifiedEnd.name = undefined;\r\n\t\t\t\t\t\tspecifiedEnd.index = undefined;\r\n\t\t\t\t\t\tgatherNameIndexPair.call(this, specifiedEnd);\r\n\t\t\t\t\t\tif(this.buggy) { return; }\r\n\t\t\t\t\t\r\n\t\t\t\t\t} else if(value[I].value == \"auto\") {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tspecifiedEnd.type = LOCATE_AUTO;\r\n\t\t\t\t\t\tspecifiedEnd.name = undefined;\r\n\t\t\t\t\t\tspecifiedEnd.index = undefined;\r\n\t\t\t\t\t\tI++; break;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// grid-column: start-line...\r\n\t\t\t\t\t\tspecifiedEnd.type = LOCATE_LINE;\r\n\t\t\t\t\t\tspecifiedEnd.name = undefined;\r\n\t\t\t\t\t\tspecifiedEnd.name = undefined;\r\n\t\t\t\t\t\tspecifiedEnd.index = undefined;\r\n\t\t\t\t\t\tgatherNameIndexPair.call(this, specifiedEnd);\r\n\t\t\t\t\t\tif(this.buggy) { return; }\r\n\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(value[I] instanceof cssSyntax.DelimToken && value[I].value == \"/\") {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// this is wrong\r\n\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (no token to analyze before the slash token)\");\r\n\t\t\t\t\tthis.buggy = true;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\tspecifiedEnd.type = LOCATE_LINE;\r\n\t\t\t\t\tgatherNameIndexPair.call(this, specifiedEnd);\r\n\t\t\t\t\tif(this.buggy) { return; }\r\n\t\t\t\t\t\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tbreak;\t\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(value[I]) {\r\n\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (tokens after end)\");\r\n\t\t\t\tthis.buggy = true; \r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// If the <integer> is omitted, it defaults to '1'.\r\n\t\t\t//if(specifiedStart.name && specifiedStart.index == undefined) { specifiedStart.index = 1; }\r\n\t\t\t//if(specifiedEnd.name && specifiedEnd.index == undefined) { specifiedEnd.index = 1; }\r\n\t\t\t\r\n\t\t\t// If both 'grid-row/column-start' and 'grid-row/column-end' specify a span, the end span is ignored. \r\n\t\t\tif(specifiedEnd.type == LOCATE_SPAN && specifiedStart.type == LOCATE_SPAN) { specifiedEnd.type = LOCATE_AUTO; specifiedEnd.index = undefined; specifiedEnd.name = undefined; }\r\n\t\t\t\r\n\t\t\treturn [specifiedStart, specifiedEnd];\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\r\n\t};\t\r\n\r\n\tfunction GridLayout(element) {\r\n\t\r\n\t\t// items\r\n\t\tthis.element = element; this.element.gridLayout = this;\r\n\t\tthis.items = []; // array of GridItem\r\n\r\n\t\t// reset\r\n\t\tthis.reset();\r\n\t\t\t\t\r\n\t}\r\n\t\r\n\tGridLayout.prototype = {\r\n\t\r\n\t\treset: function() {\r\n\t\t\t\r\n\t\t\t// layout exclusion style\r\n\t\t\tthis.hlPadding = 0;\r\n\t\t\tthis.hrPadding = 0;\r\n\t\t\tthis.vtPadding = 0;\r\n\t\t\tthis.vbPadding = 0;\r\n\t\t\tthis.hPaddings = 0;\r\n\t\t\tthis.vPaddings = 0;\r\n\t\t\t\r\n\t\t\t// computed\r\n\t\t\tthis.xLines = []; // array of array of names\r\n\t\t\tthis.xSizes = []; // array of numbers (in pixels)\r\n\t\t\t\r\n\t\t\tthis.yLines = [];\r\n\t\t\tthis.ySizes = [];\r\n\r\n\t\t\tthis.growX = false;\r\n\t\t\tthis.growY = true;\r\n\t\t\tthis.growDense = false;\r\n\r\n\t\t\tthis.parentGridData = null; // { spannedGridColumns, spannedGridRows }\r\n\t\t\tthis.isSubgridX = false;\r\n\t\t\tthis.isSubgridY = false;\r\n\t\t\t\r\n\t\t\tthis.rcMatrix = []; // array of array of (whatever is not undefined, probably \"true\")\r\n\t\t\t\r\n\t\t\t// specified\r\n\t\t\tthis.specifiedXLines = [];\r\n\t\t\tthis.specifiedXSizes = [];\r\n\t\t\t\r\n\t\t\tthis.specifiedYLines = [];\r\n\t\t\tthis.specifiedYSizes = [];\r\n\t\t\t\r\n\t\t\tthis.defaultXSize = new GridTrackBreadth();\r\n\t\t\tthis.defaultYSize = new GridTrackBreadth();\r\n\r\n\t\t},\r\n\t\r\n\t\tR: function R(x,y) { \r\n\t\t\tif(this.growY) {\r\n\t\t\t\t// we grow by adding rows (normal behavior)\r\n\t\t\t\treturn y;\r\n\t\t\t} else {\r\n\t\t\t\t// we grow by adding columns (inversed behavior)\r\n\t\t\t\treturn x;\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\tC: function C(x,y) { \r\n\t\t\tif(this.growY) {\r\n\t\t\t\t// we grow by adding rows (normal behavior)\r\n\t\t\t\treturn x;\r\n\t\t\t} else {\r\n\t\t\t\t// we grow by adding columns (inversed behavior)\r\n\t\t\t\treturn y;\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\tdispose: function() {\r\n\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i];\r\n\t\t\t\titem.dispose();\r\n\t\t\t}\r\n\t\t\tthis.element.gridLayout = undefined;\r\n\t\t},\r\n\t\t\r\n\t\tupdateFromElement: function*(parentGridData) {\r\n\t\t\t\r\n\t\t\t// delete old items\r\n\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i];\r\n\t\t\t\titem.dispose();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// add new items\r\n\t\t\tthis.items.length = 0;\r\n\t\t\tthis.items = this.element.children.map(child => new cssGrid.GridItem(child, this));\r\n\t\t\tfor(var newGridItem of this.items) {\r\n\t\t\t\tyield* newGridItem.updateFromElement();\r\n\t\t\t}\r\n\r\n\t\t\t// sort them by css order (desc) then by dom order (asc)\r\n\t\t\tvar sortableItems = this.items.map(function(item, i) { return { item: item, order: item.order, position: i } });\r\n\t\t\tsortableItems.sort(function(a,b) { if(a.order==b.order) { return a.position-b.position } else if(a.order>b.order) { return +1 } else { return -1; } });\r\n\t\t\tthis.items = sortableItems.map(function(data) { return data.item; });\r\n\t\t\t\r\n\t\t\t// reset the style\r\n\t\t\tthis.reset();\r\n\r\n\t\t\t// import data from parent\r\n\t\t\tthis.parentGridData = parentGridData;\r\n\t\t\t\r\n\t\t\t// update its own style\r\n\t\t\tvar usedStyle = this.element.styleMap; var cssText = '';\r\n\t\t\tif(cssText=usedStyle.getPropertyValue(\"--grid-template\"))         { this.parseGridTemplate(cssText);    }\r\n\t\t\tif(cssText=usedStyle.getPropertyValue(\"--grid-template-rows\"))    { this.parseRowsTemplate(cssText);    }\r\n\t\t\tif(cssText=usedStyle.getPropertyValue(\"--grid-template-columns\")) { this.parseColumnsTemplate(cssText); }\r\n\t\t\tif(cssText=usedStyle.getPropertyValue(\"--grid-template-areas\"))   { this.parseAreasTemplate(cssText);   }\r\n\t\t\tif(cssText=usedStyle.getPropertyValue(\"--grid-auto-rows\")) { this.parseAutoRowsBreadth(cssText); }\r\n\t\t\tif(cssText=usedStyle.getPropertyValue(\"--grid-auto-columns\")) { this.parseAutoColumnsBreadth(cssText); }\r\n\t\t\tif(cssText=usedStyle.getPropertyValue(\"--grid-auto-flow\")) { // FIXME: should be in a function\r\n\t\t\t\t\r\n\t\t\t\t// FIXME: not a real parse...\r\n\t\t\t\tvar tokens = cssText.trim().toLowerCase().split(/\\s+/g);\r\n\t\t\t\t\r\n\t\t\t\t// direction\r\n\t\t\t\tif(tokens.indexOf('row')>=0) {\r\n\t\t\t\t\tthis.growX = false;\r\n\t\t\t\t\tthis.growY = true;\r\n\t\t\t\t} else if(tokens.indexOf('column')>=0) {\r\n\t\t\t\t\tthis.growX = true;\r\n\t\t\t\t\tthis.growY = false;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// algorithm\r\n\t\t\t\t// FIXME: should also support 'stack' (wtf)\r\n\t\t\t\tif(tokens.indexOf('dense')>=0) {\r\n\t\t\t\t\tthis.growDense = true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.growDense = false;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis.hlPadding = parseInt(usedStyle.getPropertyValue('border-left-width')) + parseInt(usedStyle.getPropertyValue('padding-left'));\r\n\t\t\tthis.hrPadding = parseInt(usedStyle.getPropertyValue('border-right-width')) + parseInt(usedStyle.getPropertyValue('padding-right'));\r\n\t\t\tthis.vtPadding = parseInt(usedStyle.getPropertyValue('border-top-width')) + parseInt(usedStyle.getPropertyValue('padding-top'));\r\n\t\t\tthis.vbPadding = parseInt(usedStyle.getPropertyValue('border-bottom-width')) + parseInt(usedStyle.getPropertyValue('padding-bottom'));\r\n\r\n\t\t\tthis.hPaddings = this.hlPadding + this.hrPadding;\r\n\t\t\tthis.vPaddings = this.vtPadding + this.vbPadding;\r\n\r\n\t\t\t// we cannot grow in the direction of the subgrid\r\n\t\t\t// TODO: handle case where we grow in neither dimension (right now I choose arbitrarily)\r\n\t\t\tif(this.isSubgridY && this.growY) {\r\n\t\t\t\tthis.growY = false;\r\n\t\t\t\tthis.growX = true;\r\n\t\t\t}\r\n\t\t\tif(this.isSubgridX && this.growX) {\r\n\t\t\t\tthis.growX = false;\r\n\t\t\t\tthis.growY = true;\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\tresetItems: function() {\r\n\t\t\tfor(var i = this.items.length; i--;) {\r\n\t\t\t\tvar item = this.items[i]; \r\n\t\t\t\titem.xStart = item.xEnd = item.yStart = item.yEnd = -1;\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\tresetLinesToSpecified: function() {\r\n\t\t\tthis.xLines = this.specifiedXLines.slice(0);\r\n\t\t\tthis.xSizes = this.specifiedXSizes.slice(0);\r\n\t\t\tthis.yLines = this.specifiedYLines.slice(0);\r\n\t\t\tthis.ySizes = this.specifiedYSizes.slice(0);\r\n\t\t},\r\n\t\t\r\n\t\tparseTrackBreadthToken: function(cssToken) {\r\n\t\t\t\r\n\t\t\t// try to match a pattern\r\n\t\t\tif(cssToken instanceof cssSyntax.IdentifierToken) {\r\n\t\t\t\t\r\n\t\t\t\tif(cssToken.value == \"auto\") {\r\n\t\t\t\t\treturn { type: TRACK_BREADTH_AUTO, value:\"auto\" };\r\n\t\t\t\t} else if(cssToken.value == \"min-content\") {\r\n\t\t\t\t\treturn { type: TRACK_BREADTH_MIN_CONTENT, value:\"min-content\" };\r\n\t\t\t\t} else if(cssToken.value == \"max-content\") {\r\n\t\t\t\t\treturn { type: TRACK_BREADTH_MAX_CONTENT, value:\"max-content\" };\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else if(cssToken instanceof cssSyntax.DimensionToken) {\r\n\t\t\t\t\r\n\t\t\t\tif(cssToken.unit == \"fr\") {\r\n\t\t\t\t\treturn { type: TRACK_BREADTH_FRACTION, value:cssToken.value };\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn { type: TRACK_BREADTH_LENGTH, value:cssUnits.convertToPixels(cssToken.toCSSString(), this.element) };\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else if(cssToken instanceof cssSyntax.PercentageToken) {\r\n\t\t\t\t\r\n\t\t\t\treturn { type: TRACK_BREADTH_PERCENTAGE, value:cssToken.value };\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// TODO: recognize \"calc()\", too\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn null;\r\n\t\t},\r\n\t\t\r\n\t\tparseTrackBreadth: function(value, I) {\r\n\t\t\r\n\t\t\t// TODO: try catch on null parsed token\r\n\t\t\tvar buggy = false;\r\n\t\t\t\r\n\t\t\tvar currentTrackBreadth = new GridTrackBreadth();\r\n\t\t\tvar parseTrackBreadthToken = function() {\r\n\t\t\t\t\r\n\t\t\t\t// try to match a pattern\r\n\t\t\t\tvar result = this.parseTrackBreadthToken(value[I]);\r\n\t\t\t\tif(result) { I++; return result; }\r\n\t\t\t\t\r\n\t\t\t\t// no pattern matched, so the declaration is invalid:\r\n\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-template-rows/columns: \"+value.toCSSString()+\" (unrecognized track breadth)\");\r\n\t\t\t\tbuggy = true;\r\n\t\t\t\treturn;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(value[I] instanceof cssSyntax.Func && value[I].name==\"minmax\") {\r\n\t\t\t\t\r\n\t\t\t\t// we need to parse two subvalues\r\n\t\t\t\tvar value_backup = value;\r\n\t\t\t\tvar I_backup = I;\r\n\t\t\t\t\r\n\t\t\t\t// check we have exactly two arguments\r\n\t\t\t\tvar args = value_backup[I_backup].getArguments();\r\n\t\t\t\tif(args.length != 2) { \r\n\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-template-rows/columns: \"+value_backup.toCSSString()+\" (invalid number of arguments to the minmax function)\");\r\n\t\t\t\t\tbuggy = true;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// here's the first one:\r\n\t\t\t\tvalue = args[0].filter(function(t) { return !(t instanceof cssSyntax.WhitespaceToken) }); I = 0;\t\t\t\t\r\n\t\t\t\tvar data = parseTrackBreadthToken.call(this);\r\n\t\t\t\tcurrentTrackBreadth.minType = data.type;\r\n\t\t\t\tcurrentTrackBreadth.minValue = data.value;\r\n\t\t\t\t\r\n\t\t\t\t// here's the second one:\r\n\t\t\t\tvalue = args[1].filter(function(t) { return !(t instanceof cssSyntax.WhitespaceToken) }); I = 0;\t\t\t\t\r\n\t\t\t\tvar data = parseTrackBreadthToken.call(this);\r\n\t\t\t\tcurrentTrackBreadth.maxType  = data.type;\r\n\t\t\t\tcurrentTrackBreadth.maxValue = data.value;\r\n\t\t\t\t\r\n\t\t\t\t// restore context\r\n\t\t\t\tvalue = value_backup;\r\n\t\t\t\tI = I_backup+1;\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\r\n\t\t\t\t// we need to parse only one value\r\n\t\t\t\tvar data = parseTrackBreadthToken.call(this);\r\n\t\t\t\tcurrentTrackBreadth.minType  = currentTrackBreadth.maxType  = data.type;\r\n\t\t\t\tcurrentTrackBreadth.minValue = currentTrackBreadth.maxValue = data.value;\r\n\r\n\t\t\t}\r\n\t\t\t\t\r\n\t\t\treturn { result: currentTrackBreadth, I:I };\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tparseAutoRowsBreadth: function(cssText) {\r\n\t\t\r\n\t\t\t// TODO: check that no tokens are left when the parsing is done (+columns)\r\n\t\t\t\r\n\t\t\t// parse value into tokens:\r\n\t\t\tvar unfiltred_value = cssSyntax.parseCSSValue(cssText);\r\n\t\t\tvar value = unfiltred_value.filter(function(o) { return !(o instanceof cssSyntax.WhitespaceToken); });\r\n\t\t\tvalue.toCSSString = function() { return unfiltred_value.toCSSString(); }\r\n\t\t\t\r\n\t\t\t// parse tokens into data:\r\n\t\t\tvar data = this.parseTrackBreadth(value, 0);\r\n\t\t\tif(data.result) { this.defaultYSize = data.result; } else { throw \"TODO: better error message\"; }\r\n\t\t\treturn;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tparseAutoColumnsBreadth: function(cssText) {\r\n\t\t\t\r\n\t\t\t// parse value into tokens:\r\n\t\t\tvar unfiltred_value = cssSyntax.parseCSSValue(cssText);\r\n\t\t\tvar value = unfiltred_value.filter(function(o) { return !(o instanceof cssSyntax.WhitespaceToken); });\r\n\t\t\tvalue.toCSSString = function() { return unfiltred_value.toCSSString(); }\r\n\t\t\t\r\n\t\t\t// parse tokens into data:\r\n\t\t\tvar data = this.parseTrackBreadth(value, 0);\r\n\t\t\tif(data.result) { this.defaultXSize = data.result; } else { throw \"TODO: better error message\"; }\r\n\t\t\treturn;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tparseGridTemplate: function(cssText) { // TODO: I used some lazy heuristics here\r\n\t\t\tvar buggy = false; \r\n\t\t\r\n\t\t\t// step 1: columns are defined before the slash, if any\r\n\t\t\tvar cssText = cssText.replace(/\\/\\*(.*?)\\*\\//g,\"\");\r\n\t\t\tvar cssTextSections = cssText.split(\"/\");\r\n\t\t\tif(cssTextSections.length == 2) {\r\n\t\t\t\tif(this.parseColumnsTemplate(cssTextSections[0])) { return buggy=true; }\r\n\t\t\t\tcssText = cssTextSections[1];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// check that the syntax makes sense\r\n\t\t\telse if(cssTextSections.length >= 3) { \r\n\t\t\t\treturn buggy=true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// check if we can find any string\r\n\t\t\tif(/\"|'/.test(cssText)) {\r\n\t\t\t\r\n\t\t\t\t// extract strings from the value\r\n\t\t\t\tvar strings = [];\r\n\t\t\t\tcssText = cssText.replace(/\\s*(\"(?:.*?)\"|'(?:.*?)')\\s*([-_a-zA-Z0-9]*)\\s*/g,function(data,str,size) { strings.push(str); return ' '+(size||\"auto\")+' '; });\r\n\t\t\t\t\r\n\t\t\t\t// remove duplicate line name blocks\r\n\t\t\t\tcssText = cssText.replace(/\\)\\s*\\(/g,\" \");\r\n\t\t\t\t\r\n\t\t\t\t// parse rows now\r\n\t\t\t\tif(this.parseRowsTemplate(cssText)) { return buggy=true; }\r\n\t\t\t\t\r\n\t\t\t\t// parse areas now\r\n\t\t\t\tif(this.parseAreasTemplate(strings.join(' '))) { return buggy=true; }\r\n\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// parse rows now\r\n\t\t\t\tif(this.parseRowsTemplate(cssText)) { return buggy=true; }\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn buggy;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tparseAreasTemplate: function(cssText) {\r\n\t\t\t\r\n\t\t\t// parse value into tokens:\r\n\t\t\tvar unfiltred_value = cssSyntax.parseCSSValue(cssText);\r\n\t\t\tvar value = unfiltred_value.filter(function(o) { return !(o instanceof cssSyntax.WhitespaceToken); });\r\n\t\t\tvalue.toCSSString = function() { return unfiltred_value.toCSSString(); }\r\n\t\t\t\r\n\t\t\t// parse tokens into data:\r\n\t\t\tvar I = 0;\r\n\t\t\tvar buggy = false;\r\n\t\t\tvar regexp = /^([-_a-zA-Z0-9]+|[.]+)\\s*/;\r\n\t\t\tvar grid = [], areas = Object.create(null);\r\n\t\t\twhile(value[I]) {\r\n\t\t\t\t\r\n\t\t\t\tvar str = ''+value[I++].value;\r\n\t\t\t\t\r\n\t\t\t\tvar columns = [];\r\n\t\t\t\twhile(str!=='') {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// extract next token\r\n\t\t\t\t\tvar data = regexp.exec(str); if(!data || data.length != 2) { return buggy=true; }\r\n\t\t\t\t\tstr = str.substr(data[0].length); var cell = data[1];\r\n\t\t\t\t\t\r\n\t\t\t\t\t// update cell max pos (ignore empty cells)\r\n\t\t\t\t\tif(cell!='.' && cell[0]!='.') {\r\n\t\t\t\t\t\tif(!areas[cell]) { areas[cell] = { xStart:columns.length, xEnd:columns.length+1, yStart: I-1, yEnd: I }; }\r\n\t\t\t\t\t\tif(areas[cell].xStart > columns.length) { return buggy=true; } \r\n\t\t\t\t\t\tif(areas[cell].yStart > I-1) { return buggy=true; }\r\n\t\t\t\t\t\tareas[cell].xEnd = Math.max(areas[cell].xEnd, columns.length+1);\r\n\t\t\t\t\t\tareas[cell].yEnd = Math.max(areas[cell].yEnd, I);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// add the cell to this row\r\n\t\t\t\t\tcolumns.push(data[1]);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tgrid.push(columns);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// validate areas\r\n\t\t\tfor(var a in areas) {\r\n\t\t\t\tvar area = areas[a];\r\n\t\t\t\tfor(var y = area.yStart; y<area.yEnd; y++) {\r\n\t\t\t\t\tfor(var x = area.xStart; x<area.xEnd; x++) {\r\n\t\t\t\t\t\tif(grid[y][x] != a) { return buggy=true; }\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// add autogenerated line names\r\n\t\t\tfor(var a in areas) {\r\n\t\t\t\tvar area = areas[a];\r\n\t\t\t\t\r\n\t\t\t\t// make sure we have enough y lines for the areas to fit:\r\n\t\t\t\twhile(this.specifiedYLines.length<=area.yEnd) {\r\n\t\t\t\t\tthis.specifiedYLines.push([]);\r\n\t\t\t\t\tthis.specifiedYSizes.push(this.defaultYSize);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// add the y line name\r\n\t\t\t\tthis.specifiedYLines[area.yStart].push(a+\"-start\");\r\n\t\t\t\tthis.specifiedYLines[area.yEnd].push(a+\"-end\");\r\n\t\t\t\t\r\n\t\t\t\t// make sure we have enough x lines for the areas to fit:\r\n\t\t\t\twhile(this.specifiedXLines.length<=area.xEnd) {\r\n\t\t\t\t\tthis.specifiedXLines.push([]);\r\n\t\t\t\t\tthis.specifiedXSizes.push(this.defaultXSize);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// add the x line name\r\n\t\t\t\tthis.specifiedXLines[area.xStart].push(a+\"-start\");\r\n\t\t\t\tthis.specifiedXLines[area.xEnd].push(a+\"-end\");\r\n\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\t},\r\n\t\t\r\n\t\tparseTrackDefinitions: function(lineNames, trackBreadths, cssText) {\r\n\t\t\t\r\n\t\t\t// replace the repeat() function by its full representation\r\n\t\t\tcssText = cssText.replace(/\\[/g,'(').replace(/\\]/g,')').replace(/repeat\\(\\s*([0-9]+)\\s*\\,((?:\\([^()]*\\)|[^()])+)\\)/gi, function(s, n, v) {\r\n\t\t\t\tvar result = ' ';\r\n\t\t\t\tfor(var i = parseInt(n); i--;) { \r\n\t\t\t\t\tresult += v + ' ';\r\n\t\t\t\t}\r\n\t\t\t\treturn result;\r\n\t\t\t});\r\n\t\t\t'TODO: improve the repeat support';\r\n\t\t\t\r\n\t\t\t// merge duplicate name-definitions\r\n\t\t\tcssText = cssText.replace(/\\)\\s*\\(/g, ' ');\r\n\t\t\t'TODO: improve the duplicate name-definitions support';\r\n\t\t\t\r\n\t\t\t// parse value into tokens:\r\n\t\t\tvar unfiltred_value = cssSyntax.parseCSSValue(cssText);\r\n\t\t\tvar value = unfiltred_value.filter(function(o) { return !(o instanceof cssSyntax.WhitespaceToken); });\r\n\t\t\tvalue.toCSSString = function() { return unfiltred_value.toCSSString(); }\r\n\t\t\t\r\n\t\t\t// parse tokens into data:\r\n\t\t\tvar I = 0;\r\n\t\t\tvar buggy = false;\r\n\t\t\t\r\n\t\t\tvar parseLineNames = function() {\r\n\t\t\t\t\r\n\t\t\t\tvar currentLineNames = []; // array of string\r\n\t\t\t\t\r\n\t\t\t\tif(value[I] instanceof cssSyntax.SimpleBlock && value[I].name == \"(\") {\r\n\t\t\t\t\tvar tokens = value[I].value;\r\n\t\t\t\t\tfor(var J=tokens.length; J--;) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (tokens[J] instanceof cssSyntax.IdentifierToken) {\r\n\t\t\t\t\t\t\tcurrentLineNames.push(tokens[J].value);\r\n\t\t\t\t\t\t} else if (tokens[J] instanceof cssSyntax.WhitespaceToken) {\r\n\t\t\t\t\t\t\t// ignore\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// unrecognized token, so the declaration is invalid:\r\n\t\t\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-template-rows/columns: \"+value.toCSSString()+\" (unrecognized line name)\");\r\n\t\t\t\t\t\t\tbuggy = true;\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tI++;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tlineNames.push(currentLineNames); \r\n\t\t\t\tcurrentLineNames = [];\r\n\t\t\t\t\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tvar parseTrackBreadth = function() {\r\n\t\t\t\t\r\n\t\t\t\tvar data = this.parseTrackBreadth(value, I);\r\n\t\t\t\ttrackBreadths.push(data.result);\r\n\t\t\t\tI = data.I;\r\n\t\t\t\t\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tparseLineNames(); \r\n\t\t\twhile(value[I]) {\r\n\t\t\t\tparseTrackBreadth.call(this); if(buggy) { break; }\r\n\t\t\t\tparseLineNames(); if(buggy) { break; }\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tparseColumnsTemplate: function(cssText) {\r\n\t\t\t// read the grid columns from the parent grid in case we are in a subgrid\r\n\t\t\tif(/^\\s*subgrid\\s*$/i.test(cssText)) {\r\n\t\t\t\tif(this.parentGridData && this.parentGridData.spannedGridColumns) {\r\n\t\t\t\t\tcssText = this.parentGridData.spannedGridColumns;\r\n\t\t\t\t\tthis.isSubgridX = true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcssText = 'auto'; // TODO: should be 'none' but this is not supported\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// parse the value as list of tracks\r\n\t\t\treturn this.parseTrackDefinitions(this.specifiedXLines, this.specifiedXSizes, cssText);\r\n\t\t},\r\n\t\t\r\n\t\tparseRowsTemplate: function(cssText) {\r\n\t\t\t// read the grid rows from the parent grid in case we are in a subgrid\r\n\t\t\tif(/^\\s*subgrid\\s*$/i.test(cssText)) {\r\n\t\t\t\tif(this.parentGridData && this.parentGridData.spannedGridRows) {\r\n\t\t\t\t\tcssText = this.parentGridData.spannedGridRows;\r\n\t\t\t\t\tthis.isSubgridY = true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcssText = 'auto'; // TODO: should be 'none' but this is not supported\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// parse the value as list of tracks\r\n\t\t\treturn this.parseTrackDefinitions(this.specifiedYLines, this.specifiedYSizes, cssText);\r\n\t\t},\r\n\t\t\r\n\t\tparseTracksTemplate: function(columnsTemplate, rowsTemplate, areasTemplate) {\r\n\t\t\tif(rowsTemplate   ) this.parseRowsTemplate(rowsTemplate);\r\n\t\t\tif(columnsTemplate) this.parseColumnsTemplate(columnsTemplate);\r\n\t\t\tif(areasTemplate  ) this.parseAreasTemplate(areasTemplate);\r\n\t\t},\r\n\t\t\r\n\t\tbuildExplicitMatrix: function() {\r\n\t\t\t\r\n\t\t\t// reset\r\n\t\t\tthis.resetLinesToSpecified();\r\n\t\t\tthis.rcMatrix = [];\r\n\t\t\t\r\n\t\t\t// simple autogrow\r\n\t\t\tif(this.growY) {\r\n\t\t\t\tthis.ensureRows(this.ySizes.length);\r\n\t\t\t\tthis.ensureColumns(this.xSizes.length);\r\n\t\t\t} else {\r\n\t\t\t\tthis.ensureColumns(this.xSizes.length);\r\n\t\t\t\tthis.ensureRows(this.ySizes.length);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}, \r\n\t\t\r\n\t\tbuildImplicitMatrix: function*() { /* see http://dev.w3.org/csswg/css-grid/#auto-placement-algo */\r\n\t\t\r\n\t\t\t// start by building the explicit matrix\r\n\t\t\tthis.buildExplicitMatrix();\r\n\t\t\t\r\n\t\t\t// [1] position non-auto items\r\n\t\t\tyield* this.positionNonAutoItems();\r\n\t\t\t\r\n\t\t\t// [2] position auto-in-column-only items\r\n\t\t\tyield* this.positionAutoInColumnOnlyItems();\r\n\t\t\t\r\n\t\t\t// [3] make room for implicit tracks\r\n\t\t\tthis.autoGrow();\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tensureRows: function(yEnd) {\r\n\t\t\t\r\n\t\t\tif(this.growY) {\r\n\t\t\t\t\r\n\t\t\t\t// add rows as necessary\r\n\t\t\t\twhile(this.ySizes.length<yEnd) {\r\n\t\t\t\t\tthis.ySizes.push(this.defaultYSize);\r\n\t\t\t\t}\r\n\t\t\t\twhile(this.rcMatrix.length<yEnd) {\r\n\t\t\t\t\tthis.rcMatrix.push([]);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// add rows as necessary\r\n\t\t\t\twhile(this.ySizes.length<yEnd) {\r\n\t\t\t\t\tthis.ySizes.push(this.defaultYSize);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// walk through columns\r\n\t\t\t\tfor(var x = this.rcMatrix.length; x--;) {\r\n\t\t\t\t\r\n\t\t\t\t\t// add rows as necessary\r\n\t\t\t\t\tif(this.rcMatrix[x].length < yEnd) {\r\n\t\t\t\t\t\tthis.rcMatrix[x].length = yEnd;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tensureColumns: function(xEnd) {\r\n\t\t\t\r\n\t\t\tif(this.growY) {\r\n\t\t\t\r\n\t\t\t\t// add columns as necessary\r\n\t\t\t\twhile(this.xSizes.length<xEnd) {\r\n\t\t\t\t\tthis.xSizes.push(this.defaultXSize);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// walk through rows\r\n\t\t\t\tfor(var y = this.rcMatrix.length; y--;) {\r\n\t\t\t\t\r\n\t\t\t\t\t// add columns as necessary\r\n\t\t\t\t\tif(this.rcMatrix[y].length < xEnd) {\r\n\t\t\t\t\t\tthis.rcMatrix[y].length = xEnd;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// add columns as necessary\r\n\t\t\t\twhile(this.xSizes.length<xEnd) {\r\n\t\t\t\t\tthis.xSizes.push(this.defaultXSize);\r\n\t\t\t\t}\r\n\t\t\t\twhile(this.rcMatrix.length<xEnd) {\r\n\t\t\t\t\tthis.rcMatrix.push([]);\r\n\t\t\t\t}\r\n\t\t\t\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\tmarkAsOccupied: function(item) {\r\n\t\t\t\r\n\t\t\tvar xStart = item.xStart;\r\n\t\t\tvar yStart = item.yStart;\r\n\t\t\tvar xEnd = item.xEnd;\r\n\t\t\tvar yEnd = item.yEnd;\r\n\t\t\r\n\t\t\t// let's check the rcMatrix mode we're in:\r\n\t\t\tif(this.growY) {\r\n\t\t\t\t\r\n\t\t\t\t// add rows as necessary\r\n\t\t\t\tthis.ensureRows(yEnd);\r\n\t\t\t\t\r\n\t\t\t\t// walk through rows\r\n\t\t\t\tfor(var y = yStart; y<yEnd; y++) {\r\n\t\t\t\t\r\n\t\t\t\t\t// add columns as necessary\r\n\t\t\t\t\tif(this.rcMatrix[y].length < xEnd-1) {\r\n\t\t\t\t\t\tthis.rcMatrix[y].length = xEnd-1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// walk through columns\r\n\t\t\t\t\tfor(var x = xStart; x<xEnd; x++) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// the cell is occupied\r\n\t\t\t\t\t\tthis.rcMatrix[y][x] = item;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// add columns as necessary\r\n\t\t\t\tthis.ensureColumns(xEnd);\r\n\t\t\t\t\r\n\t\t\t\t// walk through rows\r\n\t\t\t\tfor(var x = xStart; x<xEnd; x++) {\r\n\t\t\t\t\r\n\t\t\t\t\t// add rows as necessary\r\n\t\t\t\t\tif(this.rcMatrix[x].length < yEnd-1) {\r\n\t\t\t\t\t\tthis.rcMatrix[x].length = yEnd-1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// walk through rows\r\n\t\t\t\t\tfor(var y = yStart; y<yEnd; y++) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// the cell is occupied\r\n\t\t\t\t\t\tthis.rcMatrix[x][y] = item;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tpullSubgridItemsFrom: function*(item, i=undefined, fragment=undefined) {\r\n\r\n\t\t\t// Compute \"i\" if it wasn't given\r\n\t\t\tif(i === undefined) {\r\n\t\t\t\ti = this.items.indexOf(item);\r\n\t\t\t}\r\n\t\t\tif(i < 0 || i >= this.items.length || this.items[i] !== item) {\r\n\t\t\t\tthrow new Error(\"INVALID ARGUMENT: item and i do not match (in pullSubgridItemsFrom)\");\r\n\t\t\t}\r\n\r\n\t\t\t// first, do we need to pull items in the first place\r\n\t\t\tif(item.element.styleMap.getPropertyValue(\"display\") == \"layout(grid)\") {\r\n\r\n\t\t\t\t// layout the item to find out the subitems\r\n\t\t\t\t// TODO: maybe try to provide accurate sizes and don't relayout if not needed?\r\n\t\t\t\tvar layoutResult = fragment; if(!fragment) {\r\n\t\t\t\t\tlayoutResult = yield item.element.layoutNextFragment({\r\n\t\t\t\t\t\tdata: {\r\n\t\t\t\t\t\t\tparentGridData: {\r\n\t\t\t\t\t\t\t\tspannedGridColumns: Array.from(new Array(item.xEnd-item.xStart)).map(v=>'min-content').join(' ')+'',\r\n\t\t\t\t\t\t\t\tspannedGridRows: Array.from(new Array(item.yEnd-item.yStart)).map(v=>'min-content').join(' ')+''\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar subItems = [];\r\n\t\t\t\tif(layoutResult.data && layoutResult.data.dataForParentGrid) {\r\n\t\t\t\t\tsubItems = layoutResult.data.dataForParentGrid.items.map(subitem => {\r\n\r\n\t\t\t\t\t\t// try to coerce the subitem into a GridItem\r\n\t\t\t\t\t\tsubitem.__proto__ = GridItem;\r\n\r\n\t\t\t\t\t\t// save the item's positioning inside the subgrid\r\n\t\t\t\t\t\tsubitem.specifiedXStart = new GridItemPosition(LOCATE_SUBGRID, item, subitem.xStart);\r\n\t\t\t\t\t\tsubitem.specifiedXEnd = new GridItemPosition(LOCATE_SUBGRID, item, subitem.xEnd);\r\n\t\t\t\t\t\tsubitem.specifiedYStart = new GridItemPosition(LOCATE_SUBGRID, item, subitem.yStart);\r\n\t\t\t\t\t\tsubitem.specifiedYEnd = new GridItemPosition(LOCATE_SUBGRID, item, subitem.yEnd);\r\n\r\n\t\t\t\t\t\t// offset the subitem's position by the subgrid's position\r\n\t\t\t\t\t\tsubitem.xStart += item.xStart;\r\n\t\t\t\t\t\tsubitem.xEnd += item.xStart;\r\n\t\t\t\t\t\tsubitem.yStart += item.yStart;\r\n\t\t\t\t\t\tsubitem.yEnd += item.yStart;\r\n\r\n\t\t\t\t\t\t// constraints the subitem's position within the subgrid's grid\r\n\t\t\t\t\t\t// (this is necessary because we won't call markAsOccupied on them, so we don't enforce track creation)\r\n\t\t\t\t\t\tsubitem.xStart = Math.max(item.xStart, Math.min(item.xEnd-1, subitem.xStart));\r\n\t\t\t\t\t\tsubitem.xEnd   = Math.max(item.xStart, Math.min(item.xEnd-0, subitem.xEnd));\r\n\t\t\t\t\t\tsubitem.yStart = Math.max(item.yStart, Math.min(item.yEnd-1, subitem.yStart));\r\n\t\t\t\t\t\tsubitem.yEnd   = Math.max(item.yStart, Math.min(item.yEnd-0, subitem.yEnd));\r\n\r\n\t\t\t\t\t\t// add margin to the item if it needs to absorb from the subgrid\r\n\t\t\t\t\t\tif(subitem.specifiedXStart.index == 0) {\r\n\t\t\t\t\t\t\t// first column, add [mpb]-left to the margin\r\n\t\t\t\t\t\t\tlet increment = item.hlMargin + item.hlPadding + item.hlBorder;\r\n\t\t\t\t\t\t\tsubitem.hlMargin += increment;\r\n\t\t\t\t\t\t\tsubitem.hMargins += increment;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(subitem.specifiedXEnd.index == item.xEnd-item.xStart) {\r\n\t\t\t\t\t\t\t// last column, add [mpb]-right to the margin\r\n\t\t\t\t\t\t\tlet increment = item.hrMargin + item.hrPadding + item.hrBorder;\r\n\t\t\t\t\t\t\tsubitem.hrMargin += increment;\r\n\t\t\t\t\t\t\tsubitem.hMargins += increment;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(subitem.specifiedYStart.index == 0) {\r\n\t\t\t\t\t\t\t// first row, add [mpb]-top to the margin\r\n\t\t\t\t\t\t\tlet increment = item.vtMargin + item.vtPadding + item.vtBorder;\r\n\t\t\t\t\t\t\tsubitem.vtMargin += increment;\r\n\t\t\t\t\t\t\tsubitem.vMargins += increment;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(subitem.specifiedYEnd.index == item.yEnd-item.yStart) {\r\n\t\t\t\t\t\t\t// last row, add [mpb]-bottom to the margin\r\n\t\t\t\t\t\t\tlet increment = item.vbMargin + item.vbPadding + item.vbBorder;\r\n\t\t\t\t\t\t\tsubitem.vbMargin += increment;\r\n\t\t\t\t\t\t\tsubitem.vMargins += increment;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// TODO: is there any other data that need to be revived?\r\n\r\n\t\t\t\t\t\treturn subitem;\r\n\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// append the newly found items\r\n\t\t\t\tif(subItems.length > 0) {\r\n\t\t\t\t\tthis.items.splice(i+1, 0, ...subItems);\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\t\t\r\n\t\tpositionNonAutoItems: function*() {\r\n\t\t\t\r\n\t\t\tfor(var i=0, l=this.items.length; i<l; i++) {\r\n\t\t\t\tvar item = this.items[i];\r\n\t\t\t\t\r\n\t\t\t\t// if the element has a specific column associated to it\r\n\t\t\t\tif(item.specifiedXStart.type == LOCATE_LINE) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if the element has a specified row associated to it\r\n\t\t\t\t\tif(item.specifiedYStart.type == LOCATE_LINE) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find the start position (x axis)\r\n\t\t\t\t\t\tvar xStart = this.findXStart(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find the start position (y axis)\r\n\t\t\t\t\t\tvar yStart = this.findYStart(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find the end position (x axis)\r\n\t\t\t\t\t\tvar xEnd = this.findXEnd(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find the end position (y axis)\r\n\t\t\t\t\t\tvar yEnd = this.findYEnd(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// we're done! this is so cool!\r\n\t\t\t\t\t\titem.xStart = xStart;\r\n\t\t\t\t\t\titem.yStart = yStart;\r\n\t\t\t\t\t\titem.xEnd = xEnd;\r\n\t\t\t\t\t\titem.yEnd = yEnd;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// we should fill the explicit matrix now!\r\n\t\t\t\t\t\tthis.markAsOccupied(item);\r\n\r\n\t\t\t\t\t\t// if the item is a subgrid, we should pull its subitems now\r\n\t\t\t\t\t\tyield* this.pullSubgridItemsFrom(item, i);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tpositionAutoInColumnOnlyItems: function*() {\r\n\t\t\t\r\n\t\t\tif(this.growY) {\r\n\t\t\t\t\r\n\t\t\t\tfor(var i=0, l=this.items.length; i<l; i++) {\r\n\t\t\t\t\tvar item = this.items[i];\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if the element has a specified row associated to it, but is not positioned yet\r\n\t\t\t\t\tif(item.specifiedYStart.type == LOCATE_LINE && (item.yStart==-1)) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find the start position (y axis)\r\n\t\t\t\t\t\tvar yStart = this.findYStart(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find the end position (y axis)\r\n\t\t\t\t\t\tvar yEnd = this.findYEnd(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// assumption: X is either AUTO + SPAN or AUTO + AUTO\r\n\t\t\t\t\t\tvar spanX = 1;\r\n\t\t\t\t\t\tif(item.specifiedXEnd.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\t\tif(item.specifiedXEnd.name === undefined) {\r\n\t\t\t\t\t\t\t\t// The span is defined as this value\r\n\t\t\t\t\t\t\t\tspanX = item.specifiedXEnd.index;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\r\n\t\t\t\t\t\t\t\tspanX = 1; console.error('[CSS-GRID] UNSUPPORTED: grid-row/column: auto / span [0-9]+ [A-Z]+');\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// add rows as necessary\r\n\t\t\t\t\t\tthis.ensureRows(yEnd);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// walk through columns to find a suitable position\r\n\t\t\t\t\t\tIncrementalColumnAttempts: for(var sx = 0;;sx++) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tfor(var x = sx+spanX-1; x>=sx; x--) {\r\n\t\t\t\t\t\t\t\tfor(var y = yStart; y<yEnd; y++) {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// if the cell is occupied\r\n\t\t\t\t\t\t\t\t\tif(this.rcMatrix[y][x]) {\r\n\t\t\t\t\t\t\t\t\t\tcontinue IncrementalColumnAttempts;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar xStart = sx;\r\n\t\t\t\t\t\tvar xEnd = sx+spanX;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// we're done! this is so cool dude!\r\n\t\t\t\t\t\titem.xStart = xStart;\r\n\t\t\t\t\t\titem.yStart = yStart;\r\n\t\t\t\t\t\titem.xEnd = xEnd;\r\n\t\t\t\t\t\titem.yEnd = yEnd;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// we should fill the explicit matrix now!\r\n\t\t\t\t\t\tthis.markAsOccupied(item);\r\n\r\n\t\t\t\t\t\t// if the item is a subgrid, we should pull its subitems now\r\n\t\t\t\t\t\tyield* this.pullSubgridItemsFrom(item, i);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\tfor(var i=0, l=this.items.length; i<l; i++) {\r\n\t\t\t\t\tvar item = this.items[i];\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if the element has a specified column associated to it, but is not positioned yet\r\n\t\t\t\t\tif(item.specifiedXStart.type == LOCATE_LINE && (item.xStart==-1)) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find the start position (x axis)\r\n\t\t\t\t\t\tvar xStart = this.findXStart(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find the end position (x axis)\r\n\t\t\t\t\t\tvar xEnd = this.findXEnd(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// assumption: Y is either AUTO + SPAN or AUTO + AUTO\r\n\t\t\t\t\t\tvar spanY = 1;\r\n\t\t\t\t\t\tif(item.specifiedYEnd.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\t\tif(item.specifiedYEnd.name === undefined) {\r\n\t\t\t\t\t\t\t\t// The span is defined as this value\r\n\t\t\t\t\t\t\t\tspanY = item.specifiedYEnd.index;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\r\n\t\t\t\t\t\t\t\tspanY = 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// add rows as necessary\r\n\t\t\t\t\t\tthis.ensureColumns(xEnd);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// walk through columns to find a suitable position\r\n\t\t\t\t\t\tIncrementalRowAttempts: for(var sy = 0;;sy++) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tfor(var y = sy+spanY-1; y>=sy; y--) {\r\n\t\t\t\t\t\t\t\tfor(var x = xStart; x<xEnd; x++) {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// if the cell is occupied\r\n\t\t\t\t\t\t\t\t\tif(this.rcMatrix[x][y]) {\r\n\t\t\t\t\t\t\t\t\t\tcontinue IncrementalRowAttempts;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar yStart = sy;\r\n\t\t\t\t\t\tvar yEnd = sy+spanY;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// we're done! this is so cool!\r\n\t\t\t\t\t\titem.xStart = xStart;\r\n\t\t\t\t\t\titem.yStart = yStart;\r\n\t\t\t\t\t\titem.xEnd = xEnd;\r\n\t\t\t\t\t\titem.yEnd = yEnd;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// we should fill the explicit matrix now!\r\n\t\t\t\t\t\tthis.markAsOccupied(item);\r\n\r\n\t\t\t\t\t\t// if the item is a subgrid, we should pull its subitems now\r\n\t\t\t\t\t\tyield* this.pullSubgridItemsFrom(item, i);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\t\r\n\t\tautoGrow: function() {\r\n\t\t\t\r\n\t\t\t// helpers\r\n\t\t\tvar growX = function(index) {\r\n\t\t\t\twhile(index >= this.xLines.length) {\r\n\t\t\t\t\tthis.xLines.push(['*']);\r\n\t\t\t\t\tthis.xSizes.push(this.defaultXSize);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar growY = function(index) {\r\n\t\t\t\twhile(index >= this.yLines.length) {\r\n\t\t\t\t\tthis.yLines.push(['*']);\r\n\t\t\t\t\tthis.ySizes.push(this.defaultYSize);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// reset the lines to the specified ones if necessary\r\n\t\t\tthis.resetLinesToSpecified(); // TODO: why?\r\n\t\t\t\r\n\t\t\t// ensure there's at least one cell\r\n\t\t\tgrowX.call(this,1); growY.call(this,1);\r\n\t\t\t\r\n\t\t\t// check if an item is explicitly positioned outside the explicit grid, and expand it if needed\r\n\t\t\tfor(var i = this.items.length; i--;) {\r\n\t\t\t\t\r\n\t\t\t\tvar item = this.items[i];\r\n\t\t\t\t\r\n\t\t\t\t// CONSIDER: items already positioned\r\n\t\t\t\tif(item.xEnd > 0) { growX.call(this,item.xEnd); }\r\n\t\t\t\tif(item.yEnd > 0) { growY.call(this,item.yEnd); }\r\n\t\t\t\tif(item.xEnd > 0 && item.yEnd > 0) { continue; }\r\n\t\t\t\t\r\n\t\t\t\t// CONSIDER: elements with a known location\r\n\t\t\t\t\r\n\t\t\t\t// (x axis):\r\n\t\t\t\tif(item.specifiedXEnd.type == LOCATE_LINE || item.specifiedXStart.type == LOCATE_LINE) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar xStart = this.findXStart(item);\r\n\t\t\t\t\tvar xEnd = this.findXEnd(item);\r\n\t\t\t\t\tgrowX.call(this,xEnd);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// (y axis):\r\n\t\t\t\tif(item.specifiedYEnd.type == LOCATE_LINE || item.specifiedYStart.type == LOCATE_LINE) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar yStart = this.findYStart(item);\r\n\t\t\t\t\tvar yEnd = this.findYEnd(item);\r\n\t\t\t\t\tif(yEnd <= yStart) { yEnd = yStart+1; }\r\n\t\t\t\t\tgrowY.call(this,yEnd);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// CONSIDER: known spans\r\n\t\t\t\t// // NOTE: I don't support \"grid-row/column-start: span X\";\r\n\t\t\t\tif(item.specifiedXEnd.type == LOCATE_SPAN && item.specifiedXEnd.name===undefined) {\r\n\t\t\t\t\tgrowX.call(this,item.specifiedXEnd.index);\r\n\t\t\t\t}\r\n\t\t\t\tif(item.specifiedYEnd.type == LOCATE_SPAN && item.specifiedYEnd.name===undefined) {\r\n\t\t\t\t\tgrowY.call(this,item.specifiedYEnd.index);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// grow the grid matrix:\r\n\t\t\tif(this.growY) {\r\n\t\t\t\twhile(this.ySizes.length>this.rcMatrix.length) {\r\n\t\t\t\t\tthis.rcMatrix.push([]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(var r=this.rcMatrix.length; r--;) {\r\n\t\t\t\t\tthis.rcMatrix[r].length = this.xSizes.length;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\twhile(this.xSizes.length>this.rcMatrix.length) {\r\n\t\t\t\t\tthis.rcMatrix.push([]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(var r=this.rcMatrix.length; r--;) {\r\n\t\t\t\t\tthis.rcMatrix[r].length = this.ySizes.length;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tperformLayout: function*() {\r\n\t\t\r\n\t\t\t// process non-automatic items\r\n\t\t\tyield* this.buildImplicitMatrix();\r\n\r\n\t\t\t// position the remaining grid items. \r\n\t\t\tvar cursor = { x: 0, y: 0 };\r\n\r\n\t\t\tif(this.growY) {\r\n\t\t\t\t\r\n\t\t\t\t//For each grid item that hasn't been positioned by the previous steps, in order-modified document order:\r\n\t\t\t\tfor(var i=0; i<this.items.length; i++) {\r\n\t\t\t\t\tvar item = this.items[i]; if(item.xEnd!=-1 && item.yEnd!=-1) { continue; }\r\n\t\t\t\t\t\r\n\t\t\t\t\t// reset the cursor if the algorithm is set to 'dense'\r\n\t\t\t\t\tif(this.growDense) { cursor = { x: 0, y: 0 }; }\r\n\t\t\t\t\t\r\n\t\t\t\t\t//If the item has a definite column position: \r\n\t\t\t\t\tif(item.specifiedXStart.type == LOCATE_LINE) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// 1. Set the column position of the cursor to be equal to the inline-start index of the grid item. \r\n\t\t\t\t\t\tvar xStart = this.findXStart(item); if(cursor.x > xStart) { cursor.y++; } cursor.x = xStart;\r\n\t\t\t\t\t\tvar xEnd = this.findXEnd(item); if(xStart>=xEnd) { xEnd=xStart+1}\r\n\t\t\t\t\t\titem.xStart=xStart; item.xEnd=xEnd;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// assumption: Y is either AUTO + SPAN or AUTO + AUTO\r\n\t\t\t\t\t\tvar spanY = 1;\r\n\t\t\t\t\t\tif(item.specifiedYEnd.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\t\tif(item.specifiedYEnd.name === undefined) {\r\n\t\t\t\t\t\t\t\t// The span is defined as this value\r\n\t\t\t\t\t\t\t\tspanY = item.specifiedYEnd.index;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\r\n\t\t\t\t\t\t\t\tspanY = 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// 2. Increment the auto-placement cursor's row position until a value is found where the grid item does not overlap any occupied grid cells (creating new rows in the implicit grid as necessary).\r\n\t\t\t\t\t\tIncrementalRowAttempts: while(true) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// make room for the currently attempted position\r\n\t\t\t\t\t\t\tthis.ensureRows(cursor.y+spanY);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// check the non-overlap condition\r\n\t\t\t\t\t\t\tfor(var y = cursor.y+spanY-1; y>=cursor.y; y--) {\r\n\t\t\t\t\t\t\t\tfor(var x = xStart; x<xEnd; x++) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// if the cell is occupied\r\n\t\t\t\t\t\t\t\t\tif(this.rcMatrix[y][x]) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// move to the next row\r\n\t\t\t\t\t\t\t\t\t\tcursor.y=y+1; continue IncrementalRowAttempts;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// settle the position\r\n\t\t\t\t\t\titem.xStart = xStart;\r\n\t\t\t\t\t\titem.xEnd = xEnd;\r\n\t\t\t\t\t\titem.yStart = cursor.y;\r\n\t\t\t\t\t\titem.yEnd = cursor.y+spanY;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tthis.markAsOccupied(item);\r\n\r\n\t\t\t\t\t\t// if the item is a subgrid, we should pull its subitems now\r\n\t\t\t\t\t\tyield* this.pullSubgridItemsFrom(item, i);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else { // If the item has an automatic grid position in both axes: \r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// assumption: X is either AUTO + SPAN or AUTO + AUTO\r\n\t\t\t\t\t\tvar spanX = 1;\r\n\t\t\t\t\t\tif(item.specifiedXEnd.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\t\tif(item.specifiedXEnd.name === undefined) {\r\n\t\t\t\t\t\t\t\t// The span is defined as this value\r\n\t\t\t\t\t\t\t\tspanX = item.specifiedXEnd.index;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\r\n\t\t\t\t\t\t\t\tspanX = 1; console.error('[CSS-GRID] UNSUPPORTED: grid-row/column: auto / span [0-9]+ [A-Z]+');\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// assumption: Y is either AUTO + SPAN or AUTO + AUTO\r\n\t\t\t\t\t\tvar spanY = 1;\r\n\t\t\t\t\t\tif(item.specifiedYEnd.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\t\tif(item.specifiedYEnd.name === undefined) {\r\n\t\t\t\t\t\t\t\t// The span is defined as this value\r\n\t\t\t\t\t\t\t\tspanY = item.specifiedYEnd.index;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\r\n\t\t\t\t\t\t\t\tspanY = 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Increment the auto-placement cursor's row/column position (creating new rows in the implicit grid as necessary)\r\n\t\t\t\t\t\tvar nextStep = function() {\r\n\t\t\t\t\t\t\tcursor.x++; if(cursor.x+spanX>this.rcMatrix[0].length) { cursor.y++; this.ensureRows(cursor.y + spanY); cursor.x=0; }\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// 1. Increment the column position of the auto-placement cursor until this item's grid area does not overlap any occupied grid cells\r\n\t\t\t\t\t\tIncrementalYXPositionAttempts: while(true) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// make room for the currently attempted position\r\n\t\t\t\t\t\t\tthis.ensureRows(cursor.y+spanY);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// check the non-overlap condition\r\n\t\t\t\t\t\t\tfor(var y = cursor.y+spanY-1; y>=cursor.y; y--) {\r\n\t\t\t\t\t\t\t\tfor(var x = cursor.x+spanX-1; x>=cursor.x; x--) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// if the cell is occupied\r\n\t\t\t\t\t\t\t\t\tif(this.rcMatrix[y][x]) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// move to the next row/column\r\n\t\t\t\t\t\t\t\t\t\tnextStep.call(this); continue IncrementalYXPositionAttempts;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// settle the position\r\n\t\t\t\t\t\titem.xStart = cursor.x;\r\n\t\t\t\t\t\titem.xEnd = cursor.x+spanX;\r\n\t\t\t\t\t\titem.yStart = cursor.y;\r\n\t\t\t\t\t\titem.yEnd = cursor.y+spanY;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tthis.markAsOccupied(item);\r\n\r\n\t\t\t\t\t\t// if the item is a subgrid, we should pull its subitems now\r\n\t\t\t\t\t\tyield* this.pullSubgridItemsFrom(item, i);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t//For each grid item that hasn't been positioned by the previous steps, in order-modified document order:\r\n\t\t\t\tfor(var i=0; i<this.items.length; i++) {\r\n\t\t\t\t\tvar item = this.items[i]; if(item.xEnd!=-1 && item.yEnd!=-1) { continue; }\r\n\t\t\t\t\t\r\n\t\t\t\t\t// reset the cursor if the algorithm is set to 'dense'\r\n\t\t\t\t\tif(this.growDense) { cursor = { x: 0, y: 0 }; }\r\n\t\t\t\t\t\r\n\t\t\t\t\t//If the item has a definite row position: \r\n\t\t\t\t\tif(item.specifiedYStart.type == LOCATE_LINE) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// 1. Set the column position of the cursor to be equal to the inline-start index of the grid item. \r\n\t\t\t\t\t\tvar yStart = this.findYStart(item); if(cursor.y > yStart) { cursor.x++; } cursor.y = yStart;\r\n\t\t\t\t\t\tvar yEnd = this.findYEnd(item); if(yStart>=yEnd) { yEnd=yStart+1}\r\n\t\t\t\t\t\titem.yStart=yStart; item.yEnd=yEnd;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// assumption: X is either AUTO + SPAN or AUTO + AUTO\r\n\t\t\t\t\t\tvar spanX = 1;\r\n\t\t\t\t\t\tif(item.specifiedXEnd.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\t\tif(item.specifiedXEnd.name === undefined) {\r\n\t\t\t\t\t\t\t\t// The span is defined as this value\r\n\t\t\t\t\t\t\t\tspanX = item.specifiedXEnd.index;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\r\n\t\t\t\t\t\t\t\tspanX = 1; console.error('[CSS-GRID] UNSUPPORTED: grid-row/column: auto / span [0-9]+ [A-Z]+');\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// 2. Increment the auto-placement cursor's row position until a value is found where the grid item does not overlap any occupied grid cells (creating new rows in the implicit grid as necessary).\r\n\t\t\t\t\t\tIncrementalColumnAttempts: while(true) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// make room for the currently attempted position\r\n\t\t\t\t\t\t\tthis.ensureColumns(cursor.x+spanX);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// check the non-overlap condition\r\n\t\t\t\t\t\t\tfor(var x = cursor.x+spanX-1; x>=cursor.x; x--) {\r\n\t\t\t\t\t\t\t\tfor(var y = yStart; y<yEnd; y++) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// if the cell is occupied\r\n\t\t\t\t\t\t\t\t\tif(this.rcMatrix[x][y]) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// move to the next row\r\n\t\t\t\t\t\t\t\t\t\tcursor.x=x+1; continue IncrementalColumnAttempts;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// settle the position\r\n\t\t\t\t\t\titem.yStart = yStart;\r\n\t\t\t\t\t\titem.yEnd = yEnd;\r\n\t\t\t\t\t\titem.xStart = cursor.x;\r\n\t\t\t\t\t\titem.yEnd = cursor.x+spanX;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tthis.markAsOccupied(item);\r\n\r\n\t\t\t\t\t\t// if the item is a subgrid, we should pull its subitems now\r\n\t\t\t\t\t\tyield* this.pullSubgridItemsFrom(item, i);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else { // If the item has an automatic grid position in both axes: \r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// assumption: Y is either AUTO + SPAN or AUTO + AUTO\r\n\t\t\t\t\t\tvar spanY = 1;\r\n\t\t\t\t\t\tif(item.specifiedYEnd.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\t\tif(item.specifiedYEnd.name === undefined) {\r\n\t\t\t\t\t\t\t\t// The span is defined as this value\r\n\t\t\t\t\t\t\t\tspanY = item.specifiedYEnd.index;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\r\n\t\t\t\t\t\t\t\tspanY = 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// assumption: X is either AUTO + SPAN or AUTO + AUTO\r\n\t\t\t\t\t\tvar spanX = 1;\r\n\t\t\t\t\t\tif(item.specifiedXEnd.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\t\tif(item.specifiedXEnd.name === undefined) {\r\n\t\t\t\t\t\t\t\t// The span is defined as this value\r\n\t\t\t\t\t\t\t\tspanX = item.specifiedXEnd.index;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\r\n\t\t\t\t\t\t\t\tspanX = 1; console.error('[CSS-GRID] UNSUPPORTED: grid-row/column: auto / span [0-9]+ [A-Z]+');\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Increment the auto-placement cursor's row/column position (creating new rows in the implicit grid as necessary)\r\n\t\t\t\t\t\tvar nextStep = function() {\r\n\t\t\t\t\t\t\tcursor.y++; if(cursor.y+spanY>this.rcMatrix[0].length) { cursor.x++; this.ensureRows(cursor.x + spanX); cursor.y=0; }\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// 1. Increment the column position of the auto-placement cursor until this item's grid area does not overlap any occupied grid cells\r\n\t\t\t\t\t\tIncrementalXYPositionAttempts: while(true) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// make room for the currently attempted position\r\n\t\t\t\t\t\t\tthis.ensureColumns(cursor.x+spanX);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// check the non-overlap condition\r\n\t\t\t\t\t\t\tfor(var x = cursor.x+spanX-1; x>=cursor.x; x--) {\r\n\t\t\t\t\t\t\t\tfor(var y = cursor.y+spanY-1; y>=cursor.y; y--) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// if the cell is occupied\r\n\t\t\t\t\t\t\t\t\tif(this.rcMatrix[x][y]) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// move to the next row/column\r\n\t\t\t\t\t\t\t\t\t\tnextStep.call(this); continue IncrementalXYPositionAttempts;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// settle the position\r\n\t\t\t\t\t\titem.xStart = cursor.x;\r\n\t\t\t\t\t\titem.xEnd = cursor.x+spanX;\r\n\t\t\t\t\t\titem.yStart = cursor.y;\r\n\t\t\t\t\t\titem.yEnd = cursor.y+spanY;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tthis.markAsOccupied(item);\r\n\r\n\t\t\t\t\t\t// if the item is a subgrid, we should pull its subitems now\r\n\t\t\t\t\t\tyield* this.pullSubgridItemsFrom(item, i);\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\tyield* this.computeAbsoluteTrackBreadths();\r\n\r\n\t\t\t//\r\n\t\t\t// position all the fragments\r\n\t\t\t//\r\n\r\n\t\t\tvar xSizes = this.finalXSizes;\r\n\t\t\tvar ySizes = this.finalYSizes;\r\n\r\n\t\t\tvar gridWidth = 0, gridHeight = 0;\r\n\t\t\tfor(var x = 0; x<xSizes.length; x++) {\r\n\t\t\t\tgridWidth += xSizes[x].breadth;\r\n\t\t\t}\r\n\t\t\tfor(var y = 0; y<ySizes.length; y++) {\r\n\t\t\t\tgridHeight += ySizes[y].breadth;\r\n\t\t\t}\r\n\t\t\tthis.gridWidth = gridWidth;\r\n\t\t\tthis.gridHeight = gridHeight;\r\n\r\n\t\t\tvar width = 0; var height = 0;\r\n\t\t\tvar items_widths = []; var items_heights = []; \r\n\t\t\titems_widths.length = items_heights.length = this.items.length;\r\n\r\n\t\t\tfor(var i=this.items.length; i--;) { var item = this.items[i]; \r\n\r\n\t\t\t\tvar left = this.hlPadding;\r\n\t\t\t\tfor(var x = 0; x<item.xStart; x++) {\r\n\t\t\t\t\tleft += xSizes[x].breadth;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar top = this.vtPadding;\r\n\t\t\t\tfor(var y = 0; y<item.yStart; y++) {\r\n\t\t\t\t\ttop += ySizes[y].breadth;\r\n\t\t\t\t}\r\n\r\n\t\t\t\titem.fragment.inlineOffset = left + item.hlMargin;\r\n\t\t\t\titem.fragment.blockOffset = top + item.vtMargin;\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\t\t\r\n\t\tcomputeAbsoluteTrackBreadths: function*() {\r\n\t\t\r\n\t\t\tvar LIMIT_IS_INFINITE = 1;\t\t\r\n\t\t\tvar infinity = 9999999.0;\r\n\t\t\tvar fullWidth = this.element.fixedInlineSize != null ? this.element.fixedInlineSize - this.hPaddings : infinity;\r\n\t\t\tvar fullHeight = this.element.fixedBlockSize != null ? this.element.fixedBlockSize - this.vPaddings : 0; // fixedBlockSize is null if no height is defined\r\n\t\t\t\r\n\t\t\t// \r\n\t\t\t// 10.3  Initialize Track Sizes\r\n\t\t\t// \r\n\t\t\tvar initializeFromConstraints = function(v) {\r\n\t\t\t\t\r\n\t\t\t\tvar base = 0, limit = infinity;\r\n\t\t\t\tswitch(v.minType) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// For fixed track sizes, resolve to an absolute length and use that size. \r\n\t\t\t\t\tcase TRACK_BREADTH_LENGTH:      base = v.minValue; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_PERCENTAGE:  base = v.minValue*fullSize/100; break;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tswitch(v.maxType) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// For fixed track sizes, resolve to an absolute length and use that size. \r\n\t\t\t\t\tcase TRACK_BREADTH_LENGTH:      limit = v.minValue; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_PERCENTAGE:  limit = v.minValue*fullSize/100; break;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// For flexible track sizes, use the track's initial base size as its initial growth limit.  \r\n\t\t\t\t\tcase TRACK_BREADTH_FRACTION:    limit = base; break;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// For intrinsic track sizes, use an initial growth limit of infinity. \r\n\t\t\t\t\tdefault:                        limit = infinity; break;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn { base:base, limit:limit, breadth:0, flags:((limit==infinity)?LIMIT_IS_INFINITE:0)|0 };\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// Equal distribution algorithm\r\n\t\t\t//\r\n\t\t\tvar distributeEquallyAmongTracks = function distributeEquallyAmongTracks(xSizes, kind, tracks, spaceToDistribute, enforceLimit) {\r\n\t\t\t\t// Distribute space to base sizes\r\n\t\t\t\tvar trackAmount = tracks.length;\r\n\t\t\t\tvar spacePerTrack = spaceToDistribute/trackAmount;\r\n\t\t\t\tif(kind=='base') {\r\n\t\t\t\t\r\n\t\t\t\t\t// if we enforce the limit, grow up to the most limitating track\r\n\t\t\t\t\tif(enforceLimit) {\r\n\t\t\t\t\t\tfor(var t = tracks.length; t--;) { var cx = tracks[t].x;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// find the lowest acceptable increase for all tracks\r\n\t\t\t\t\t\t\tvar newBase = xSizes[cx].base + spacePerTrack;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// if limits are enfo\r\n\t\t\t\t\t\t\tif(enforceLimit && (xSizes[cx].flags & LIMIT_IS_INFINITE == 0) && newBase > xSizes[cx].limit) {\r\n\t\t\t\t\t\t\t\tspacePerTrack -= newBase - xSizes[cx].limit;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tfor(var t = tracks.length; t--;) { var cx = tracks[t].x;\r\n\t\t\t\t\t\txSizes[cx].base += spacePerTrack;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(kind == 'limit') {\r\n\t\t\t\t\r\n\t\t\t\t\t// Update the tracks' affected sizes by folding in the calculated increase so that the next round of space distribution will account for the increase.\r\n\t\t\t\t\tfor(var t = tracks.length; t--;) { var cx = tracks[t].x;\r\n\t\t\t\t\t\t// If the growth limit is infinite...\r\n\t\t\t\t\t\tif(xSizes[cx].flags & LIMIT_IS_INFINITE) {\r\n\t\t\t\t\t\t\t// set it to the track's base size plus the calculated increase\r\n\t\t\t\t\t\t\tif(xSizes[cx].limit == infinity) {\r\n\t\t\t\t\t\t\t\txSizes[cx].limit = xSizes[cx].base + spacePerTrack;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\txSizes[cx].limit += spacePerTrack; // TODO: THERE IS A BUG HERE ?\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// otherwise just increase the limit\r\n\t\t\t\t\t\t\txSizes[cx].limit += spacePerTrack;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t\r\n\t\t\t// \r\n\t\t\t// 10.4  Resolve Content-Based Track Sizing Functions\r\n\t\t\t// \r\n\t\t\tvar computeTrackBreadth = function(xSizes, specifiedSizes, getMinWidthOf, getMaxWidthOf, getXStartOf, getXEndOf) {\r\n\t\t\t\t\r\n\t\t\t\t// For each track\r\n\t\t\t\tvar items_done = 0; // items already consumed for this algorithm\r\n\t\t\t\tfor(var x = specifiedSizes.length; x--;) {\r\n\t\t\t\t\r\n\t\t\t\t\tvar dontCountMaxItems = false;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// If the track has a 'min-content' min track sizing function\r\n\t\t\t\t\tif(specifiedSizes[x].minType == TRACK_BREADTH_MIN_CONTENT || specifiedSizes[x].minType == TRACK_BREADTH_AUTO) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Consider the items in it with a span of 1: \r\n\t\t\t\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i]; var item_xStart = getXStartOf(item); var item_xEnd = getXEndOf(item);\r\n\t\t\t\t\t\t\tif(item_xStart>x || item_xEnd<=x || item_xEnd-item_xStart != 1) continue;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Set its base size to the maximum of the items' min-content contributions. \r\n\t\t\t\t\t\t\txSizes[x].base = Math.max(xSizes[x].base, getMinWidthOf(item)); items_done++; dontCountMaxItems=true;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// If the track has a 'max-content' min track sizing function\r\n\t\t\t\t\telse if(specifiedSizes[x].minType == TRACK_BREADTH_MAX_CONTENT) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Consider the items in it with a span of 1: \r\n\t\t\t\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i]; var item_xStart = getXStartOf(item); var item_xEnd = getXEndOf(item);\r\n\t\t\t\t\t\t\tif(item_xStart>x || item_xEnd<=x || item_xEnd-item_xStart != 1) continue;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Set its base size to the maximum of the items' max-content contributions. \r\n\t\t\t\t\t\t\txSizes[x].base = Math.max(xSizes[x].base, getMaxWidthOf(item)); items_done++; dontCountMaxItems=true;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// If the track has a 'min-content' max track sizing function\r\n\t\t\t\t\tif(specifiedSizes[x].maxType == TRACK_BREADTH_MIN_CONTENT) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Consider the items in it with a span of 1: \r\n\t\t\t\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i]; var item_xStart = getXStartOf(item); var item_xEnd = getXEndOf(item);\r\n\t\t\t\t\t\t\tif(item_xStart>x || item_xEnd<=x || item_xEnd-item_xStart != 1) continue;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Set its growth limit to the maximum of the items' min-content contributions. \r\n\t\t\t\t\t\t\tif(xSizes[x].limit == infinity) { xSizes[x].limit = getMinWidthOf(item); }\r\n\t\t\t\t\t\t\telse { xSizes[x].limit = Math.max(xSizes[x].limit, getMinWidthOf(item)); }\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif(!dontCountMaxItems) { items_done++; }\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} \r\n\t\t\t\t\t\r\n\t\t\t\t\t// If the track has a 'max-content' max track sizing function\r\n\t\t\t\t\telse if(specifiedSizes[x].maxType == TRACK_BREADTH_MAX_CONTENT || specifiedSizes[x].minType == TRACK_BREADTH_AUTO) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Consider the items in it with a span of 1: \r\n\t\t\t\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i]; var item_xStart = getXStartOf(item); var item_xEnd = getXEndOf(item);\r\n\t\t\t\t\t\t\tif(item_xStart>x || item_xEnd<=x || item_xEnd-item_xStart != 1) continue;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Set its growth limit to the maximum of the items' max-content contributions. \r\n\t\t\t\t\t\t\tif(xSizes[x].limit == infinity) { xSizes[x].limit = getMaxWidthOf(item); }\r\n\t\t\t\t\t\t\telse { xSizes[x].limit = Math.max(xSizes[x].limit, getMaxWidthOf(item)); }\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif(!dontCountMaxItems) { items_done++; }\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// update infinity flag\r\n\t\t\t\t\tif(xSizes[x].limit != infinity) {\r\n\t\t\t\t\t\txSizes[x].flags = xSizes[x].flags & ~LIMIT_IS_INFINITE;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// Next, consider the items with a span of 2 that do not span a track with a flexible sizing function: \r\n\t\t\t\t// Repeat incrementally for items with greater spans until all items have been considered.\r\n\t\t\t\tfor(var span = 2; items_done < this.items.length && span <= specifiedSizes.length; span++) {\r\n\t\t\t\t\tItemLoop: for(var i = this.items.length; i--;) { var item = this.items[i]; var item_xStart = getXStartOf(item); var item_xEnd = getXEndOf(item);\r\n\t\t\t\t\t\tif(item_xEnd-item_xStart != span) continue ItemLoop;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// gather some pieces of data about the tracks\r\n\t\t\t\t\t\tvar full_base = 0; var full_limit = 0;\r\n\t\t\t\t\t\tfor(var cx = item_xStart; cx<item_xEnd; cx++) { \r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// 1. we want to make sure none is flexible\r\n\t\t\t\t\t\t\tif(specifiedSizes[cx].maxType == TRACK_BREADTH_FRACTION) continue ItemLoop;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// 2. compute aggregated sizes\r\n\t\t\t\t\t\t\tfull_base += xSizes[cx].base;\r\n\t\t\t\t\t\t\tfull_limit += xSizes[cx].limit;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(full_limit > infinity) full_limit=infinity;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar distributeFreeSpace = function(requiredSpace, kind /*'base'|'limit'*/, target /*'min-content'|'max-content'*/) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\twhile (true) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// compute the required extra space\r\n\t\t\t\t\t\t\t\tvar spaceToDistribute = requiredSpace;\r\n\t\t\t\t\t\t\t\tfor(var cx = item_xStart; cx<item_xEnd; cx++) {\r\n\t\t\t\t\t\t\t\t\tspaceToDistribute -= xSizes[cx][kind];\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// if no space to distribute, just lock auto columns:\r\n\t\t\t\t\t\t\t\tif(spaceToDistribute <= 1/1024) { //due to double precision, this may never reach perfect 0\r\n\t\t\t\t\t\t\t\t\tfor(var cx = item_xStart; cx<item_xEnd; cx++) {\r\n\t\t\t\t\t\t\t\t\t\tif(xSizes[cx].limit == infinity) {\r\n\t\t\t\t\t\t\t\t\t\t\txSizes[cx].limit = xSizes[cx].base;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// sort rows by growth limit\r\n\t\t\t\t\t\t\t\tvar rows_and_limits = [];\r\n\t\t\t\t\t\t\t\tfor(var cx = item_xStart; cx<item_xEnd; cx++) {\r\n\t\t\t\t\t\t\t\t\trows_and_limits.push({ \r\n\t\t\t\t\t\t\t\t\t\tx:cx, \r\n\t\t\t\t\t\t\t\t\t\tbase:xSizes[cx].base,\r\n\t\t\t\t\t\t\t\t\t\tlimit:xSizes[cx].limit,\r\n\t\t\t\t\t\t\t\t\t\tminIsMinContent: specifiedSizes[cx].minType == TRACK_BREADTH_MIN_CONTENT || specifiedSizes[cx].minType == TRACK_BREADTH_AUTO,\r\n\t\t\t\t\t\t\t\t\t\tminIsMaxContent: specifiedSizes[cx].minType == TRACK_BREADTH_MAX_CONTENT,\r\n\t\t\t\t\t\t\t\t\t\tmaxIsMinContent: specifiedSizes[cx].maxType == TRACK_BREADTH_MIN_CONTENT,\r\n\t\t\t\t\t\t\t\t\t\tmaxIsMaxContent: specifiedSizes[cx].maxType == TRACK_BREADTH_MAX_CONTENT || specifiedSizes[cx].maxType == TRACK_BREADTH_AUTO\r\n\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\trows_and_limits.sort(function(a,b) { return a.limit-b.limit; });\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// remove non-affected tracks\r\n\t\t\t\t\t\t\t\trows_and_limits = rows_and_limits.filter(function(b) {\r\n\t\t\t\t\t\t\t\t\tif(kind=='base') {\r\n\t\t\t\t\t\t\t\t\t\tif(target=='min-content') {\r\n\t\t\t\t\t\t\t\t\t\t\treturn b.minIsMinContent||b.minIsMaxContent;\r\n\t\t\t\t\t\t\t\t\t\t} else if(target=='max-content') {\r\n\t\t\t\t\t\t\t\t\t\t\treturn b.minIsMaxContent;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t} else if (kind == 'limit') {\r\n\t\t\t\t\t\t\t\t\t\tif(target=='min-content') {\r\n\t\t\t\t\t\t\t\t\t\t\treturn b.maxIsMinContent||b.maxIsMaxContent;\r\n\t\t\t\t\t\t\t\t\t\t} else if(target=='max-content') {\r\n\t\t\t\t\t\t\t\t\t\t\treturn b.maxIsMaxContent;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// check that there is at least one affected track\r\n\t\t\t\t\t\t\t\tif(rows_and_limits.length == 0) { return; }\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// apply the algorithm\r\n\t\t\t\t\t\t\t\tif(kind=='base') {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// Distribute space up to growth limits\r\n\t\t\t\t\t\t\t\t\tvar tracks = rows_and_limits.filter(function(b) { return b.base<b.limit; }, 0);\r\n\t\t\t\t\t\t\t\t\tvar trackAmount = tracks.length;\r\n\t\t\t\t\t\t\t\t\tif(trackAmount > 0) {\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, kind, tracks, spaceToDistribute, /*enforceLimit:*/true);\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// Distribute space beyond growth limits\r\n\t\t\t\t\t\t\t\t\t\t// If space remains after all tracks are frozen, unfreeze and continue to distribute space to\r\n \r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// - when handling 'min-content' base sizes: \r\n\t\t\t\t\t\t\t\t\t\tif(target=='min-content') {\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t// any affected track that happens to also have an intrinsic max track sizing function; \r\n\t\t\t\t\t\t\t\t\t\t\tvar tracks = rows_and_limits.filter(function(b) { return b.maxIsMinContent||b.maxIsMaxContent; }, 0);\r\n\t\t\t\t\t\t\t\t\t\t\tvar trackAmount = tracks.length;\r\n\t\t\t\t\t\t\t\t\t\t\tif(trackAmount>=1) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t// (such tracks exist:)\r\n\t\t\t\t\t\t\t\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, kind, tracks, spaceToDistribute, /*enforceLimit:*/false);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t// if there are no such tracks, then all affected tracks. \r\n\t\t\t\t\t\t\t\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, kind, rows_and_limits, spaceToDistribute, /*enforceLimit:*/false);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// - when handling 'max-content' base sizes: \r\n\t\t\t\t\t\t\t\t\t\telse if(target=='max-content') {\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t// any affected track that happens to also have a 'max-content' max track sizing function;\r\n\t\t\t\t\t\t\t\t\t\t\tvar tracks = rows_and_limits.filter(function(b) { return b.maxIsMaxContent; }, 0);\r\n\t\t\t\t\t\t\t\t\t\t\tvar trackAmount = tracks.length;\r\n\t\t\t\t\t\t\t\t\t\t\tif(trackAmount>=1) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t// (such tracks exist:)\r\n\t\t\t\t\t\t\t\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, kind, tracks, spaceToDistribute, /*enforceLimit:*/false);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t// if there are no such tracks, then all affected tracks. \r\n\t\t\t\t\t\t\t\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, kind, rows_and_limits, spaceToDistribute, /*enforceLimit:*/false);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\telse if (kind == 'limit') {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// distribute among all tracks\r\n\t\t\t\t\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, kind, rows_and_limits, spaceToDistribute);\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar updateInfiniteLimitFlag = function() {\r\n\t\t\t\t\t\t\tfor(var x = xSizes.length; x--;) {\r\n\t\t\t\t\t\t\t\tif(xSizes[x].limit != infinity) {\r\n\t\t\t\t\t\t\t\t\txSizes[x].flags = xSizes[x].flags & ~LIMIT_IS_INFINITE;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t// 1. For intrinsic minimums: First increase the base size of tracks with a min track sizing function of 'min-content' or 'max-content' by distributing extra space as needed to account for these items' min-content contributions. \r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\tdistributeFreeSpace(getMinWidthOf(item), 'base', 'min-content');\r\n\t\t\t\t\t\tupdateInfiniteLimitFlag();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t// 2. For max-content minimums: Next continue to increase the base size of tracks with a min track sizing function of 'max-content' by distributing extra space as needed to account for these items' max-content contributions. \r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\tdistributeFreeSpace(getMaxWidthOf(item), 'base', 'max-content');\r\n\t\t\t\t\t\tupdateInfiniteLimitFlag();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t// 3. For intrinsic maximums: Third increase the growth limit of tracks with a max track sizing function of 'min-content' or 'max-content' by distributing extra space as needed to account for these items' min-content contributions. \r\n\t\t\t\t\t\t// Mark any tracks whose growth limit changed from infinite to finite in this step as infinitely growable for the next step. \r\n\t\t\t\t\t\t// (aka do not update infinity flag)\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\tdistributeFreeSpace(getMinWidthOf(item), 'limit', 'min-content');\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t// 4. For max-content maximums: Lastly continue to increase the growth limit of tracks with a max track sizing function of 'max-content' by distributing extra space as needed to account for these items' max-content contributions. \r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\tdistributeFreeSpace(getMaxWidthOf(item), 'limit', 'max-content');\r\n\t\t\t\t\t\tupdateInfiniteLimitFlag();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\titems_done++;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar computeTrackBreadthIncrease = function(xSizes, specifiedSizes, fullSize, getMinWidthOf, getMaxWidthOf, getXStartOf, getXEndOf) {\r\n\t\t\t\t\r\n\t\t\t\t// sort rows by growth limit\r\n\t\t\t\tvar rows_and_limits = xSizes.map(function(item, cx) { \r\n\t\t\t\t\treturn { \r\n\t\t\t\t\t\tx:cx, \r\n\t\t\t\t\t\tbase:xSizes[cx].base,\r\n\t\t\t\t\t\tlimit:xSizes[cx].limit,\r\n\t\t\t\t\t\tminIsMinContent: specifiedSizes[cx].minType == TRACK_BREADTH_MIN_CONTENT || specifiedSizes[cx].minType == TRACK_BREADTH_AUTO,\r\n\t\t\t\t\t\tminIsMaxContent: specifiedSizes[cx].minType == TRACK_BREADTH_MAX_CONTENT,\r\n\t\t\t\t\t\tmaxIsMinContent: specifiedSizes[cx].maxType == TRACK_BREADTH_MIN_CONTENT,\r\n\t\t\t\t\t\tmaxIsMaxContent: specifiedSizes[cx].maxType == TRACK_BREADTH_MAX_CONTENT || specifiedSizes[cx].maxType == TRACK_BREADTH_AUTO\r\n\t\t\t\t\t};\r\n\t\t\t\t});\r\n\t\t\t\trows_and_limits.sort(function(a,b) { return a.limit-b.limit; });\r\n\t\t\t\t\r\n\t\t\t\twhile(true) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// compute size to distribute\r\n\t\t\t\t\tvar spaceToDistribute = fullSize;\r\n\t\t\t\t\tfor(var cx = xSizes.length; cx--;) {\r\n\t\t\t\t\t\tspaceToDistribute -= xSizes[cx].base;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// check that there is some space to distribute\r\n\t\t\t\t\tif(spaceToDistribute <= 1/1024) { return; } // NOTE: the space may never become 0 due to a rounding issue\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Distribute space up to growth limits\r\n\t\t\t\t\tvar tracks = rows_and_limits = rows_and_limits.filter(function(b) { return ((b.minIsMinContent||b.minIsMaxContent) && b.base<b.limit); }, 0);\r\n\t\t\t\t\tvar trackAmount = tracks.length; if(trackAmount <= 0) { return; }\r\n\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, 'base', tracks, spaceToDistribute, /*enforceLimit:*/true);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar computeFlexibleTrackBreadth = function(xSizes, specifiedSizes, fullSize, getMinWidthOf, getMaxWidthOf, getXStartOf, getXEndOf) {\r\n\t\t\t\t\r\n\t\t\t\t// If the free space is an indefinite length: \r\n\t\t\t\tif(fullSize==0) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t//The used flex fraction is the maximum of: \r\n\t\t\t\t\tvar currentFraction = 0;\r\n\t\t\t\t\t\r\n\t\t\t\t\t//  Each flexible track's base size divided by its flex factor. \r\n\t\t\t\t\t'TODO: I believe this is completely useless, but CSSWG will not change it.';\r\n\t\t\t\t\t\r\n\t\t\t\t\t//  The result of finding the size of an fr for each grid item that crosses a flexible track, using all the grid tracks that the item crosses and a space to fill of the item's max-content contribution. \r\n\t\t\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i]; var item_xStart = getXStartOf(item); var item_xEnd = getXEndOf(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// gather some pieces of data about the tracks\r\n\t\t\t\t\t\tvar spaceToDistribute = getMaxWidthOf(item); var flexFactorSum = 0;\r\n\t\t\t\t\t\tfor(var cx = item_xStart; cx<item_xEnd; cx++) { \r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif(specifiedSizes[cx].maxType == TRACK_BREADTH_FRACTION) {\r\n\t\t\t\t\t\t\t\t// compute how much flexible tracks are required\r\n\t\t\t\t\t\t\t\tflexFactorSum += specifiedSizes[cx].maxValue;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// deduce non-flexible tracks from the space to distribute\r\n\t\t\t\t\t\t\t\tspaceToDistribute -= xSizes[cx].base;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// compute the minimum flex fraction for this item\r\n\t\t\t\t\t\tif(spaceToDistribute > 0 && flexFactorSum > 0) {\r\n\t\t\t\t\t\t\tcurrentFraction = Math.max(currentFraction, spaceToDistribute / flexFactorSum)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// for each flexible track\r\n\t\t\t\t\tfor(var x = xSizes.length; x--;) {\r\n\t\t\t\t\t\tif(specifiedSizes[x].maxType == TRACK_BREADTH_FRACTION) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Compute the product of the hypothetical flex fraction and the track's flex factor\r\n\t\t\t\t\t\t\tvar trackSize = currentFraction * specifiedSizes[x].maxValue;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// If that size is less than the track's base size:\r\n\t\t\t\t\t\t\tif(xSizes[x].base < trackSize) {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// set its base size to that product.\r\n\t\t\t\t\t\t\t\txSizes[x].breadth = trackSize;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\txSizes[x].breadth = xSizes[x].base;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\txSizes[x].breadth = xSizes[x].base;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t\t// compute the leftover space\r\n\t\t\t\t\tvar spaceToDistribute = fullSize;\r\n\t\t\t\t\tvar tracks = []; var fractionSum = 0;\r\n\t\t\t\t\tfor(var x = xSizes.length; x--;) {\r\n\t\t\t\t\t\tif(specifiedSizes[x].maxType == TRACK_BREADTH_FRACTION) {\r\n\t\t\t\t\t\t\ttracks.push(x); fractionSum += specifiedSizes[x].maxValue;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tspaceToDistribute -= (xSizes[x].breadth = xSizes[x].base);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// while there are flexible tracks to size\r\n\t\t\t\t\twhile(tracks.length>0) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Let the hypothetical flex fraction be the leftover space divided by the sum of the flex factors of the flexible tracks.\r\n\t\t\t\t\t\tvar currentFraction = spaceToDistribute / fractionSum; var restart = false;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// for each flexible track\r\n\t\t\t\t\t\tfor(var i = tracks.length; i--;) { var x = tracks[i];\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Compute the product of the hypothetical flex fraction and the track's flex factor\r\n\t\t\t\t\t\t\tvar trackSize = currentFraction * specifiedSizes[x].maxValue;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// If that size is less than the track's base size:\r\n\t\t\t\t\t\t\tif(xSizes[x].base < trackSize) {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// set its base size to that product.\r\n\t\t\t\t\t\t\t\txSizes[x].breadth = trackSize;\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// mark as non-flexible\r\n\t\t\t\t\t\t\t\txSizes[x].breadth = xSizes[x].base;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// remove from computation\r\n\t\t\t\t\t\t\t\tfractionSum -= specifiedSizes[x].maxValue;\r\n\t\t\t\t\t\t\t\ttracks.splice(i,1);\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// restart\r\n\t\t\t\t\t\t\t\trestart=true;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif(!restart) { tracks.length = 0; }\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar computeFinalTrackBreadth = function(xSizes, this_xSizes, fullWidth, getMinWidthOf, getMaxWidthOf, getXStartOf, getXEndOf) {\r\n\t\t\t\t\r\n\t\t\t\t// compute base and limit\r\n\t\t\t\tcomputeTrackBreadth.call(\r\n\t\t\t\t\tthis,\r\n\t\t\t\t\txSizes,\r\n\t\t\t\t\tthis_xSizes,\r\n\t\t\t\t\tgetMinWidthOf,\r\n\t\t\t\t\tgetMaxWidthOf,\r\n\t\t\t\t\tgetXStartOf,\r\n\t\t\t\t\tgetXEndOf\r\n\t\t\t\t);\r\n\t\t\t\t\r\n\t\t\t\t// ResolveContentBasedTrackSizingFunctions (step 4)\r\n\t\t\t\tfor(var x = this_xSizes.length; x--;) {\r\n\t\t\t\t\tif(xSizes[x].limit == infinity) { xSizes[x].limit = xSizes[x].base; }\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// grow tracks up to their max\r\n\t\t\t\tcomputeTrackBreadthIncrease.call(\r\n\t\t\t\t\tthis,\r\n\t\t\t\t\txSizes,\r\n\t\t\t\t\tthis_xSizes,\r\n\t\t\t\t\tfullWidth,\r\n\t\t\t\t\tgetMinWidthOf,\r\n\t\t\t\t\tgetMaxWidthOf,\r\n\t\t\t\t\tgetXStartOf,\r\n\t\t\t\t\tgetXEndOf\r\n\t\t\t\t);\r\n\t\t\t\t\r\n\t\t\t\t// handle flexible things\r\n\t\t\t\tcomputeFlexibleTrackBreadth.call(\r\n\t\t\t\t\tthis,\r\n\t\t\t\t\txSizes,\r\n\t\t\t\t\tthis_xSizes,\r\n\t\t\t\t\tfullWidth,\r\n\t\t\t\t\tgetMinWidthOf,\r\n\t\t\t\t\tgetMaxWidthOf,\r\n\t\t\t\t\tgetXStartOf,\r\n\t\t\t\t\tgetXEndOf\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar getSubgridTrackSizes = function(finalXSizes, hlMBP, hrMBP) {\r\n\t\t\t\treturn finalXSizes.slice(item.xStart, item.xEnd-item.xStart).map((b,i) => {\r\n\t\t\t\t\tvar breadth = b.breadth;\r\n\t\t\t\t\tif(i == 0) breadth -= hlMBP;\r\n\t\t\t\t\tif(i == finalXSizes.length-1) breadth -= hrMBP;\r\n\t\t\t\t\treturn breadth+'px';\r\n\t\t\t\t}).join(' ');\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t// compute breadth of columns\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\tvar mode = 'x';\r\n\t\t\tvar fullSize = fullWidth;\r\n\t\t\tvar xSizes = this.xSizes.map(initializeFromConstraints);\r\n\t\t\t\r\n\t\t\tvar getMinWidthOf = function(item) { return item.minWidth+item.hMargins; };\r\n\t\t\tvar getMaxWidthOf = function(item) { return item.maxWidth+item.hMargins; };\r\n\t\t\tvar getXStartOf = function(item) { return item.xStart; }; \r\n\t\t\tvar getXEndOf = function(item) { return item.xEnd; };\r\n\t\t\t\r\n\t\t\t// compute base and limit\r\n\t\t\tcomputeFinalTrackBreadth.call(\r\n\t\t\t\tthis,\r\n\t\t\t\txSizes,\r\n\t\t\t\tthis.xSizes,\r\n\t\t\t\tfullWidth,\r\n\t\t\t\tgetMinWidthOf,\r\n\t\t\t\tgetMaxWidthOf,\r\n\t\t\t\tgetXStartOf,\r\n\t\t\t\tgetXEndOf\r\n\t\t\t);\r\n\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t// save the results\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\tthis.finalXSizes = xSizes;\r\n\t\t\t\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t// position each element absolutely, and set width to compute height\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\r\n\t\t\t// remove subgrid items, because we will void their data now\r\n\t\t\tthis.items = this.items.filter(item => item.element != undefined);\r\n\r\n\t\t\tfor(var i = 0; i < this.items.length; i++) {\r\n\t\t\t\tvar item = this.items[i];\r\n\t\t\t\t\r\n\t\t\t\t// ignore subgrid items\r\n\t\t\t\tif(item.element===undefined) continue;\r\n\r\n\t\t\t\t// firstly, compute the total breadth of the spanned tracks\r\n\t\t\t\tvar totalBreadth = 0;\r\n\t\t\t\tfor(var cx = item.xStart; cx<item.xEnd; cx++) {\r\n\t\t\t\t\ttotalBreadth += xSizes[cx].breadth;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// secondly, adapt to the alignment properties\r\n\t\t\t\t\"TODO: alignment\";\r\n\t\t\t\t\r\n\t\t\t\t// finally, set the style\r\n\t\t\t\titem.fragment = yield item.element.layoutNextFragment({\r\n\t\t\t\t\tfixedInlineSize: totalBreadth-item.hMargins,\r\n\t\t\t\t\tdata: {\r\n\t\t\t\t\t\tparentGridData: {\r\n\t\t\t\t\t\t\tspannedGridColumns: getSubgridTrackSizes(this.finalXSizes, item.hlMargin+item.hlBorder+item.hlPadding, item.hrMargin+item.hrBorder+item.hrPadding),\r\n\t\t\t\t\t\t\tspannedGridRows: Array.from(new Array(item.yEnd-item.yStart)).map(v=>'min-content').join(' ')+''\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tyield* this.pullSubgridItemsFrom(item, i, item.fragment);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t// compute breadth of rows\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\tvar mode = 'y';\r\n\t\t\tvar fullSize = fullHeight;\r\n\t\t\tvar ySizes = this.ySizes.map(initializeFromConstraints);\r\n\t\t\t\r\n\t\t\tvar getMinHeightOf = function(item) { return item.fragment.blockSize+item.vMargins; };\r\n\t\t\tvar getMaxHeightOf = function(item) { return item.fragment.blockSize+item.vMargins; };\r\n\t\t\tvar getYStartOf = function(item) { return item.yStart; };\r\n\t\t\tvar getYEndOf = function(item) { return item.yEnd; };\r\n\t\t\t\r\n\t\t\tcomputeFinalTrackBreadth.call(\r\n\t\t\t\tthis,\r\n\t\t\t\tySizes,\r\n\t\t\t\tthis.ySizes,\r\n\t\t\t\tfullHeight,\r\n\t\t\t\tgetMinHeightOf,\r\n\t\t\t\tgetMaxHeightOf,\r\n\t\t\t\tgetYStartOf,\r\n\t\t\t\tgetYEndOf\r\n\t\t\t);\r\n\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t// save the results\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\tthis.finalYSizes = ySizes;\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t// relayout all the children\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t\r\n\t\t\t// remove subgrid items, because we will void their data now\r\n\t\t\tthis.items = this.items.filter(item => item.element != undefined);\r\n\r\n\t\t\tfor(var i = 0; i < this.items.length; i++) {\r\n\t\t\t\tvar item = this.items[i];\r\n\r\n\t\t\t\t// ignore subgrid items\r\n\t\t\t\tif(item.element===undefined) continue;\r\n\t\t\t\t\r\n\t\t\t\t// firstly, compute the total breadth of the spanned tracks\r\n\t\t\t\tvar totalHorizontalBreadth = 0;\r\n\t\t\t\tfor(var cx = item.xStart; cx<item.xEnd; cx++) {\r\n\t\t\t\t\ttotalHorizontalBreadth += xSizes[cx].breadth;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar totalVerticalBreadth = 0;\t\t\t\t\r\n\t\t\t\tfor(var cy = item.yStart; cy<item.yEnd; cy++) {\r\n\t\t\t\t\ttotalVerticalBreadth += ySizes[cy].breadth;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// secondly, adapt to the alignment properties\r\n\t\t\t\t\"TODO: alignment\";\r\n\t\t\t\t\r\n\t\t\t\t// finally, set the style\r\n\t\t\t\titem.fragment = yield item.element.layoutNextFragment({\r\n\t\t\t\t\tfixedInlineSize: totalHorizontalBreadth-item.hMargins,\r\n\t\t\t\t\tfixedBlockSize: totalVerticalBreadth-item.vMargins,\r\n\t\t\t\t\tdata: {\r\n\t\t\t\t\t\tparentGridData: {\r\n\t\t\t\t\t\t\tspannedGridColumns: getSubgridTrackSizes(this.finalXSizes, item.hlMargin+item.hlBorder+item.hlPadding, item.hrMargin+item.hrBorder+item.hrPadding),\r\n\t\t\t\t\t\t\tspannedGridRows: getSubgridTrackSizes(this.finalYSizes, item.vtMargin+item.vtBorder+item.vtPadding, item.vbMargin+item.vbBorder+item.vbPadding)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\tyield* this.pullSubgridItemsFrom(item, i, item.fragment);\r\n\r\n\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t// log the results\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t/*console.log({\r\n\t\t\t\tx: xSizes,\r\n\t\t\t\txBreadths: xSizes.map(function(e) { return e.breadth; }),\r\n\t\t\t\ty: ySizes,\r\n\t\t\t\tyBreadths: ySizes.map(function(e) { return e.breadth; }),\r\n\t\t\t});*/\r\n\t\t\r\n\t\t},\r\n\t\t\r\n\t\tfindXStart: function(item) {\r\n\t\t\r\n\t\t\t//////////////////////////////////////////////////////////////////////////////\r\n\t\t\t// TODO: this doesn't reflect the spec after the changes made at my request //\r\n\t\t\t//////////////////////////////////////////////////////////////////////////////\r\n\t\t\t\r\n\t\t\tvar xStart = -1;\r\n\t\t\tif(item.specifiedXStart.type !== LOCATE_LINE) return 0;\r\n\t\t\t\r\n\t\t\tif(item.specifiedXStart.name) {\r\n\t\t\t\t\r\n\t\t\t\t//\r\n\t\t\t\t// <integer>? <custom-ident>\r\n\t\t\t\t//\r\n\t\t\t\t\r\n\t\t\t\tif(item.specifiedXStart.index === undefined) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// First attempts to match the grid area's edge to a named grid area\r\n\t\t\t\t\txStart = this.findXLine(item.specifiedXStart.name+\"-start\", 0, 0, /*dontFallback*/true);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tif(xStart==-1) {\r\n\t\t\t\t\r\n\t\t\t\t\t// Otherwise, contributes the first named line with the specified name to the grid item's placement. \r\n\t\t\t\t\txStart = this.findXLine(item.specifiedXStart.name, 0, (item.specifiedXStart.index||1)-1);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t//\r\n\t\t\t\t// <integer>\r\n\t\t\t\t//\r\n\t\t\t\txStart = (item.specifiedXStart.index||1)-1;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// correct impossible values\r\n\t\t\tif(xStart < 0) { xStart=0; }\r\n\t\t\t\r\n\t\t\t// return the final result\r\n\t\t\treturn item.xStart = xStart;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tfindYStart: function(item) {\r\n\t\t\t\r\n\t\t\tvar yStart = -1;\r\n\t\t\tif(item.specifiedYStart.type !== LOCATE_LINE) return 0;\r\n\r\n\t\t\tif(item.specifiedYStart.name) {\r\n\t\t\t\t\r\n\t\t\t\t//\r\n\t\t\t\t// <interger>? <custom-ident>\r\n\t\t\t\t//\r\n\t\t\t\t\r\n\t\t\t\tif(item.specifiedYStart.index === undefined) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// First attempts to match the grid area's edge to a named grid area\r\n\t\t\t\t\tyStart = this.findYLine(item.specifiedYStart.name+\"-start\", 0, 0, /*dontFallback*/true);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tif(yStart == -1) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Otherwise, contributes the first named line with the specified name to the grid item's placement. \r\n\t\t\t\t\tyStart = this.findYLine(item.specifiedYStart.name, 0,(item.specifiedYStart.index||1)-1);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t//\r\n\t\t\t\t// <integer>\r\n\t\t\t\t//\r\n\t\t\t\tyStart = (item.specifiedYStart.index||1)-1;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// correct impossible values\r\n\t\t\tif(yStart < 0) { yStart=0; }\r\n\t\t\t\r\n\t\t\t// return the final result\r\n\t\t\treturn item.yStart = yStart;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tfindXEnd: function(item) {\r\n\t\t\t\r\n\t\t\tvar xEnd = -1;\r\n\t\t\tvar xStart = item.xStart;\r\n\t\t\tswitch(item.specifiedXEnd.type) {\r\n\t\t\t\t\r\n\t\t\t\tcase LOCATE_LINE:\r\n\t\t\t\t\tif(item.specifiedXEnd.name) {\r\n\t\t\t\t\t\tif(item.specifiedXEnd.index === undefined) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// First attempts to match the grid area's edge to a named grid area\r\n\t\t\t\t\t\t\txEnd = this.findXLine(item.specifiedXEnd.name+\"-end\", 0, 0, /*dontFallback*/true);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(xEnd == -1) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Otherwise, contributes the first named line with the specified name to the grid item's placement. \r\n\t\t\t\t\t\t\txEnd = this.findXLine(item.specifiedXEnd.name, 0, (item.specifiedXEnd.index||1)-1);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\txEnd = (item.specifiedXEnd.index||1)-1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\tcase LOCATE_SPAN:\r\n\t\t\t\t\tif(item.specifiedXEnd.name) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// Set the corresponding edge N lines apart from its opposite edge. \r\n\t\t\t\t\t\txEnd = this.findXLine(item.specifiedXEnd.name, xStart+1, (item.specifiedXEnd.index||1)-1);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Set the corresponding edge N lines apart from its opposite edge. \r\n\t\t\t\t\t\txEnd = xStart+((item.specifiedXEnd.index|0)||1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\tcase LOCATE_AUTO:\r\n\t\t\t\t\t// I don't support subgrids, so this is always true:\r\n\t\t\t\t\txEnd = xStart+1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(xEnd <= xStart) { xEnd = xStart+1; }\r\n\t\t\treturn item.xEnd = xEnd;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tfindYEnd: function(item) {\r\n\t\t\t\r\n\t\t\tvar yEnd = -1;\r\n\t\t\tvar yStart = item.yStart;\r\n\t\t\tswitch(item.specifiedYEnd.type) {\r\n\t\t\t\t\r\n\t\t\t\tcase LOCATE_LINE:\r\n\t\t\t\t\tif(item.specifiedYEnd.name) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t// <integer>? <identifier>\r\n\t\t\t\t\t\t// \r\n\t\t\t\t\t\tif(item.specifiedYEnd.index === undefined) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// First attempts to match the grid area's edge to a named grid area\r\n\t\t\t\t\t\t\tyEnd = this.findYLine(item.specifiedYEnd.name+\"-end\", 0, 0, /*dontFallback*/true);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(yEnd == -1) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Otherwise, contributes the first named line with the specified name to the grid item's placement. \r\n\t\t\t\t\t\t\tyEnd = this.findYLine(item.specifiedYEnd.name, 0, (item.specifiedYEnd.index||1)-1);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t// <integer>\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\tyEnd = (item.specifiedYEnd.index||1)-1;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\tcase LOCATE_SPAN:\r\n\t\t\t\t\tif(item.specifiedYEnd.name) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// Set the corresponding edge N lines apart from its opposite edge. \r\n\t\t\t\t\t\tyEnd = this.findYLine(item.specifiedYEnd.name, yStart+1, (item.specifiedYEnd.index||1)-1);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// TODO: I'm having the wrong behavior here, I sent a mail to csswg to get the spec changed\r\n\t\t\t\t\t\t// \"The spec is more what you'd call 'guidelines' than actual rules\"\r\n\t\t\t\t\t\tif(yEnd==-1) { yEnd = 0; }\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Set the corresponding edge N lines apart from its opposite edge. \r\n\t\t\t\t\t\tyEnd = yStart+((item.specifiedYEnd.index|0)||1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\tcase LOCATE_AUTO:\r\n\t\t\t\t\t// I don't support subgrids, so this is always true:\r\n\t\t\t\t\tyEnd = yStart+1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// correct impossible end values\r\n\t\t\tif(yEnd <= yStart) { yEnd = yStart+1; }\r\n\t\t\t\r\n\t\t\t// return the final result\r\n\t\t\treturn item.yEnd = yEnd;\r\n\r\n\t\t},\r\n\t\t\r\n\t\tfindXLine: function(name, startIndex, skipCount, dontFallback) {\r\n\t\t\r\n\t\t\tstartIndex=startIndex|0;\r\n\t\t\tskipCount=skipCount|0;\r\n\t\t\t\r\n\t\t\t// special case for cases where the name isn't provided\r\n\t\t\tif(!name) {\r\n\t\t\t\tif(startIndex+skipCount < this.xLines.length) {\r\n\t\t\t\t\treturn startIndex+skipCount;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn this.xLines.length;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// find the 1+skipCount'th line to match the right name\r\n\t\t\tvar last = -1;\r\n\t\t\tfor(var i = startIndex; i<this.xLines.length; i++) {\r\n\t\t\t\tif(this.xLines[i].indexOf(name) >= 0 || (!dontFallback && this.xLines[i].indexOf('*') >= 0)) { \r\n\t\t\t\t\tif(skipCount>0) { last=i; skipCount--; }\r\n\t\t\t\t\telse { return i; }\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// if we still have lines to find, we know that lines of the implicit grid match all names\r\n\t\t\tif(!dontFallback) { console.warn('[CSS-GRID] Missing '+(skipCount+1)+' lines named \"'+name+'\" after line '+startIndex+'.'); last = this.xLines.length+skipCount+1; this.ensureRows(last); }\r\n\t\t\treturn last;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tfindYLine: function(name, startIndex, skipCount, dontFallback) {\r\n\r\n\t\t\tstartIndex=startIndex|0;\r\n\t\t\tskipCount=skipCount|0;\r\n\t\t\t\r\n\t\t\t// special case for cases where the name isn't provided\r\n\t\t\tif(!name) {\r\n\t\t\t\tif(startIndex+skipCount < this.yLines.length) {\r\n\t\t\t\t\treturn startIndex+skipCount;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn this.yLines.length;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// find the 1+skipCount'th line to match the right name\r\n\t\t\tvar last = -1;\r\n\t\t\tfor(var i = startIndex; i<this.yLines.length; i++) {\r\n\t\t\t\tif(this.yLines[i].indexOf(name) >= 0 || (!dontFallback && this.yLines[i].indexOf('*') >= 0)) { \r\n\t\t\t\t\tif(skipCount>0) { last=i; skipCount--; }\r\n\t\t\t\t\telse { return i; }\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// if we still have lines to find, we know that lines of the implicit grid match all names\r\n\t\t\tif(!dontFallback) { console.warn('[CSS-GRID] Missing '+(skipCount+1)+' lines named \"'+name+'\" after line '+startIndex+'.'); last = this.yLines.length+skipCount+1; this.ensureColumns(last); }\r\n\t\t\treturn last;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t}\r\n\t\r\n\tvar cssGrid = {\r\n\t\t\r\n\t\tLOCATE_LINE   :  LOCATE_LINE,\r\n\t\tLOCATE_SPAN   :  LOCATE_SPAN,\r\n\t\tLOCATE_AREA   :  LOCATE_AREA,\r\n\t\tLOCATE_AUTO   :  LOCATE_AUTO,\r\n\t\t\r\n\t\tALIGN_START   :  ALIGN_START,\r\n\t\tALIGN_CENTER  :  ALIGN_CENTER,\r\n\t\tALIGN_END     :  ALIGN_END,\r\n\t\tALIGN_FIT     :  ALIGN_FIT,  \r\n\t\t\r\n\t\tTRACK_BREADTH_AUTO        : TRACK_BREADTH_AUTO,\r\n\t\tTRACK_BREADTH_LENGTH      : TRACK_BREADTH_LENGTH,\r\n\t\tTRACK_BREADTH_FRACTION    : TRACK_BREADTH_FRACTION,\r\n\t\tTRACK_BREADTH_PERCENTAGE  : TRACK_BREADTH_PERCENTAGE,\r\n\t\tTRACK_BREADTH_MIN_CONTENT : TRACK_BREADTH_MIN_CONTENT,\r\n\t\tTRACK_BREADTH_MAX_CONTENT : TRACK_BREADTH_MAX_CONTENT,\r\n\r\n\t\tGridLayout: GridLayout, \r\n\t\tGridItem: GridItem, \r\n\t\tGridItemPosition: GridItemPosition,\r\n\t\tGridTrackBreadth: GridTrackBreadth,\r\n\t\t\r\n\t};\r\n\treturn cssGrid;\r\n\t\r\n})()\r\n\nrequire.define('src/css-grid/lib/grid-layout.js');","// TODO: document the \"no_auto_css_grid\" flag?\r\n// TOOD: document the \"no_ms_grid_implementation\" flag?\r\n\r\n!(function() { \"use strict\";\r\n\r\n\tvar cssGrid = require('src/css-grid/lib/grid-layout.js');\r\n\tconsole.log(\"css-grid-polyfill\");\r\n\r\n\tvar layoutProperties = ['display','position','box-sizing','margin-left','margin-right','margin-top','margin-bottom','padding-left','padding-right','padding-top','padding-bottom','border-left-width','border-right-width','border-top-width','border-bottom-width'];\r\n\tregisterLayout('grid', class GridLayout {\r\n\t\t\r\n\t\t//\r\n\t\t// [0] define css properties\r\n\t\t//\r\n\t\tstatic get inputProperties() {\r\n\t\t\treturn ['--grid','--grid-template','--grid-template-rows','--grid-template-columns','--grid-template-areas','--grid-areas','--grid-auto-flow',...layoutProperties];\r\n\t\t}\r\n\t\tstatic get childInputProperties() {\r\n\t\t\treturn ['--grid-area','--grid-row','--grid-column','--grid-row-start','--grid-row-end','--grid-column-start','--grid-column-end','order',...layoutProperties]\r\n\t\t}\r\n\r\n\t\t*intrinsicSizes() { /* ... */ }\r\n\r\n\t\t*layout(children, edges, constraints, styleMap) {\r\n\r\n\t\t\t//\r\n\t\t\t// Initialize the grid layout\r\n\t\t\t//\r\n\r\n\t\t\tvar grid = new cssGrid.GridLayout({ \r\n\t\t\t\tstyleMap:styleMap, \r\n\t\t\t\tchildren:children,\r\n\t\t\t\tfixedInlineSize:constraints.fixedInlineSize, \r\n\t\t\t\tfixedBlockSize:constraints.fixedBlockSize\r\n\t\t\t});\r\n\r\n\t\t\t//\r\n\t\t\t// Get data from parent\r\n\t\t\t// \r\n\t\t\t\r\n\t\t\tvar parentGridData = constraints.data ? constraints.data.parentGridData : null;\r\n\r\n\t\t\t//\r\n\t\t\t// Prepare the grid layout\r\n\t\t\t//\r\n\r\n\t\t\tyield* grid.updateFromElement(parentGridData);\r\n\r\n\t\t\t//\r\n\t\t\t// Perform the grid layout\r\n\t\t\t// \r\n\r\n\t\t\tyield* grid.performLayout();\r\n\r\n\t\t\t//\r\n\t\t\t// Return the layout results\r\n\t\t\t//\r\n\t\t\t\r\n\t\t\tvar dataForParentGrid = null;\r\n\t\t\tif(parentGridData && (grid.isSubgridX||grid.isSubgridY)) {\r\n\t\t\t\t// prepare the items for copy, because @bfgeek isn't a merciful god\r\n\t\t\t\tlet grid_items = grid.items.map(item => Object.assign({}, item, { element:undefined, parentGrid:undefined, fragment:{blockSize:item.fragment.blockSize} }));\r\n\t\t\t\tdataForParentGrid = {\r\n\t\t\t\t\titems: grid_items,\r\n\t\t\t\t\txSizes: grid.xSizes,\r\n\t\t\t\t\tySizes: grid.ySizes\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tconsole.log({\r\n\t\t\t\tautoBlockSize: grid.gridHeight + grid.vtPadding + grid.vbPadding, \r\n\t\t\t\tchildFragments: grid.items.map(item => item.fragment).filter(fragment => fragment instanceof LayoutFragment),\r\n\t\t\t\tdata: { dataForParentGrid }\r\n\t\t\t});\r\n\r\n\t\t\treturn {\r\n\t\t\t\tautoBlockSize: grid.gridHeight + grid.vtPadding + grid.vbPadding, \r\n\t\t\t\tchildFragments: grid.items.map(item => item.fragment).filter(fragment => fragment instanceof LayoutFragment),\r\n\t\t\t\tdata: { dataForParentGrid }\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t});\r\n\r\n})()\nrequire.define('src/css-grid/polyfill.js');","//require('core:dom-matchMedia-polyfill');\r\n//require('core:dom-classList-polyfill');\r\nrequire('src/css-grid/polyfill.js');\nrequire.define('src/requirements.js');"]}