{"version":3,"sources":["..\\src\\core\\polyfill-dom-console.js","..\\src\\core\\polyfill-dom-requestAnimationFrame.js","..\\src\\core\\css-syntax.js","..\\src\\core\\dom-events.js","..\\src\\core\\dom-experimental-event-streams.js","..\\src\\core\\dom-query-selector-live.js","..\\src\\core\\css-cascade.js","..\\src\\core\\css-style.js","..\\src\\core\\polyfill-dom-uniqueID.js","..\\src\\core\\css-sizing.js","..\\src\\core\\css-box.js","..\\src\\core\\css-units.js","..\\src\\css-grid\\lib\\grid-layout.js","..\\src\\css-grid\\polyfill.js","..\\src\\requirements.js"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mD;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iE;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;ACrzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6D;;;;ACnXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sD;;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;AC9yBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oD;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kD;;;;ACnuFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;AC/HA;AACA;AACA;AACA,sC","file":"css-polyfills.js","sourcesContent":["!(function(window, document) { \"use strict\";\r\n\r\n\t//\r\n\t// some code for console polyfilling\r\n\t//\r\n\tif(!window.console) {\r\n\t\t\t\r\n\t\twindow.console = {\r\n\t\t\tbacklog: '',\r\n\t\t\t\r\n\t\t\tlog: function(x) { this.backlog+=x+'\\n'; if(window.debug) alert(x); },\r\n\t\t\t\r\n\t\t\tdir: function(x) { try { \r\n\t\t\t\t\r\n\t\t\t\tvar elm = function(e) {\r\n\t\t\t\t\tif(e.innerHTML) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\ttagName: e.tagName,\r\n\t\t\t\t\t\t\tclassName: e.className,\r\n\t\t\t\t\t\t\tid: e.id,\r\n\t\t\t\t\t\t\tinnerHTML: e.innerHTML.substr(0,100)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tnodeName: e.nodeName,\r\n\t\t\t\t\t\t\tnodeValue: e.nodeValue\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\t\r\n\t\t\t\tvar jsonify = function(o) {\r\n\t\t\t\t\tvar seen=[];\r\n\t\t\t\t\tvar jso=JSON.stringify(o, function(k,v){\r\n\t\t\t\t\t\tif (typeof v =='object') {\r\n\t\t\t\t\t\t\tif ( !seen.indexOf(v) ) { return '__cycle__'; }\r\n\t\t\t\t\t\t\tif ( v instanceof window.Node) { return elm(v); }\r\n\t\t\t\t\t\t\tseen.push(v);\r\n\t\t\t\t\t\t} return v;\r\n\t\t\t\t\t});\r\n\t\t\t\t\treturn jso;\r\n\t\t\t\t};\r\n\t\t\t\t\r\n\t\t\t\tthis.log(jsonify(x)); \r\n\t\t\t\t\r\n\t\t\t} catch(ex) { this.log(x) } },\r\n\t\t\t\r\n\t\t\twarn: function(x) { this.log(x) },\r\n\t\t\t\r\n\t\t\terror: function(x) { this.log(\"ERROR:\"); this.log(x); }\r\n\t\t\t\r\n\t\t};\r\n\t\t\r\n\t\tif(!window.onerror) {\r\n\t\t\twindow.onerror = function() {\r\n\t\t\t\tconsole.log([].slice.call(arguments,0).join(\"\\n\"))\r\n\t\t\t};\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n\t//\r\n\t// this special console is used as a proxy emulating the CSS console of browsers\r\n\t//\r\n\twindow.cssConsole = {\r\n\t\tenabled: (!!window.debug), warnEnabled: (true),\r\n\t\tlog: function(x) { if(this.enabled) console.log(x) },\r\n\t\tdir: function(x) { if(this.enabled) console.dir(x) },\r\n\t\twarn: function(x) { if(this.warnEnabled) console.warn(x) },\r\n\t\terror: function(x) { console.error(x); }\r\n\t}\r\n\r\n})(window, document);\nrequire.define('src/core/polyfill-dom-console.js');","void function() {\r\n\t\r\n\t// request animation frame\r\n    var vendors = ['webkit', 'moz', 'ms', 'o'];\r\n    for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {\r\n        var vp = vendors[i];\r\n        window.requestAnimationFrame = window[vp+'RequestAnimationFrame'];\r\n        window.cancelAnimationFrame = (window[vp+'CancelAnimationFrame'] || window[vp+'CancelRequestAnimationFrame']);\r\n    }\r\n    if (!window.requestAnimationFrame || !window.cancelAnimationFrame) {\r\n\t\t\r\n\t\t// tick every 16ms\r\n        var listener_index = 0; var listeners = []; var tmp = []; var tick = function() {\r\n\t\t\tvar now = +(new Date()); var callbacks = listeners; listeners = tmp;\r\n\t\t\tfor(var i = 0; i<callbacks.length; i++) { callbacks[i](now); }\r\n\t\t\tlistener_index += callbacks.length; callbacks.length = 0; tmp = callbacks;\r\n\t\t\tsetTimeout(tick, 16);\r\n\t\t}; tick();\r\n\t\t\r\n\t\t// add a listener\r\n        window.requestAnimationFrame = function(callback) {\r\n            return listener_index + listeners.push(callback);\r\n        };\r\n\t\t\r\n\t\t// remove a listener\r\n        window.cancelAnimationFrame = function(index) {\r\n\t\t\tindex -= listener_index; if(index >= 0 && index < listeners.length) {\r\n\t\t\t\tlisteners[index] = function() {};\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n    }\r\n\t\r\n\t// setImmediate\r\n\tif(!window.setImmediate) {\r\n\t\twindow.setImmediate = function(f) { return setTimeout(f, 0) };\r\n\t\twindow.cancelImmediate = clearTimeout;\r\n\t}\r\n\t\r\n}();\r\n\nrequire.define('src/core/polyfill-dom-requestAnimationFrame.js');","//\r\n// note: this file is based on Tab Atkins's CSS Parser\r\n// please include him (@tabatkins) if you open any issue for this file\r\n// \r\nmodule.exports = (function(window, document) { \"use strict\";\r\n\r\n// \r\n// exports\r\n//\r\nvar cssSyntax = { \r\n\ttokenize: function(string) {}, \r\n\tparse: function(tokens) {}\r\n};\r\n\r\n//\r\n// css tokenizer\r\n//\r\n\r\n// Add support for token lists (superclass of array)\r\nfunction TokenList() {\r\n\tvar array = []; \r\n\tarray.toCSSString=TokenListToCSSString;\r\n\treturn array;\r\n}\r\nfunction TokenListToCSSString(sep) {\r\n\tif(sep) {\r\n\t\treturn this.map(function(o) { return o.toCSSString(); }).join(sep);\r\n\t} else {\r\n\t\treturn this.asCSSString || (this.asCSSString = (\r\n\t\t\tthis.map(function(o) { return o.toCSSString(); }).join(\"/**/\")\r\n\t\t\t\t.replace(/( +\\/\\*\\*\\/ *| * | *\\/\\*\\*\\/ +)/g,\" \")\r\n\t\t\t\t.replace(/( +\\/\\*\\*\\/ *| * | *\\/\\*\\*\\/ +)/g,\" \")\r\n\t\t\t\t.replace(/(\\!|\\:|\\;|\\@|\\.|\\,|\\*|\\=|\\&|\\\\|\\/|\\<|\\>|\\[|\\{|\\(|\\]|\\}|\\)|\\|)\\/\\*\\*\\//g,\"$1\")\r\n\t\t\t\t.replace(/\\/\\*\\*\\/(\\!|\\:|\\;|\\@|\\.|\\,|\\*|\\=|\\&|\\\\|\\/|\\<|\\>|\\[|\\{|\\(|\\]|\\}|\\)|\\|)/g,\"$1\")\r\n\t\t));\r\n\t}\r\n}\r\ncssSyntax.TokenList = TokenList;\r\ncssSyntax.TokenListToCSSString = TokenListToCSSString;\r\n\r\nfunction between(num, first, last) { return num >= first && num <= last; }\r\nfunction digit(code) { return between(code, 0x30,0x39); }\r\nfunction hexdigit(code) { return digit(code) || between(code, 0x41,0x46) || between(code, 0x61,0x66); }\r\nfunction uppercaseletter(code) { return between(code, 0x41,0x5a); }\r\nfunction lowercaseletter(code) { return between(code, 0x61,0x7a); }\r\nfunction letter(code) { return uppercaseletter(code) || lowercaseletter(code); }\r\nfunction nonascii(code) { return code >= 0x80; }\r\nfunction namestartchar(code) { return letter(code) || nonascii(code) || code == 0x5f; }\r\nfunction namechar(code) { return namestartchar(code) || digit(code) || code == 0x2d; }\r\nfunction nonprintable(code) { return between(code, 0,8) || code == 0xb || between(code, 0xe,0x1f) || code == 0x7f; }\r\nfunction newline(code) { return code == 0xa; }\r\nfunction whitespace(code) { return newline(code) || code == 9 || code == 0x20; }\r\nfunction badescape(code) { return newline(code) || isNaN(code); }\r\n\r\nvar maximumallowedcodepoint = 0x10ffff;\r\n\r\nfunction InvalidCharacterError(message) {\r\n\tthis.message = message;\r\n};\r\nInvalidCharacterError.prototype = new Error;\r\nInvalidCharacterError.prototype.name = 'InvalidCharacterError';\r\n\r\nfunction preprocess(str) {\r\n\t// Turn a string into an array of code points,\r\n\t// following the preprocessing cleanup rules.\r\n\tvar codepoints = [];\r\n\tfor(var i = 0; i < str.length; i++) {\r\n\t\tvar code = str.charCodeAt(i);\r\n\t\tif(code == 0xd && str.charCodeAt(i+1) == 0xa) {\r\n\t\t\tcode = 0xa; i++;\r\n\t\t}\r\n\t\tif(code == 0xd || code == 0xc) code = 0xa;\r\n\t\tif(code == 0x0) code = 0xfffd;\r\n\t\tif(between(code, 0xd800, 0xdbff) && between(str.charCodeAt(i+1), 0xdc00, 0xdfff)) {\r\n\t\t\t// Decode a surrogate pair into an astral codepoint.\r\n\t\t\tvar lead = code - 0xd800;\r\n\t\t\tvar trail = str.charCodeAt(i+1) - 0xdc00;\r\n\t\t\tcode = Math.pow(2, 21) + lead * Math.pow(2, 10) + trail;\r\n\t\t}\r\n\t\tcodepoints.push(code);\r\n\t}\r\n\treturn codepoints;\r\n}\r\n\r\nfunction stringFromCode(code) {\r\n\tif(code <= 0xffff) return String.fromCharCode(code);\r\n\t// Otherwise, encode astral char as surrogate pair.\r\n\tcode -= Math.pow(2, 21);\r\n\tvar lead = Math.floor(code/Math.pow(2, 10)) + 0xd800;\r\n\tvar trail = code % Math.pow(2, 10); + 0xdc00;\r\n\treturn String.fromCharCode(lead) + String.fromCharCode(trail);\r\n}\r\n\r\nfunction tokenize(str) {\r\n\tstr = preprocess(str);\r\n\tvar i = -1;\r\n\tvar tokens = new TokenList();\r\n\tvar code;\r\n\r\n\t// Line number information.\r\n\tvar line = 0;\r\n\tvar column = 0;\r\n\t// The only use of lastLineLength is in reconsume().\r\n\tvar lastLineLength = 0;\r\n\tvar incrLineno = function() {\r\n\t\tline += 1;\r\n\t\tlastLineLength = column;\r\n\t\tcolumn = 0;\r\n\t};\r\n\tvar locStart = {line:line, column:column};\r\n\r\n\tvar codepoint = function(i) {\r\n\t\tif(i >= str.length) {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\treturn str[i];\r\n\t}\r\n\tvar next = function(num) {\r\n\t\tif(num === undefined) { num = 1; }\r\n\t\tif(num > 3) { throw \"Spec Error: no more than three codepoints of lookahead.\"; }\r\n\t\treturn codepoint(i+num);\r\n\t};\r\n\tvar consume = function(num) {\r\n\t\tif(num === undefined)\r\n\t\t\tnum = 1;\r\n\t\ti += num;\r\n\t\tcode = codepoint(i);\r\n\t\tif(newline(code)) incrLineno();\r\n\t\telse column += num;\r\n\t\t//console.log('Consume '+i+' '+String.fromCharCode(code) + ' 0x' + code.toString(16));\r\n\t\treturn true;\r\n\t};\r\n\tvar reconsume = function() {\r\n\t\ti -= 1;\r\n\t\tif (newline(code)) {\r\n\t\t\tline -= 1;\r\n\t\t\tcolumn = lastLineLength;\r\n\t\t} else {\r\n\t\t\tcolumn -= 1;\r\n\t\t}\r\n\t\tlocStart.line = line;\r\n\t\tlocStart.column = column;\r\n\t\treturn true;\r\n\t};\r\n\tvar eof = function(codepoint) {\r\n\t\tif(codepoint === undefined) codepoint = code;\r\n\t\treturn codepoint == -1;\r\n\t};\r\n\tvar donothing = function() {};\r\n\tvar tokenizeerror = function() { console.log(\"Parse error at index \" + i + \", processing codepoint 0x\" + code.toString(16) + \".\");return true; };\r\n\r\n\tvar consumeAToken = function() {\r\n\t\tconsumeComments();\r\n\t\tconsume();\r\n\t\tif(whitespace(code)) {\r\n\t\t\twhile(whitespace(next())) consume();\r\n\t\t\treturn new WhitespaceToken;\r\n\t\t}\r\n\t\telse if(code == 0x22) return consumeAStringToken();\r\n\t\telse if(code == 0x23) {\r\n\t\t\tif(namechar(next()) || areAValidEscape(next(1), next(2))) {\r\n\t\t\t\tvar token = new HashToken();\r\n\t\t\t\tif(wouldStartAnIdentifier(next(1), next(2), next(3))) token.type = \"id\";\r\n\t\t\t\ttoken.value = consumeAName();\r\n\t\t\t\treturn token;\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x24) {\r\n\t\t\tif(next() == 0x3d) {\r\n\t\t\t\tconsume();\r\n\t\t\t\treturn new SuffixMatchToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x27) return consumeAStringToken();\r\n\t\telse if(code == 0x28) return new OpenParenToken();\r\n\t\telse if(code == 0x29) return new CloseParenToken();\r\n\t\telse if(code == 0x2a) {\r\n\t\t\tif(next() == 0x3d) {\r\n\t\t\t\tconsume();\r\n\t\t\t\treturn new SubstringMatchToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x2b) {\r\n\t\t\tif(startsWithANumber()) {\r\n\t\t\t\treconsume();\r\n\t\t\t\treturn consumeANumericToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x2c) return new CommaToken();\r\n\t\telse if(code == 0x2d) {\r\n\t\t\tif(startsWithANumber()) {\r\n\t\t\t\treconsume();\r\n\t\t\t\treturn consumeANumericToken();\r\n\t\t\t} else if(next(1) == 0x2d && next(2) == 0x3e) {\r\n\t\t\t\tconsume(2);\r\n\t\t\t\treturn new CDCToken();\r\n\t\t\t} else if(startsWithAnIdentifier()) {\r\n\t\t\t\treconsume();\r\n\t\t\t\treturn consumeAnIdentlikeToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x2e) {\r\n\t\t\tif(startsWithANumber()) {\r\n\t\t\t\treconsume();\r\n\t\t\t\treturn consumeANumericToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x3a) return new ColonToken;\r\n\t\telse if(code == 0x3b) return new SemicolonToken;\r\n\t\telse if(code == 0x3c) {\r\n\t\t\tif(next(1) == 0x21 && next(2) == 0x2d && next(3) == 0x2d) {\r\n\t\t\t\tconsume(3);\r\n\t\t\t\treturn new CDOToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x40) {\r\n\t\t\tif(wouldStartAnIdentifier(next(1), next(2), next(3))) {\r\n\t\t\t\treturn new AtKeywordToken(consumeAName());\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x5b) return new OpenSquareToken();\r\n\t\telse if(code == 0x5c) {\r\n\t\t\tif(startsWithAValidEscape()) {\r\n\t\t\t\treconsume();\r\n\t\t\t\treturn consumeAnIdentlikeToken();\r\n\t\t\t} else {\r\n\t\t\t\ttokenizeerror();\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x5d) return new CloseSquareToken();\r\n\t\telse if(code == 0x5e) {\r\n\t\t\tif(next() == 0x3d) {\r\n\t\t\t\tconsume();\r\n\t\t\t\treturn new PrefixMatchToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x7b) return new OpenCurlyToken();\r\n\t\telse if(code == 0x7c) {\r\n\t\t\tif(next() == 0x3d) {\r\n\t\t\t\tconsume();\r\n\t\t\t\treturn new DashMatchToken();\r\n\t\t\t} else if(next() == 0x7c) {\r\n\t\t\t\tconsume();\r\n\t\t\t\treturn new ColumnToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x7d) return new CloseCurlyToken();\r\n\t\telse if(code == 0x7e) {\r\n\t\t\tif(next() == 0x3d) {\r\n\t\t\t\tconsume();\r\n\t\t\t\treturn new IncludeMatchToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(digit(code)) {\r\n\t\t\treconsume();\r\n\t\t\treturn consumeANumericToken();\r\n\t\t}\r\n\t\telse if(namestartchar(code)) {\r\n\t\t\treconsume();\r\n\t\t\treturn consumeAnIdentlikeToken();\r\n\t\t}\r\n\t\telse if(eof()) return new EOFToken();\r\n\t\telse return new DelimToken(code);\r\n\t};\r\n\r\n\tvar consumeComments = function() {\r\n\t\twhile(next(1) == 0x2f && next(2) == 0x2a) {\r\n\t\t\tconsume(2);\r\n\t\t\twhile(true) {\r\n\t\t\t\tconsume();\r\n\t\t\t\tif(code == 0x2a && next() == 0x2f) {\r\n\t\t\t\t\tconsume();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else if(eof()) {\r\n\t\t\t\t\ttokenizeerror();\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tvar consumeANumericToken = function() {\r\n\t\tvar num = consumeANumber();\r\n\t\tif(wouldStartAnIdentifier(next(1), next(2), next(3))) {\r\n\t\t\tvar token = new DimensionToken();\r\n\t\t\ttoken.value = num.value;\r\n\t\t\ttoken.repr = num.repr;\r\n\t\t\ttoken.type = num.type;\r\n\t\t\ttoken.unit = consumeAName();\r\n\t\t\treturn token;\r\n\t\t} else if(next() == 0x25) {\r\n\t\t\tconsume();\r\n\t\t\tvar token = new PercentageToken();\r\n\t\t\ttoken.value = num.value;\r\n\t\t\ttoken.repr = num.repr;\r\n\t\t\treturn token;\r\n\t\t} else {\r\n\t\t\tvar token = new NumberToken();\r\n\t\t\ttoken.value = num.value;\r\n\t\t\ttoken.repr = num.repr;\r\n\t\t\ttoken.type = num.type;\r\n\t\t\treturn token;\r\n\t\t}\r\n\t};\r\n\r\n\tvar consumeAnIdentlikeToken = function() {\r\n\t\tvar str = consumeAName();\r\n\t\tif(str.toLowerCase() == \"url\" && next() == 0x28) {\r\n\t\t\tconsume();\r\n\t\t\twhile(whitespace(next(1)) && whitespace(next(2))) consume();\r\n\t\t\tif(next() == 0x22 || next() == 0x27) {\r\n\t\t\t\treturn new FunctionToken(str);\r\n\t\t\t} else if(whitespace(next()) && (next(2) == 0x22 || next(2) == 0x27)) {\r\n\t\t\t\treturn new FunctionToken(str);\r\n\t\t\t} else {\r\n\t\t\t\treturn consumeAURLToken();\r\n\t\t\t}\r\n\t\t} else if(next() == 0x28) {\r\n\t\t\tconsume();\r\n\t\t\treturn new FunctionToken(str);\r\n\t\t} else {\r\n\t\t\treturn new IdentifierToken(str);\r\n\t\t}\r\n\t};\r\n\r\n\tvar consumeAStringToken = function(endingCodePoint) {\r\n\t\tif(endingCodePoint === undefined) endingCodePoint = code;\r\n\t\tvar string = \"\";\r\n\t\twhile(consume()) {\r\n\t\t\tif(code == endingCodePoint || eof()) {\r\n\t\t\t\treturn new StringToken(string);\r\n\t\t\t} else if(newline(code)) {\r\n\t\t\t\ttokenizeerror();\r\n\t\t\t\treconsume();\r\n\t\t\t\treturn new BadStringToken();\r\n\t\t\t} else if(code == 0x5c) {\r\n\t\t\t\tif(eof(next())) {\r\n\t\t\t\t\tdonothing();\r\n\t\t\t\t} else if(newline(next())) {\r\n\t\t\t\t\tconsume();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstring += stringFromCode(consumeEscape())\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tstring += stringFromCode(code);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tvar consumeAURLToken = function() {\r\n\t\tvar token = new URLToken(\"\");\r\n\t\twhile(whitespace(next())) consume();\r\n\t\tif(eof(next())) return token;\r\n\t\twhile(consume()) {\r\n\t\t\tif(code == 0x29 || eof()) {\r\n\t\t\t\treturn token;\r\n\t\t\t} else if(whitespace(code)) {\r\n\t\t\t\twhile(whitespace(next())) consume();\r\n\t\t\t\tif(next() == 0x29 || eof(next())) {\r\n\t\t\t\t\tconsume();\r\n\t\t\t\t\treturn token;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconsumeTheRemnantsOfABadURL();\r\n\t\t\t\t\treturn new BadURLToken();\r\n\t\t\t\t}\r\n\t\t\t} else if(code == 0x22 || code == 0x27 || code == 0x28 || nonprintable(code)) {\r\n\t\t\t\ttokenizeerror();\r\n\t\t\t\tconsumeTheRemnantsOfABadURL();\r\n\t\t\t\treturn new BadURLToken();\r\n\t\t\t} else if(code == 0x5c) {\r\n\t\t\t\tif(startsWithAValidEscape()) {\r\n\t\t\t\t\ttoken.value += stringFromCode(consumeEscape());\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttokenizeerror();\r\n\t\t\t\t\tconsumeTheRemnantsOfABadURL();\r\n\t\t\t\t\treturn new BadURLToken();\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\ttoken.value += stringFromCode(code);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tvar consumeEscape = function() {\r\n\t\t// Assume the the current character is the \\\r\n\t\t// and the next code point is not a newline.\r\n\t\tconsume();\r\n\t\tif(hexdigit(code)) {\r\n\t\t\t// Consume 1-6 hex digits\r\n\t\t\tvar digits = [code];\r\n\t\t\tfor(var total = 0; total < 5; total++) {\r\n\t\t\t\tif(hexdigit(next())) {\r\n\t\t\t\t\tconsume();\r\n\t\t\t\t\tdigits.push(code);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(whitespace(next())) consume();\r\n\t\t\tvar value = parseInt(digits.map(function(x){return String.fromCharCode(x);}).join(''), 16);\r\n\t\t\tif( value > maximumallowedcodepoint ) value = 0xfffd;\r\n\t\t\treturn value;\r\n\t\t} else if(eof()) {\r\n\t\t\treturn 0xfffd;\r\n\t\t} else {\r\n\t\t\treturn code;\r\n\t\t}\r\n\t};\r\n\r\n\tvar areAValidEscape = function(c1, c2) {\r\n\t\tif(c1 != 0x5c) return false;\r\n\t\tif(newline(c2)) return false;\r\n\t\treturn true;\r\n\t};\r\n\tvar startsWithAValidEscape = function() {\r\n\t\treturn areAValidEscape(code, next());\r\n\t};\r\n\r\n\tvar wouldStartAnIdentifier = function(c1, c2, c3) {\r\n\t\tif(c1 == 0x2d) {\r\n\t\t\treturn namestartchar(c2) || c2 == 0x2d || areAValidEscape(c2, c3);\r\n\t\t} else if(namestartchar(c1)) {\r\n\t\t\treturn true;\r\n\t\t} else if(c1 == 0x5c) {\r\n\t\t\treturn areAValidEscape(c1, c2);\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n\tvar startsWithAnIdentifier = function() {\r\n\t\treturn wouldStartAnIdentifier(code, next(1), next(2));\r\n\t};\r\n\r\n\tvar wouldStartANumber = function(c1, c2, c3) {\r\n\t\tif(c1 == 0x2b || c1 == 0x2d) {\r\n\t\t\tif(digit(c2)) return true;\r\n\t\t\tif(c2 == 0x2e && digit(c3)) return true;\r\n\t\t\treturn false;\r\n\t\t} else if(c1 == 0x2e) {\r\n\t\t\tif(digit(c2)) return true;\r\n\t\t\treturn false;\r\n\t\t} else if(digit(c1)) {\r\n\t\t\treturn true;\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n\tvar startsWithANumber = function() {\r\n\t\treturn wouldStartANumber(code, next(1), next(2));\r\n\t};\r\n\r\n\tvar consumeAName = function() {\r\n\t\tvar result = \"\";\r\n\t\twhile(consume()) {\r\n\t\t\tif(namechar(code)) {\r\n\t\t\t\tresult += stringFromCode(code);\r\n\t\t\t} else if(startsWithAValidEscape()) {\r\n\t\t\t\tresult += stringFromCode(consumeEscape());\r\n\t\t\t} else {\r\n\t\t\t\treconsume();\r\n\t\t\t\treturn result;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tvar consumeANumber = function() {\r\n\t\tvar repr = [];\r\n\t\tvar type = \"integer\";\r\n\t\tif(next() == 0x2b || next() == 0x2d) {\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t}\r\n\t\twhile(digit(next())) {\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t}\r\n\t\tif(next(1) == 0x2e && digit(next(2))) {\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t\ttype = \"number\";\r\n\t\t\twhile(digit(next())) {\r\n\t\t\t\tconsume();\r\n\t\t\t\trepr += stringFromCode(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar c1 = next(1), c2 = next(2), c3 = next(3);\r\n\t\tif((c1 == 0x45 || c1 == 0x65) && digit(c2)) {\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t\ttype = \"number\";\r\n\t\t\twhile(digit(next())) {\r\n\t\t\t\tconsume();\r\n\t\t\t\trepr += stringFromCode(code);\r\n\t\t\t}\r\n\t\t} else if((c1 == 0x45 || c1 == 0x65) && (c2 == 0x2b || c2 == 0x2d) && digit(c3)) {\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t\ttype = \"number\";\r\n\t\t\twhile(digit(next())) {\r\n\t\t\t\tconsume();\r\n\t\t\t\trepr += stringFromCode(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar value = convertAStringToANumber(repr);\r\n\t\treturn {type:type, value:value, repr:repr};\r\n\t};\r\n\r\n\tvar convertAStringToANumber = function(string) {\r\n\t\t// CSS's number rules are identical to JS, afaik.\r\n\t\treturn +string;\r\n\t};\r\n\r\n\tvar consumeTheRemnantsOfABadURL = function() {\r\n\t\twhile(consume()) {\r\n\t\t\tif(code == 0x2d || eof()) {\r\n\t\t\t\treturn;\r\n\t\t\t} else if(startsWithAValidEscape()) {\r\n\t\t\t\tconsumeEscape();\r\n\t\t\t\tdonothing();\r\n\t\t\t} else {\r\n\t\t\t\tdonothing();\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\r\n\r\n\tvar iterationCount = 0;\r\n\twhile(!eof(next())) {\r\n\t\ttokens.push(consumeAToken());\r\n\t\tif(iterationCount++ > str.length*2) throw new Error(\"The CSS Tokenizer is infinite-looping\");\r\n\t}\r\n\treturn tokens;\r\n}\r\n\r\nfunction CSSParserToken() { return this; }\r\nCSSParserToken.prototype.toJSON = function() {\r\n\treturn {token: this.tokenType};\r\n}\r\nCSSParserToken.prototype.toString = function() { return this.tokenType; }\r\nCSSParserToken.prototype.toCSSString = function() { return ''+this; }\r\n\r\nfunction BadStringToken() { return this; }\r\nBadStringToken.prototype = new CSSParserToken;\r\nBadStringToken.prototype.tokenType = \"BADSTRING\";\r\nBadStringToken.prototype.toCSSString = function() { return \"'\"; }\r\n\r\nfunction BadURLToken() { return this; }\r\nBadURLToken.prototype = new CSSParserToken;\r\nBadURLToken.prototype.tokenType = \"BADURL\";\r\nBadURLToken.prototype.toCSSString = function() { return \"url(\"; }\r\n\r\nfunction WhitespaceToken() { return this; }\r\nWhitespaceToken.prototype = new CSSParserToken;\r\nWhitespaceToken.prototype.tokenType = \"WHITESPACE\";\r\nWhitespaceToken.prototype.toString = function() { return \"WS\"; }\r\nWhitespaceToken.prototype.toCSSString = function() { return \" \"; }\r\n\r\nfunction CDOToken() { return this; }\r\nCDOToken.prototype = new CSSParserToken;\r\nCDOToken.prototype.tokenType = \"CDO\";\r\nCDOToken.prototype.toCSSString = function() { return \"<!--\"; }\r\n\r\nfunction CDCToken() { return this; }\r\nCDCToken.prototype = new CSSParserToken;\r\nCDCToken.prototype.tokenType = \"CDC\";\r\nCDCToken.prototype.toCSSString = function() { return \"-->\"; }\r\n\r\nfunction ColonToken() { return this; }\r\nColonToken.prototype = new CSSParserToken;\r\nColonToken.prototype.tokenType = \":\";\r\n\r\nfunction SemicolonToken() { return this; }\r\nSemicolonToken.prototype = new CSSParserToken;\r\nSemicolonToken.prototype.tokenType = \";\";\r\n\r\nfunction GroupingToken() { return this; }\r\nGroupingToken.prototype = new CSSParserToken;\r\n\r\nfunction OpenCurlyToken() { this.value = \"{\"; this.mirror = \"}\"; return this; }\r\nOpenCurlyToken.prototype = new GroupingToken;\r\nOpenCurlyToken.prototype.tokenType = \"{\";\r\n\r\nfunction CloseCurlyToken() { this.value = \"}\"; this.mirror = \"{\"; return this; }\r\nCloseCurlyToken.prototype = new GroupingToken;\r\nCloseCurlyToken.prototype.tokenType = \"}\";\r\n\r\nfunction OpenSquareToken() { this.value = \"[\"; this.mirror = \"]\"; return this; }\r\nOpenSquareToken.prototype = new GroupingToken;\r\nOpenSquareToken.prototype.tokenType = \"[\";\r\n\r\nfunction CloseSquareToken() { this.value = \"]\"; this.mirror = \"[\"; return this; }\r\nCloseSquareToken.prototype = new GroupingToken;\r\nCloseSquareToken.prototype.tokenType = \"]\";\r\n\r\nfunction OpenParenToken() { this.value = \"(\"; this.mirror = \")\"; return this; }\r\nOpenParenToken.prototype = new GroupingToken;\r\nOpenParenToken.prototype.tokenType = \"(\";\r\n\r\nfunction CloseParenToken() { this.value = \")\"; this.mirror = \"(\"; return this; }\r\nCloseParenToken.prototype = new GroupingToken;\r\nCloseParenToken.prototype.tokenType = \")\";\r\n\r\nfunction IncludeMatchToken() { return this; }\r\nIncludeMatchToken.prototype = new CSSParserToken;\r\nIncludeMatchToken.prototype.tokenType = \"~=\";\r\n\r\nfunction DashMatchToken() { return this; }\r\nDashMatchToken.prototype = new CSSParserToken;\r\nDashMatchToken.prototype.tokenType = \"|=\";\r\n\r\nfunction PrefixMatchToken() { return this; }\r\nPrefixMatchToken.prototype = new CSSParserToken;\r\nPrefixMatchToken.prototype.tokenType = \"^=\";\r\n\r\nfunction SuffixMatchToken() { return this; }\r\nSuffixMatchToken.prototype = new CSSParserToken;\r\nSuffixMatchToken.prototype.tokenType = \"$=\";\r\n\r\nfunction SubstringMatchToken() { return this; }\r\nSubstringMatchToken.prototype = new CSSParserToken;\r\nSubstringMatchToken.prototype.tokenType = \"*=\";\r\n\r\nfunction ColumnToken() { return this; }\r\nColumnToken.prototype = new CSSParserToken;\r\nColumnToken.prototype.tokenType = \"||\";\r\n\r\nfunction EOFToken() { return this; }\r\nEOFToken.prototype = new CSSParserToken;\r\nEOFToken.prototype.tokenType = \"EOF\";\r\nEOFToken.prototype.toCSSString = function() { return \"\"; }\r\n\r\nfunction DelimToken(code) {\r\n\tthis.value = stringFromCode(code);\r\n\treturn this;\r\n}\r\nDelimToken.prototype = new CSSParserToken;\r\nDelimToken.prototype.tokenType = \"DELIM\";\r\nDelimToken.prototype.toString = function() { return \"DELIM(\"+this.value+\")\"; }\r\nDelimToken.prototype.toCSSString = function() {\r\n\treturn (this.value == \"\\\\\") ? \"\\\\\\n\" : this.value;\r\n}\r\n\r\nfunction CommaToken() { return this; }\r\nCommaToken.prototype = new DelimToken;\r\nCommaToken.prototype.tokenType = \",\";\r\n\r\nfunction StringValuedToken() { return this; }\r\nStringValuedToken.prototype = new CSSParserToken;\r\nStringValuedToken.prototype.ASCIIMatch = function(str) {\r\n\treturn this.value.toLowerCase() == str.toLowerCase();\r\n}\r\n\r\nfunction IdentifierToken(val) {\r\n\tthis.value = val;\r\n}\r\nIdentifierToken.prototype = new StringValuedToken;\r\nIdentifierToken.prototype.tokenType = \"IDENT\";\r\nIdentifierToken.prototype.toString = function() { return \"IDENT(\"+this.value+\")\"; }\r\nIdentifierToken.prototype.toCSSString = function() {\r\n\treturn escapeIdent(this.value);\r\n}\r\n\r\nfunction FunctionToken(val) {\r\n\tthis.value = val;\r\n\tthis.mirror = \")\";\r\n}\r\nFunctionToken.prototype = new StringValuedToken;\r\nFunctionToken.prototype.tokenType = \"FUNCTION\";\r\nFunctionToken.prototype.toString = function() { return \"FUNCTION(\"+this.value+\")\"; }\r\nFunctionToken.prototype.toCSSString = function() {\r\n\treturn escapeIdent(this.value) + \"(\";\r\n}\r\n\t\r\nfunction AtKeywordToken(val) {\r\n\tthis.value = val;\r\n}\r\nAtKeywordToken.prototype = new StringValuedToken;\r\nAtKeywordToken.prototype.tokenType = \"AT-KEYWORD\";\r\nAtKeywordToken.prototype.toString = function() { return \"AT(\"+this.value+\")\"; }\r\nAtKeywordToken.prototype.toCSSString = function() {\r\n\treturn \"@\" + escapeIdent(this.value);\r\n}\r\n\r\nfunction HashToken(val) {\r\n\tthis.value = val;\r\n\tthis.type = \"unrestricted\";\r\n}\r\nHashToken.prototype = new StringValuedToken;\r\nHashToken.prototype.tokenType = \"HASH\";\r\nHashToken.prototype.toString = function() { return \"HASH(\"+this.value+\")\"; }\r\nHashToken.prototype.toCSSString = function() {\r\n\tvar escapeValue = (this.type == \"id\") ? escapeIdent : escapeHash;\r\n\treturn \"#\" + escapeValue(this.value);\r\n}\r\n\r\nfunction StringToken(val) {\r\nthis.value = val;\r\n}\r\nStringToken.prototype = new StringValuedToken;\r\nStringToken.prototype.tokenType = \"STRING\";\r\nStringToken.prototype.toString = function() {\r\n\treturn '\"' + escapeString(this.value) + '\"';\r\n}\r\n\r\nfunction URLToken(val) {\r\n\tthis.value = val;\r\n}\r\nURLToken.prototype = new StringValuedToken;\r\nURLToken.prototype.tokenType = \"URL\";\r\nURLToken.prototype.toString = function() { return \"URL(\"+this.value+\")\"; }\r\nURLToken.prototype.toCSSString = function() {\r\n\treturn 'url(\"' + escapeString(this.value) + '\")';\r\n}\r\n\r\nfunction NumberToken() {\r\n\tthis.value = null;\r\n\tthis.type = \"integer\";\r\n\tthis.repr = \"\";\r\n}\r\nNumberToken.prototype = new CSSParserToken;\r\nNumberToken.prototype.tokenType = \"NUMBER\";\r\nNumberToken.prototype.toString = function() {\r\n\tif(this.type == \"integer\")\r\n\t\treturn \"INT(\"+this.value+\")\";\r\n\treturn \"NUMBER(\"+this.value+\")\";\r\n}\r\nNumberToken.prototype.toJSON = function() {\r\n\tvar json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\r\n\tjson.value = this.value;\r\n\tjson.type = this.type;\r\n\tjson.repr = this.repr;\r\n\treturn json;\r\n}\r\nNumberToken.prototype.toCSSString = function() { return this.repr; };\r\n\r\nfunction PercentageToken() {\r\n\tthis.value = null;\r\n\tthis.repr = \"\";\r\n}\r\nPercentageToken.prototype = new CSSParserToken;\r\nPercentageToken.prototype.tokenType = \"PERCENTAGE\";\r\nPercentageToken.prototype.toString = function() { return \"PERCENTAGE(\"+this.value+\")\"; }\r\nPercentageToken.prototype.toCSSString = function() { return this.repr + \"%\"; }\r\n\r\nfunction DimensionToken() {\r\n\tthis.value = null;\r\n\tthis.type = \"integer\";\r\n\tthis.repr = \"\";\r\n\tthis.unit = \"\";\r\n}\r\nDimensionToken.prototype = new CSSParserToken;\r\nDimensionToken.prototype.tokenType = \"DIMENSION\";\r\nDimensionToken.prototype.toString = function() { return \"DIM(\"+this.value+\",\"+this.unit+\")\"; }\r\nDimensionToken.prototype.toCSSString = function() {\r\n\tvar source = this.repr;\r\n\tvar unit = escapeIdent(this.unit);\r\n\tif(unit[0].toLowerCase() == \"e\" && (unit[1] == \"-\" || between(unit.charCodeAt(1), 0x30, 0x39))) {\r\n\t\t// Unit is ambiguous with scinot\r\n\t\t// Remove the leading \"e\", replace with escape.\r\n\t\tunit = \"\\\\65 \" + unit.slice(1, unit.length);\r\n\t}\r\n\treturn source+unit;\r\n}\r\n\r\nfunction escapeIdent(string) {\r\n\tstring = ''+string;\r\n\tvar result = '';\r\n\tvar firstcode = string.charCodeAt(0);\r\n\tfor(var i = 0; i < string.length; i++) {\r\n\t\tvar code = string.charCodeAt(i);\r\n\t\tif(code == 0x0) {\r\n\t\t\tthrow new InvalidCharacterError('Invalid character: the input contains U+0000.');\r\n\t\t}\r\n\r\n\t\tif(\r\n\t\t\tbetween(code, 0x1, 0x1f) || code == 0x7f ||\r\n\t\t\t(i == 0 && between(code, 0x30, 0x39)) ||\r\n\t\t\t(i == 1 && between(code, 0x30, 0x39) && firstcode == 0x2d)\r\n\t\t) {\r\n\t\t\tresult += '\\\\' + code.toString(16) + ' ';\r\n\t\t} else if(\r\n\t\t\tcode >= 0x80 ||\r\n\t\t\tcode == 0x2d ||\r\n\t\t\tcode == 0x5f ||\r\n\t\t\tbetween(code, 0x30, 0x39) ||\r\n\t\t\tbetween(code, 0x41, 0x5a) ||\r\n\t\t\tbetween(code, 0x61, 0x7a)\r\n\t\t) {\r\n\t\t\tresult += string[i];\r\n\t\t} else {\r\n\t\t\tresult += '\\\\' + string[i];\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nfunction escapeHash(string) {\r\n\t// Escapes the contents of \"unrestricted\"-type hash tokens.\r\n\t// Won't preserve the ID-ness of \"id\"-type hash tokens;\r\n\t// use escapeIdent() for that.\r\n\tstring = ''+string;\r\n\tvar result = '';\r\n\tvar firstcode = string.charCodeAt(0);\r\n\tfor(var i = 0; i < string.length; i++) {\r\n\t\tvar code = string.charCodeAt(i);\r\n\t\tif(code == 0x0) {\r\n\t\t\tthrow new InvalidCharacterError('Invalid character: the input contains U+0000.');\r\n\t\t}\r\n\r\n\t\tif(\r\n\t\t\tcode >= 0x80 ||\r\n\t\t\tcode == 0x2d ||\r\n\t\t\tcode == 0x5f ||\r\n\t\t\tbetween(code, 0x30, 0x39) ||\r\n\t\t\tbetween(code, 0x41, 0x5a) ||\r\n\t\t\tbetween(code, 0x61, 0x7a)\r\n\t\t) {\r\n\t\t\tresult += string[i];\r\n\t\t} else {\r\n\t\t\tresult += '\\\\' + code.toString(16) + ' ';\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nfunction escapeString(string) {\r\n\tstring = ''+string;\r\n\tvar result = '';\r\n\tfor(var i = 0; i < string.length; i++) {\r\n\t\tvar code = string.charCodeAt(i);\r\n\r\n\t\tif(code == 0x0) {\r\n\t\t\tthrow new InvalidCharacterError('Invalid character: the input contains U+0000.');\r\n\t\t}\r\n\r\n\t\tif(between(code, 0x1, 0x1f) || code == 0x7f) {\r\n\t\t\tresult += '\\\\' + code.toString(16) + ' ';\r\n\t\t} else if(code == 0x22 || code == 0x5c) {\r\n\t\t\tresult += '\\\\' + string[i];\r\n\t\t} else {\r\n\t\t\tresult += string[i];\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n// Exportation.\r\ncssSyntax.tokenize = tokenize;\r\ncssSyntax.IdentifierToken = IdentifierToken;\r\ncssSyntax.FunctionToken = FunctionToken;\r\ncssSyntax.AtKeywordToken = AtKeywordToken;\r\ncssSyntax.HashToken = HashToken;\r\ncssSyntax.StringToken = StringToken;\r\ncssSyntax.BadStringToken = BadStringToken;\r\ncssSyntax.URLToken = URLToken;\r\ncssSyntax.BadURLToken = BadURLToken;\r\ncssSyntax.DelimToken = DelimToken;\r\ncssSyntax.NumberToken = NumberToken;\r\ncssSyntax.PercentageToken = PercentageToken;\r\ncssSyntax.DimensionToken = DimensionToken;\r\ncssSyntax.IncludeMatchToken = IncludeMatchToken;\r\ncssSyntax.DashMatchToken = DashMatchToken;\r\ncssSyntax.PrefixMatchToken = PrefixMatchToken;\r\ncssSyntax.SuffixMatchToken = SuffixMatchToken;\r\ncssSyntax.SubstringMatchToken = SubstringMatchToken;\r\ncssSyntax.ColumnToken = ColumnToken;\r\ncssSyntax.WhitespaceToken = WhitespaceToken;\r\ncssSyntax.CDOToken = CDOToken;\r\ncssSyntax.CDCToken = CDCToken;\r\ncssSyntax.ColonToken = ColonToken;\r\ncssSyntax.SemicolonToken = SemicolonToken;\r\ncssSyntax.CommaToken = CommaToken;\r\ncssSyntax.OpenParenToken = OpenParenToken;\r\ncssSyntax.CloseParenToken = CloseParenToken;\r\ncssSyntax.OpenSquareToken = OpenSquareToken;\r\ncssSyntax.CloseSquareToken = CloseSquareToken;\r\ncssSyntax.OpenCurlyToken = OpenCurlyToken;\r\ncssSyntax.CloseCurlyToken = CloseCurlyToken;\r\ncssSyntax.EOFToken = EOFToken;\r\ncssSyntax.CSSParserToken = CSSParserToken;\r\ncssSyntax.GroupingToken = GroupingToken;\r\n\r\n//\r\n// css parser\r\n//\r\n\r\nfunction TokenStream(tokens) {\r\n\t// Assume that tokens is an array.\r\n\tthis.tokens = tokens;\r\n\tthis.i = -1;\r\n}\r\nTokenStream.prototype.tokenAt = function(i) {\r\n\tif(i < this.tokens.length)\r\n\t\treturn this.tokens[i];\r\n\treturn new EOFToken();\r\n}\r\nTokenStream.prototype.consume = function(num) {\r\n\tif(num === undefined) num = 1;\r\n\tthis.i += num;\r\n\tthis.token = this.tokenAt(this.i);\r\n\t//console.log(this.i, this.token);\r\n\treturn true;\r\n}\r\nTokenStream.prototype.next = function() {\r\n\treturn this.tokenAt(this.i+1);\r\n}\r\nTokenStream.prototype.reconsume = function() {\r\n\tthis.i--;\r\n}\r\n\r\nfunction parseerror(s, msg) {\r\n\tconsole.log(\"Parse error at token \" + s.i + \": \" + s.token + \".\\n\" + msg);\r\n\treturn true;\r\n}\r\nfunction donothing(){ return true; };\r\n\r\nfunction consumeAListOfRules(s, topLevel) {\r\n\tvar rules = new TokenList();\r\n\tvar rule;\r\n\twhile(s.consume()) {\r\n\t\tif(s.token instanceof WhitespaceToken) {\r\n\t\t\tcontinue;\r\n\t\t} else if(s.token instanceof EOFToken) {\r\n\t\t\treturn rules;\r\n\t\t} else if(s.token instanceof CDOToken || s.token instanceof CDCToken) {\r\n\t\t\tif(topLevel == \"top-level\") continue;\r\n\t\t\ts.reconsume();\r\n\t\t\tif(rule = consumeAStyleRule(s)) rules.push(rule);\r\n\t\t} else if(s.token instanceof AtKeywordToken) {\r\n\t\t\ts.reconsume();\r\n\t\t\tif(rule = consumeAnAtRule(s)) rules.push(rule);\r\n\t\t} else {\r\n\t\t\ts.reconsume();\r\n\t\t\tif(rule = consumeAStyleRule(s)) rules.push(rule);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction consumeAnAtRule(s) {\r\n\ts.consume();\r\n\tvar rule = new AtRule(s.token.value);\r\n\twhile(s.consume()) {\r\n\t\tif(s.token instanceof SemicolonToken || s.token instanceof EOFToken) {\r\n\t\t\treturn rule;\r\n\t\t} else if(s.token instanceof OpenCurlyToken) {\r\n\t\t\trule.value = consumeASimpleBlock(s);\r\n\t\t\treturn rule;\r\n\t\t} else if(s.token instanceof SimpleBlock && s.token.name == \"{\") {\r\n\t\t\trule.value = s.token;\r\n\t\t\treturn rule;\r\n\t\t} else {\r\n\t\t\ts.reconsume();\r\n\t\t\trule.prelude.push(consumeAComponentValue(s));\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction consumeAStyleRule(s) {\r\n\tvar rule = new StyleRule();\r\n\twhile(s.consume()) {\r\n\t\tif(s.token instanceof EOFToken) {\r\n\t\t\tparseerror(s, \"Hit EOF when trying to parse the prelude of a qualified rule.\");\r\n\t\t\treturn;\r\n\t\t} else if(s.token instanceof OpenCurlyToken) {\r\n\t\t\trule.value = consumeASimpleBlock(s);\r\n\t\t\treturn rule;\r\n\t\t} else if(s.token instanceof SimpleBlock && s.token.name == \"{\") {\r\n\t\t\trule.value = s.token;\r\n\t\t\treturn rule;\r\n\t\t} else {\r\n\t\t\ts.reconsume();\r\n\t\t\trule.prelude.push(consumeAComponentValue(s));\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction consumeAListOfDeclarations(s) {\r\n\tvar decls = new TokenList();\r\n\twhile(s.consume()) {\r\n\t\tif(s.token instanceof WhitespaceToken || s.token instanceof SemicolonToken) {\r\n\t\t\tdonothing();\r\n\t\t} else if(s.token instanceof EOFToken) {\r\n\t\t\treturn decls;\r\n\t\t} else if(s.token instanceof AtKeywordToken) {\r\n\t\t\ts.reconsume();\r\n\t\t\tdecls.push(consumeAnAtRule(s));\r\n\t\t} else if(s.token instanceof IdentifierToken) {\r\n\t\t\tvar temp = [s.token];\r\n\t\t\twhile(!(s.next() instanceof SemicolonToken || s.next() instanceof EOFToken))\r\n\t\t\t\ttemp.push(consumeAComponentValue(s));\r\n\t\t\tvar decl;\r\n\t\t\tif(decl = consumeADeclaration(new TokenStream(temp))) decls.push(decl);\r\n\t\t} else {\r\n\t\t\tparseerror(s);\r\n\t\t\treconsume();\r\n\t\t\twhile(!(s.next() instanceof SemicolonToken || s.next() instanceof EOFToken))\r\n\t\t\t\tconsumeAComponentValue(s);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction consumeADeclaration(s) {\r\n\t// Assumes that the next input token will be an ident token.\r\n\ts.consume();\r\n\tvar decl = new Declaration(s.token.value);\r\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\r\n\tif(!(s.next() instanceof ColonToken)) {\r\n\t\tparseerror(s);\r\n\t\treturn;\r\n\t} else {\r\n\t\ts.consume();\r\n\t}\r\n\twhile(!(s.next() instanceof EOFToken)) {\r\n\t\tdecl.value.push(consumeAComponentValue(s));\r\n\t}\r\n\tvar foundImportant = false;\r\n\tfor(var i = decl.value.length - 1; i >= 0; i--) {\r\n\t\tif(decl.value[i] instanceof WhitespaceToken) {\r\n\t\t\tcontinue;\r\n\t\t} else if(decl.value[i] instanceof IdentifierToken && decl.value[i].ASCIIMatch(\"important\")) {\r\n\t\t\tfoundImportant = true;\r\n\t\t} else if(foundImportant && decl.value[i] instanceof DelimToken && decl.value[i].value == \"!\") {\r\n\t\t\tdecl.value.splice(i, decl.value.length);\r\n\t\t\tdecl.important = true;\r\n\t\t\tbreak;\r\n\t\t} else {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn decl;\r\n}\r\n\r\nfunction consumeAComponentValue(s) {\r\n\ts.consume();\r\n\tif(s.token instanceof OpenCurlyToken || s.token instanceof OpenSquareToken || s.token instanceof OpenParenToken)\r\n\t\treturn consumeASimpleBlock(s);\r\n\tif(s.token instanceof FunctionToken)\r\n\t\treturn consumeAFunction(s);\r\n\treturn s.token;\r\n}\r\n\r\nfunction consumeASimpleBlock(s) {\r\n\tvar mirror = s.token.mirror;\r\n\tvar block = new SimpleBlock(s.token.value);\r\n\twhile(s.consume()) {\r\n\t\tif(s.token instanceof EOFToken || (s.token instanceof GroupingToken && s.token.value == mirror))\r\n\t\t\treturn block;\r\n\t\telse {\r\n\t\t\ts.reconsume();\r\n\t\t\tblock.value.push(consumeAComponentValue(s));\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction consumeAFunction(s) {\r\n\tvar func = new Func(s.token.value);\r\n\twhile(s.consume()) {\r\n\t\tif(s.token instanceof EOFToken || s.token instanceof CloseParenToken)\r\n\t\t\treturn func;\r\n\t\telse {\r\n\t\t\ts.reconsume();\r\n\t\t\tfunc.value.push(consumeAComponentValue(s));\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction normalizeInput(input) {\r\n\tif(typeof input == \"string\")\r\n\t\treturn new TokenStream(tokenize(input));\r\n\tif(input instanceof TokenStream)\r\n\t\treturn input;\r\n\tif(input.length !== undefined)\r\n\t\treturn new TokenStream(input);\r\n\telse throw SyntaxError(input);\r\n}\r\n\r\nfunction parseAStylesheet(s) {\r\n\ts = normalizeInput(s);\r\n\tvar sheet = new Stylesheet();\r\n\tsheet.value = consumeAListOfRules(s, \"top-level\");\r\n\treturn sheet;\r\n}\r\n\r\nfunction parseAListOfRules(s) {\r\n\ts = normalizeInput(s);\r\n\treturn consumeAListOfRules(s);\r\n}\r\n\r\nfunction parseARule(s) {\r\n\ts = normalizeInput(s);\r\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\r\n\tif(s.next() instanceof EOFToken) throw SyntaxError();\r\n\tif(s.next() instanceof AtKeywordToken) {\r\n\t\tvar rule = consumeAnAtRule(s);\r\n\t} else {\r\n\t\tvar rule = consumeAStyleRule(s);\r\n\t\tif(!rule) throw SyntaxError();\r\n\t}\r\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\r\n\tif(s.next() instanceof EOFToken)\r\n\t\treturn rule;\r\n\tthrow SyntaxError();\r\n}\r\n\r\nfunction parseADeclaration(s) {\r\n\ts = normalizeInput(s);\r\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\r\n\tif(!(s.next() instanceof IdentifierToken)) throw SyntaxError();\r\n\tvar decl = consumeADeclaration(s);\r\n\tif(!decl) { throw new SyntaxError() }\r\n\treturn decl;\r\n}\r\n\r\nfunction parseAListOfDeclarations(s) {\r\n\ts = normalizeInput(s);\r\n\treturn consumeAListOfDeclarations(s);\r\n}\r\n\r\nfunction parseAComponentValue(s) {\r\n\ts = normalizeInput(s);\r\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\r\n\tif(s.next() instanceof EOFToken) throw SyntaxError();\r\n\tvar val = consumeAComponentValue(s);\r\n\tif(!val) throw SyntaxError();\r\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\r\n\tif(!(s.next() instanceof EOFToken)) throw new SyntaxError();\r\n\treturn val;\r\n}\r\n\r\nfunction parseAListOfComponentValues(s) {\r\n\ts = normalizeInput(s);\r\n\tvar vals = [];\r\n\twhile(true) {\r\n\t\tvar val = consumeAComponentValue(s);\r\n\t\tif(val instanceof EOFToken)\r\n\t\t\treturn vals\r\n\t\telse\r\n\t\t\tvals.push(val);\r\n\t}\r\n}\r\n\r\nfunction parseACommaSeparatedListOfComponentValues(s) {\r\n\ts = normalizeInput(s);\r\n\tvar listOfCVLs = [];\r\n\twhile(true) {\r\n\t\tvar vals = [];\r\n\t\twhile(true) {\r\n\t\t\tvar val = consumeAComponentValue(s);\r\n\t\t\tif(val instanceof EOFToken) {\r\n\t\t\t\tlistOfCVLs.push(vals);\r\n\t\t\t\treturn listOfCVLs;\r\n\t\t\t} else if(val instanceof CommaToken) {\r\n\t\t\t\tlistOfCVLs.push(vals);\r\n\t\t\t\tbreak;\r\n\t\t\t} else {\r\n\t\t\t\tvals.push(val);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction CSSParserRule() { return this; }\r\nCSSParserRule.prototype.toString = function(indent) {\r\n\treturn JSON.stringify(this,null,indent);\r\n}\r\n\r\nfunction Stylesheet() {\r\n\tthis.value = new TokenList();\r\n\treturn this;\r\n}\r\nStylesheet.prototype = new CSSParserRule;\r\nStylesheet.prototype.type = \"STYLESHEET\";\r\nStylesheet.prototype.toCSSString = function() { return this.value.toCSSString(\"\\n\"); }\r\n\r\nfunction AtRule(name) {\r\n\tthis.name = name;\r\n\tthis.prelude = new TokenList();\r\n\tthis.value = null;\r\n\treturn this;\r\n}\r\nAtRule.prototype = new CSSParserRule;\r\nAtRule.prototype.toCSSString = function() { \r\n\tif(this.value) {\r\n\t\treturn \"@\" + escapeIdent(this.name) + \" \" + this.prelude.toCSSString() + this.value.toCSSString(); \r\n\t} else {\r\n\t\treturn \"@\" + escapeIdent(this.name) + \" \" + this.prelude.toCSSString() + '; '; \r\n\t}\r\n}\r\nAtRule.prototype.getStylesheet = function() {\r\n\treturn this.asStylesheet || (this.asStylesheet = this.value ? parseAStylesheet(this.value.value) : new Stylesheet());\r\n}\r\n\r\nfunction StyleRule() {\r\n\tthis.prelude = new TokenList(); this.selector = this.prelude;\r\n\tthis.value = null;\r\n\treturn this;\r\n}\r\nStyleRule.prototype = new CSSParserRule;\r\nStyleRule.prototype.type = \"STYLE-RULE\";\r\nStyleRule.prototype.toCSSString = function() {\r\n\treturn this.prelude.toCSSString() + this.value.toCSSString();\r\n}\r\nStyleRule.prototype.getSelector = function() {\r\n\treturn this.prelude;\r\n}\r\nStyleRule.prototype.getDeclarations = function() {\r\n\tif(!(this.value instanceof SimpleBlock)) { return new TokenList(); }\r\n\tvar value = this.value.value; return parseAListOfDeclarations(value);\r\n}\r\n\r\n\r\nfunction Declaration(name) {\r\n\tthis.name = name;\r\n\tthis.value = new TokenList();\r\n\tthis.important = false;\r\n\treturn this;\r\n}\r\nDeclaration.prototype = new CSSParserRule;\r\nDeclaration.prototype.type = \"DECLARATION\";\r\nDeclaration.prototype.toCSSString = function() {\r\n\treturn this.name + ':' + this.value.toCSSString() + '; ';\r\n}\r\n\r\nfunction SimpleBlock(type) {\r\n\tthis.name = type;\r\n\tthis.value = new TokenList();\r\n\treturn this;\r\n}\r\nSimpleBlock.prototype = new CSSParserRule;\r\nSimpleBlock.prototype.type = \"BLOCK\";\r\nSimpleBlock.prototype.toCSSString = function() {\r\n\tswitch(this.name) {\r\n\t\tcase \"(\":\r\n\t\t\treturn \"(\" + this.value.toCSSString() + \")\";\r\n\t\t\t\r\n\t\tcase \"[\":\r\n\t\t\treturn \"[\" + this.value.toCSSString() + \"]\";\r\n\t\t\t\r\n\t\tcase \"{\":\r\n\t\t\treturn \"{\" + this.value.toCSSString() + \"}\";\r\n\t\t\r\n\t\tdefault: //best guess\r\n\t\t\treturn this.name + this.value.toCSSString() + this.name;\r\n\t}\r\n}\r\n\r\nfunction Func(name) {\r\n\tthis.name = name;\r\n\tthis.value = new TokenList();\r\n\treturn this;\r\n}\r\nFunc.prototype = new CSSParserRule;\r\nFunc.prototype.type = \"FUNCTION\";\r\nFunc.prototype.toCSSString = function() {\r\n\treturn this.name+'('+this.value.toCSSString()+')';\r\n}\r\nFunc.prototype.getArguments = function() {\r\n\tvar args = []; var arg = []; var value = this.value;\r\n\tfor(var i = 0; i<value.length; i++) {\r\n\t\tif(value[i].value == ',') {\r\n\t\t\targs.push(arg); arg = [];\r\n\t\t} else {\r\n\t\t\targ.push(value[i])\r\n\t\t}\r\n\t}\r\n\tif(args.length > 0 || arg.length > 0) { args.push(arg); }\r\n\treturn args;\r\n}\r\n\r\nfunction FuncArg() {\r\n\tthis.value = new TokenList();\r\n\treturn this;\r\n}\r\nFuncArg.prototype = new CSSParserRule;\r\nFuncArg.prototype.type = \"FUNCTION-ARG\";\r\nFuncArg.prototype.toCSSString = function() {\r\n\treturn this.value.toCSSString()+', ';\r\n}\r\n\r\n// Exportation.\r\ncssSyntax.CSSParserRule = CSSParserRule;\r\ncssSyntax.Stylesheet = Stylesheet;\r\ncssSyntax.AtRule = AtRule;\r\ncssSyntax.StyleRule = StyleRule;\r\ncssSyntax.Declaration = Declaration;\r\ncssSyntax.SimpleBlock = SimpleBlock;\r\ncssSyntax.Func = Func;\r\ncssSyntax.parseAStylesheet = parseAStylesheet;\r\ncssSyntax.parseAListOfRules = parseAListOfRules;\r\ncssSyntax.parseARule = parseARule;\r\ncssSyntax.parseADeclaration = parseADeclaration;\r\ncssSyntax.parseAListOfDeclarations = parseAListOfDeclarations;\r\ncssSyntax.parseAComponentValue = parseAComponentValue;\r\ncssSyntax.parseAListOfComponentValues = parseAListOfComponentValues;\r\ncssSyntax.parseACommaSeparatedListOfComponentValues = parseACommaSeparatedListOfComponentValues;\r\ncssSyntax.parse = parseAStylesheet;\r\ncssSyntax.parseCSSValue = parseAListOfComponentValues;\r\n\r\nreturn cssSyntax;\r\n\r\n}());\nrequire.define('src/core/css-syntax.js');","module.exports = (function(window, document) { \"use strict\";\r\n\r\n\trequire('src/core/polyfill-dom-console.js');\r\n\r\n\t//\r\n\t// some other basic om code\r\n\t//\r\n\tvar domEvents = {\r\n\t\t\r\n\t\t//\r\n\t\t// the following functions are about event cloning\r\n\t\t//\r\n\t\tcloneMouseEvent: function cloneMouseEvent(e) {\r\n\t\t\tvar evt = document.createEvent(\"MouseEvent\");\r\n\t\t\tevt.initMouseEvent( \r\n\t\t\t\te.type, \r\n\t\t\t\te.canBubble||e.bubbles, \r\n\t\t\t\te.cancelable, \r\n\t\t\t\te.view, \r\n\t\t\t\te.detail, \r\n\t\t\t\te.screenX, \r\n\t\t\t\te.screenY, \r\n\t\t\t\te.clientX, \r\n\t\t\t\te.clientY, \r\n\t\t\t\te.ctrlKey, \r\n\t\t\t\te.altKey, \r\n\t\t\t\te.shiftKey, \r\n\t\t\t\te.metaKey, \r\n\t\t\t\te.button, \r\n\t\t\t\te.relatedTarget\r\n\t\t\t);\r\n\t\t\treturn evt;\r\n\t\t},\r\n\t\t\r\n\t\tcloneKeyboardEvent: function cloneKeyboardEvent(e) {\r\n\t\t\t// TODO: this doesn't work cross-browser...\r\n\t\t\t// see https://gist.github.com/termi/4654819/ for the huge code\r\n\t\t\treturn domEvents.cloneCustomEvent(e);\r\n\t\t},\r\n\t\t\r\n\t\tcloneCustomEvent: function cloneCustomEvent(e) {\r\n\t\t\tvar ne = document.createEvent(\"CustomEvent\");\r\n\t\t\tne.initCustomEvent(e.type, e.canBubble||e.bubbles, e.cancelable, \"detail\" in e ? e.detail : e);\r\n\t\t\tfor(var prop in e) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif(e[prop] != ne[prop] && e[prop] != e.target) {\r\n\t\t\t\t\t\ttry { ne[prop] = e[prop]; }\r\n\t\t\t\t\t\tcatch (ex) { Object.defineProperty(ne,prop,{get:function() { return e[prop]} }) }\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch(ex) {}\r\n\t\t\t}\r\n\t\t\treturn ne;\r\n\t\t},\r\n\t\t\r\n\t\tcloneEvent: function cloneEvent(e) {\r\n\t\t\t\r\n\t\t\tif(e instanceof MouseEvent) {\r\n\t\t\t\treturn domEvents.cloneMouseEvent(e);\r\n\t\t\t} else if(e instanceof KeyboardEvent) {\r\n\t\t\t\treturn domEvents.cloneKeyboardEvent(e);\r\n\t\t\t} else {\r\n\t\t\t\treturn domEvents.cloneCustomEvent(e);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// allows you to drop event support to any class easily\r\n\t\t//\r\n\t\tEventTarget: {\r\n\t\t\timplementsIn: function(eventClass, static_class) {\r\n\t\t\t\t\r\n\t\t\t\tif(!static_class && typeof(eventClass)==\"function\") eventClass=eventClass.prototype;\r\n\t\t\t\t\r\n\t\t\t\teventClass.dispatchEvent = domEvents.EventTarget.prototype.dispatchEvent;\r\n\t\t\t\teventClass.addEventListener = domEvents.EventTarget.prototype.addEventListener;\r\n\t\t\t\teventClass.removeEventListener = domEvents.EventTarget.prototype.removeEventListener;\r\n\t\t\t\t\r\n\t\t\t},\r\n\t\t\tprototype: {}\r\n\t\t}\r\n\t\t\r\n\t};\r\n\r\n\tdomEvents.EventTarget.prototype.addEventListener = function(eventType,f) {\r\n\t\tif(!this.eventListeners) this.eventListeners=[];\r\n\t\t\r\n\t\tvar ls = (this.eventListeners[eventType] || (this.eventListeners[eventType]=[]));\r\n\t\tif(ls.indexOf(f)==-1) {\r\n\t\t\tls.push(f);\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n\tdomEvents.EventTarget.prototype.removeEventListener = function(eventType,f) {\r\n\t\tif(!this.eventListeners) this.eventListeners=[];\r\n\r\n\t\tvar ls = (this.eventListeners[eventType] || (this.eventListeners[eventType]=[])), i;\r\n\t\tif((i=ls.indexOf(f))!==-1) {\r\n\t\t\tls.splice(i,1);\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n\tdomEvents.EventTarget.prototype.dispatchEvent = function(event_or_type) {\r\n\t\tif(!this.eventListeners) this.eventListeners=[];\r\n\t\t\r\n\t\t// abort quickly when no listener has been set up\r\n\t\tif(typeof(event_or_type) == \"string\") {\r\n\t\t\tif(!this.eventListeners[event_or_type] || this.eventListeners[event_or_type].length==0) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif(!this.eventListeners[event_or_type.type] || this.eventListeners[event_or_type.type].length==0) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// convert the event\r\n\t\tvar event = event_or_type;\r\n\t\tfunction setUpPropertyForwarding(e,ee,key) {\r\n\t\t\tObject.defineProperty(ee,key,{\r\n\t\t\t\tget:function() {\r\n\t\t\t\t\tvar v = e[key]; \r\n\t\t\t\t\tif(typeof(v)==\"function\") {\r\n\t\t\t\t\t\treturn v.bind(e);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn v;\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tset:function(v) {\r\n\t\t\t\t\te[key] = v;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\tfunction setUpTarget(e,v) {\r\n\t\t\ttry { Object.defineProperty(e,\"target\",{get:function() {return v}}); }\r\n\t\t\tcatch(ex) {}\r\n\t\t\tfinally {\r\n\t\t\t\t\r\n\t\t\t\tif(e.target !== v) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar ee = Object.create(Object.getPrototypeOf(e));\r\n\t\t\t\t\tee = setUpTarget(ee,v);\r\n\t\t\t\t\tfor(key in e) {\r\n\t\t\t\t\t\tif(key != \"target\") setUpPropertyForwarding(e,ee,key);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn ee;\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn e;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// try to set the target\r\n\t\tif(typeof(event)==\"object\") {\r\n\t\t\ttry { event=setUpTarget(event,this); } catch(ex) {}\r\n\t\t\t\r\n\t\t} else if(typeof(event)==\"string\") {\r\n\t\t\tevent = document.createEvent(\"CustomEvent\");\r\n\t\t\tevent.initCustomEvent(event_or_type, /*canBubble:*/ true, /*cancelable:*/ false, /*detail:*/this);\r\n\t\t\ttry { event=setUpTarget(event,this); } catch(ex) {}\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"dispatchEvent expect an Event object or a string containing the event type\");\r\n\t\t}\r\n\t\t\r\n\t\t// call all listeners\r\n\t\tvar ls = (this.eventListeners[event.type] || (this.eventListeners[event.type]=[]));\r\n\t\tfor(var i=ls.length; i--;) {\r\n\t\t\ttry { \r\n\t\t\t\tls[i](event);\r\n\t\t\t} catch(ex) {\r\n\t\t\t\tsetImmediate(function() { throw ex; });\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn event.isDefaultPrevented;\r\n\t}\r\n\t\r\n\treturn domEvents;\r\n\t\r\n})(window, document);\nrequire.define('src/core/dom-events.js');","/////////////////////////////////////////////////////////////////\r\n////                                                         ////\r\n////                 prerequirements of qSL                  ////\r\n////                                                         ////\r\n/////////////////////////////////////////////////////////////////\r\n////                                                         ////\r\n////   Please note that I require querySelectorAll to work   ////\r\n////                                                         ////\r\n////   See http://github.com/termi/CSS_selector_engine/      ////\r\n////   for a polyfill for older browsers                     ////\r\n////                                                         ////\r\n/////////////////////////////////////////////////////////////////\r\n\r\n// TODO: improve event streams\r\n// - look for a few optimizations ideas in gecko/webkit\r\n// - use arrays in CompositeEventStream to avoid nested debouncings\r\nmodule.exports = (function(window, document) { \"use strict\";\r\n\r\n\t///\r\n\t/// event stream implementation\r\n\t/// please note this is required to 'live update' the qSA requests\r\n\t///\r\n\tfunction EventStream(connect, disconnect, reconnect) {\r\n\t\tvar self=this;\r\n\t\t\r\n\t\t// validate arguments\r\n\t\tif(!disconnect) disconnect=function(){};\r\n\t\tif(!reconnect) reconnect=connect;\r\n\t\t\r\n\t\t// high-level states\r\n\t\tvar isConnected=false;\r\n\t\tvar isDisconnected=false;\r\n\t\tvar shouldDisconnect=false;\r\n\t\t\r\n\t\t// global variables\r\n\t\tvar callback=null;\r\n\t\tvar yieldEvent = function() {\r\n\t\t\t\r\n\t\t\t// call the callback function, and pend disposal\r\n\t\t\tshouldDisconnect=true;\r\n\t\t\ttry { callback && callback(self); } catch(ex) { setImmediate(function() { throw ex; }); }\r\n\t\t\t\r\n\t\t\t// if no action was taken, dispose\r\n\t\t\tif(shouldDisconnect) { dispose(); }\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t// export the interface\r\n\t\tvar schedule = this.schedule = function(newCallback) {\r\n\t\t\r\n\t\t\t// do not allow to schedule on disconnected event streams\r\n\t\t\tif(isDisconnected) { throw new Error(\"Cannot schedule on a disconnected event stream\"); }\r\n\t\t\t\r\n\t\t\t// do not allow to schedule on already scheduled event streams\r\n\t\t\tif(isConnected && !shouldDisconnect) { throw new Error(\"Cannot schedule on an already-scheduled event stream\"); }\r\n\t\t\t\r\n\t\t\t// schedule the new callback\r\n\t\t\tcallback=newCallback; shouldDisconnect=false;\r\n\t\t\t\r\n\t\t\t// reconnect to the stream\r\n\t\t\tif(isConnected) {\r\n\t\t\t\treconnect(yieldEvent);\r\n\t\t\t} else {\r\n\t\t\t\tconnect(yieldEvent);\r\n\t\t\t\tisConnected=true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tvar dispose = this.dispose = function() {\r\n\t\t\r\n\t\t\t// do not allow to dispose non-connected streams\r\n\t\t\tif(isConnected) {\r\n\t\t\t\r\n\t\t\t\t// disconnect & save resources\r\n\t\t\t\tdisconnect(); \r\n\t\t\t\tself=null; yieldEvent=null; callback=null; \r\n\t\t\t\tisConnected=false; isDisconnected=true; shouldDisconnect=false;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t///\r\n\t/// call a function every frame\r\n\t///\r\n\tfunction AnimationFrameEventStream(options) {\r\n\t\t\r\n\t\t// flag that says whether the observer is still needed or not\r\n\t\tvar rid = 0;\r\n\t\t\t\r\n\t\t// start the event stream\r\n\t\tEventStream.call(\r\n\t\t\tthis, \r\n\t\t\tfunction connect(yieldEvent) { rid = requestAnimationFrame(yieldEvent); },\r\n\t\t\tfunction disconnect() { cancelAnimationFrame(rid); }\r\n\t\t);\r\n\t\t\r\n\t}\r\n\r\n\t///\r\n\t/// call a function every timeout\r\n\t///\r\n\tfunction TimeoutEventStream(options) {\r\n\t\t\r\n\t\t// flag that says whether the observer is still needed or not\r\n\t\tvar rid = 0; var timeout=(typeof(options)==\"number\") ? (+options) : (\"timeout\" in options ? +options.timeout : 333);\r\n\t\t\t\r\n\t\t// start the event stream\r\n\t\tEventStream.call(\r\n\t\t\tthis, \r\n\t\t\tfunction connect(yieldEvent) { rid = setTimeout(yieldEvent, timeout); },\r\n\t\t\tfunction disconnect() { clearTimeout(rid); }\r\n\t\t);\r\n\t\t\r\n\t}\r\n\r\n\t///\r\n\t/// call a function every time the mouse moves\r\n\t///\r\n\tfunction MouseEventStream() {\r\n\t\tvar self=this; var pointermove = ((\"PointerEvent\" in window) ? \"pointermove\" : ((\"MSPointerEvent\" in window) ? \"MSPointerMove\" : \"mousemove\"));\r\n\r\n\t\t// flag that says whether the event is still observed or not\r\n\t\tvar scheduled = false; var interval=0;\r\n\t\t\r\n\t\t// handle the synchronous nature of mutation events\r\n\t\tvar yieldEvent=null;\r\n\t\tvar yieldEventDelayed = function() {\r\n\t\t\tif(scheduled) return;\r\n\t\t\twindow.removeEventListener(pointermove, yieldEventDelayed, true);\r\n\t\t\tscheduled = requestAnimationFrame(yieldEvent);\r\n\t\t}\r\n\t\t\r\n\t\t// start the event stream\r\n\t\tEventStream.call(\r\n\t\t\tthis, \r\n\t\t\tfunction connect(newYieldEvent) {\r\n\t\t\t\tyieldEvent=newYieldEvent;\r\n\t\t\t\twindow.addEventListener(pointermove, yieldEventDelayed, true);\r\n\t\t\t},\r\n\t\t\tfunction disconnect() { \r\n\t\t\t\twindow.removeEventListener(pointermove, yieldEventDelayed, true);\r\n\t\t\t\tcancelAnimationFrame(scheduled); yieldEventDelayed=null; yieldEvent=null; scheduled=false;\r\n\t\t\t},\r\n\t\t\tfunction reconnect(newYieldEvent) { \r\n\t\t\t\tyieldEvent=newYieldEvent; scheduled=false;\r\n\t\t\t\twindow.addEventListener(pointermove, yieldEventDelayed, true);\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t}\r\n\r\n\t///\r\n\t/// call a function every time the mouse is clicked/unclicked\r\n\t///\r\n\tfunction MouseButtonEventStream() {\r\n\t\tvar self=this; \r\n\t\tvar pointerup = ((\"PointerEvent\" in window) ? \"pointerup\" : ((\"MSPointerEvent\" in window) ? \"MSPointerUp\" : \"mouseup\"));\r\n\t\tvar pointerdown = ((\"PointerEvent\" in window) ? \"pointerdown\" : ((\"MSPointerEvent\" in window) ? \"MSPointerDown\" : \"mousedown\"));\r\n\r\n\t\t// flag that says whether the event is still observed or not\r\n\t\tvar scheduled = false; var interval=0;\r\n\t\t\r\n\t\t// handle the synchronous nature of mutation events\r\n\t\tvar yieldEvent=null;\r\n\t\tvar yieldEventDelayed = function() {\r\n\t\t\tif(scheduled) return;\r\n\t\t\twindow.removeEventListener(pointerup, yieldEventDelayed, true);\r\n\t\t\twindow.removeEventListener(pointerdown, yieldEventDelayed, true);\r\n\t\t\tscheduled = requestAnimationFrame(yieldEvent);\r\n\t\t}\r\n\t\t\r\n\t\t// start the event stream\r\n\t\tEventStream.call(\r\n\t\t\tthis, \r\n\t\t\tfunction connect(newYieldEvent) {\r\n\t\t\t\tyieldEvent=newYieldEvent;\r\n\t\t\t\twindow.addEventListener(pointerup, yieldEventDelayed, true);\r\n\t\t\t\twindow.addEventListener(pointerdown, yieldEventDelayed, true);\r\n\t\t\t},\r\n\t\t\tfunction disconnect() { \r\n\t\t\t\twindow.removeEventListener(pointerup, yieldEventDelayed, true);\r\n\t\t\t\twindow.removeEventListener(pointerdown, yieldEventDelayed, true);\r\n\t\t\t\tcancelAnimationFrame(scheduled); yieldEventDelayed=null; yieldEvent=null; scheduled=false;\r\n\t\t\t},\r\n\t\t\tfunction reconnect(newYieldEvent) { \r\n\t\t\t\tyieldEvent=newYieldEvent; scheduled=false;\r\n\t\t\t\twindow.addEventListener(pointerup, yieldEventDelayed, true);\r\n\t\t\t\twindow.addEventListener(pointerdown, yieldEventDelayed, true);\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t}\r\n\r\n\t///\r\n\t/// call a function whenever the DOM is modified\r\n\t///\r\n\tvar DOMUpdateEventStream;\r\n\tif(\"MutationObserver\" in window) {\r\n\t\tDOMUpdateEventStream = function DOMUpdateEventStream(options) {\r\n\t\t\t \r\n\t\t\t// configuration of the observer\r\n\t\t\tif(options) {\r\n\t\t\t\tvar target = \"target\" in options ? options.target : document.documentElement;\r\n\t\t\t\tvar config = { \r\n\t\t\t\t\tsubtree: \"subtree\" in options ? !!options.subtree : true, \r\n\t\t\t\t\tattributes: \"attributes\" in options ? !!options.attributes : true, \r\n\t\t\t\t\tchildList: \"childList\" in options ? !!options.childList : true, \r\n\t\t\t\t\tcharacterData: \"characterData\" in options ? !!options.characterData : false\r\n\t\t\t\t};\r\n\t\t\t} else {\r\n\t\t\t\tvar target = document.documentElement;\r\n\t\t\t\tvar config = { \r\n\t\t\t\t\tsubtree: true, \r\n\t\t\t\t\tattributes: true, \r\n\t\t\t\t\tchildList: true, \r\n\t\t\t\t\tcharacterData: false\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t// start the event stream\r\n\t\t\tvar observer = null;\r\n\t\t\tEventStream.call(\r\n\t\t\t\tthis, \r\n\t\t\t\tfunction connect(yieldEvent) { if(config) { observer=new MutationObserver(yieldEvent); observer.observe(target,config); target=null; config=null; } },\r\n\t\t\t\tfunction disconnect() { observer && observer.disconnect(); observer=null; },\r\n\t\t\t\tfunction reconnect() { observer.takeRecords(); }\r\n\t\t\t);\r\n\r\n\t\t}\r\n\t} else if(\"MutationEvent\" in window) {\r\n\t\tDOMUpdateEventStream = function DOMUpdateEventStream(options) {\r\n\t\t\tvar self=this;\r\n\r\n\t\t\t// flag that says whether the event is still observed or not\r\n\t\t\tvar scheduled = false;\r\n\t\t\t\r\n\t\t\t// configuration of the observer\r\n\t\t\tif(options) {\r\n\t\t\t\tvar target = \"target\" in options ? options.target : document.documentElement;\r\n\t\t\t} else {\r\n\t\t\t\tvar target = document.documentElement;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// handle the synchronous nature of mutation events\r\n\t\t\tvar yieldEvent=null;\r\n\t\t\tvar yieldEventDelayed = function() {\r\n\t\t\t\tif(scheduled || !yieldEventDelayed) return;\r\n\t\t\t\tdocument.removeEventListener(\"DOMContentLoaded\", yieldEventDelayed, false);\r\n\t\t\t\tdocument.removeEventListener(\"DOMContentLoaded\", yieldEventDelayed, false);\r\n\t\t\t\ttarget.removeEventListener(\"DOMSubtreeModified\", yieldEventDelayed, false);\r\n\t\t\t\tscheduled = requestAnimationFrame(yieldEvent);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// start the event stream\r\n\t\t\tEventStream.call(\r\n\t\t\t\tthis, \r\n\t\t\t\tfunction connect(newYieldEvent) {\r\n\t\t\t\t\tyieldEvent=newYieldEvent;\r\n\t\t\t\t\tdocument.addEventListener(\"DOMContentLoaded\", yieldEventDelayed, false);\r\n\t\t\t\t\ttarget.addEventListener(\"DOMSubtreeModified\", yieldEventDelayed, false);\r\n\t\t\t\t},\r\n\t\t\t\tfunction disconnect() { \r\n\t\t\t\t\tdocument.removeEventListener(\"DOMContentLoaded\", yieldEventDelayed, false);\r\n\t\t\t\t\ttarget.removeEventListener(\"DOMSubtreeModified\", yieldEventDelayed, false);\r\n\t\t\t\t\tcancelAnimationFrame(scheduled); yieldEventDelayed=null; yieldEvent=null; scheduled=false;\r\n\t\t\t\t},\r\n\t\t\t\tfunction reconnect(newYieldEvent) { \r\n\t\t\t\t\tyieldEvent=newYieldEvent; scheduled=false;\r\n\t\t\t\t\ttarget.addEventListener(\"DOMSubtreeModified\", yieldEventDelayed, false);\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t\t\r\n\t\t}\r\n\t} else {\r\n\t\tDOMUpdateEventStream = AnimationFrameEventStream;\r\n\t}\r\n\r\n\t///\r\n\t/// call a function every time the focus shifts\r\n\t///\r\n\tfunction FocusEventStream() {\r\n\t\tvar self=this;\r\n\t\t\r\n\t\t// handle the filtering nature of focus events\r\n\t\tvar yieldEvent=null; var previousActiveElement=null; var previousHasFocus=false; var rid=0;\r\n\t\tvar yieldEventDelayed = function() {\r\n\t\t\t\r\n\t\t\t// if the focus didn't change\r\n\t\t\tif(previousActiveElement==document.activeElement && previousHasFocus==document.hasFocus()) {\r\n\t\t\t\t\r\n\t\t\t\t// then do not generate an event\r\n\t\t\t\tsetTimeout(yieldEventDelayed, 333); // focus that didn't move is expected to stay\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// else, generate one & save config\r\n\t\t\t\tpreviousActiveElement=document.activeElement;\r\n\t\t\t\tpreviousHasFocus=document.hasFocus();\r\n\t\t\t\tyieldEvent();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// start the event stream\r\n\t\tEventStream.call(\r\n\t\t\tthis, \r\n\t\t\tfunction connect(newYieldEvent) {\r\n\t\t\t\tyieldEvent=newYieldEvent;\r\n\t\t\t\trid=setTimeout(yieldEventDelayed, 500); // let the document load\r\n\t\t\t},\r\n\t\t\tfunction disconnect() { \r\n\t\t\t\tclearTimeout(rid); yieldEventDelayed=null; yieldEvent=null; rid=0;\r\n\t\t\t},\r\n\t\t\tfunction reconnect(newYieldEvent) { \r\n\t\t\t\tyieldEvent=newYieldEvent;\r\n\t\t\t\trid=setTimeout(yieldEventDelayed, 100); // focus by tab navigation moves fast\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t}\r\n\r\n\t///\r\n\t/// composite event stream\r\n\t/// because sometimes you need more than one event source\r\n\t///\r\n\tfunction CompositeEventStream(stream1, stream2) {\r\n\t\tvar self=this;\r\n\t\t\r\n\t\t// fields\r\n\t\tvar yieldEvent=null; var s1=false, s2=false;\r\n\t\tvar yieldEventWrapper=function(s) { \r\n\t\t\tif(s==stream1) s1=true;\r\n\t\t\tif(s==stream2) s2=true;\r\n\t\t\tif(s1&&s2) return;\r\n\t\t\tyieldEvent(self);\r\n\t\t}\r\n\t\t\r\n\t\t// start the event stream\r\n\t\tEventStream.call(\r\n\t\t\tthis, \r\n\t\t\tfunction connect(newYieldEvent) {\r\n\t\t\t\tyieldEvent=newYieldEvent;\r\n\t\t\t\tstream1.schedule(yieldEventWrapper);\r\n\t\t\t\tstream2.schedule(yieldEventWrapper);\r\n\t\t\t},\r\n\t\t\tfunction disconnect() { \r\n\t\t\t\tstream1.dispose();\r\n\t\t\t\tstream2.dispose();\r\n\t\t\t},\r\n\t\t\tfunction reconnect(newYieldEvent) { \r\n\t\t\t\tyieldEvent=newYieldEvent;\r\n\t\t\t\ts1 && stream1.schedule(yieldEventWrapper);\r\n\t\t\t\ts2 && stream2.schedule(yieldEventWrapper);\r\n\t\t\t\ts1 = s2 = false;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\t\r\n\treturn {\r\n\t\tEventStream:                EventStream,\r\n\t\tAnimationFrameEventStream:  AnimationFrameEventStream,\r\n\t\tTimeoutEventStream:         TimeoutEventStream,\r\n\t\tMouseEventStream:           MouseEventStream,\r\n\t\tMouseButtonEventStream:     MouseButtonEventStream,\r\n\t\tDOMUpdateEventStream:       DOMUpdateEventStream,\r\n\t\tFocusEventStream:           FocusEventStream,\r\n\t\tCompositeEventStream:       CompositeEventStream\r\n\t};\r\n\r\n})(window, document);\nrequire.define('src/core/dom-experimental-event-streams.js');","/////////////////////////////////////////////////////////////////\r\n////                                                         ////\r\n////                  Implementation of qSL                  ////\r\n////                                                         ////\r\n/////////////////////////////////////////////////////////////////\r\n////                                                         ////\r\n////   Please note that I require querySelectorAll to work   ////\r\n////                                                         ////\r\n////   See http://github.com/termi/CSS_selector_engine/      ////\r\n////   for a polyfill for older browsers                     ////\r\n////                                                         ////\r\n/////////////////////////////////////////////////////////////////\r\n\r\nmodule.exports = (function(window, document) { \"use strict\";\r\n\r\n\t// import dependencies\r\n\tvar eventStreams = require('src/core/dom-experimental-event-streams.js'),\r\n\t    DOMUpdateEventStream = eventStreams.DOMUpdateEventStream,\r\n\t\tAnimationFrameEventStream = eventStreams.AnimationFrameEventStream,\r\n\t\tCompositeEventStream = eventStreams.CompositeEventStream,\r\n\t\tFocusEventStream = eventStreams.FocusEventStream,\r\n\t\tMouseButtonEventStream = eventStreams.MouseButtonEventStream,\r\n\t\tTimeoutEventStream = eventStreams.TimeoutEventStream,\r\n\t\tMouseEventStream = eventStreams.MouseEventStream;\r\n\r\n\t///\r\n\t/// the live querySelectorAll implementation\r\n\t///\r\n\tfunction querySelectorLive(selector, handler, root) {\r\n\t\t\r\n\t\t// restrict the selector coverage to some part of the DOM only\r\n\t\tvar root = root || document;\r\n\t\t\r\n\t\t// TODO: make use of \"mutatedAncestorElement\" to update only elements inside the mutated zone\r\n\t\t\r\n\t\tvar currentElms = [];\r\n\t\tvar loop = function loop(eventStream) {\r\n\t\t\t\r\n\t\t\t// schedule next run\r\n\t\t\teventStream.schedule(loop);\r\n\t\t\t\r\n\t\t\t// update elements matching the selector\r\n\t\t\tvar newElms = [];\r\n\t\t\tvar oldElms = currentElms.slice(0);\r\n\t\t\tvar temps = root.querySelectorAll(selector);\r\n\t\t\tfor(var i=newElms.length=temps.length; i;) { newElms.push(temps[--i]); }\r\n\t\t\tcurrentElms = newElms.slice(0); temps=null;\r\n\t\t\t\r\n\t\t\t// first let's clear all elements that have been removed from the document\r\n\t\t\toldElms = oldElms.filter(function(e) {\r\n\t\t\t\t\r\n\t\t\t\t// check whether the current element is still there\r\n\t\t\t\tvar isStillInDocument = (\r\n\t\t\t\t\te===document.documentElement \r\n\t\t\t\t\t|| document.documentElement.contains(e)\r\n\t\t\t\t);\r\n\t\t\t\t\r\n\t\t\t\tif(isStillInDocument) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// NEED_COMPARE: we will compare this element to the new list\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// DELETE: raise onremoved, pop old elements\r\n\t\t\t\t\ttry { handler.onremoved && handler.onremoved(e); } catch(ex) { setImmediate(function() {throw ex})}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\t// now pop and match until both lists are exhausted\r\n\t\t\t// (we use the fact the returned elements are in document order)\r\n\t\t\tvar el1 = oldElms.pop();\r\n\t\t\tvar el2 = newElms.pop();\r\n\t\t\twhile(el1 || el2) {\r\n\t\t\t\tif(el1===el2) {\r\n\t\t\t\t\r\n\t\t\t\t\t// MATCH: pop both elements\r\n\t\t\t\t\tel1 = oldElms.pop();\r\n\t\t\t\t\tel2 = newElms.pop();\r\n\t\t\t\t\t\r\n\t\t\t\t} else if (el2 && /*el1 is after el2*/(!el1||(el2.compareDocumentPosition(el1) & (1|2|8|32))===0)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// INSERT: raise onadded, pop new elements\r\n\t\t\t\t\ttry { handler.onadded && handler.onadded(el2); } catch(ex) { setImmediate(function() {throw ex})}\r\n\t\t\t\t\tel2 = newElms.pop();\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t\t// DELETE: raise onremoved, pop old elements\r\n\t\t\t\t\ttry { handler.onremoved && handler.onremoved(el1); } catch(ex) { setImmediate(function() {throw ex})}\r\n\t\t\t\t\tel1 = oldElms.pop();\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t};\r\n\t\t\r\n\t\t// use the event stream that best matches our needs\r\n\t\tvar simpleSelector = selector.replace(/:(dir|lang|root|empty|blank|nth-child|nth-last-child|first-child|last-child|only-child|nth-of-type|nth-last-of-child|fist-of-type|last-of-type|only-of-type|not|matches|default)\\b/gi,'')\r\n\t\tvar eventStream; if(simpleSelector.indexOf(':') == -1) {\r\n\t\t\t\r\n\t\t\t// static stuff only\r\n\t\t\teventStream = new DOMUpdateEventStream(root); \r\n\t\t\t\r\n\t\t} else {\r\n\t\t\t\r\n\t\t\t// dynamic stuff too\r\n\t\t\teventStream = new DOMUpdateEventStream(root); \r\n\t\t\tif(DOMUpdateEventStream != AnimationFrameEventStream) {\r\n\t\t\t\r\n\t\t\t\t// detect the presence of focus-related pseudo-classes\r\n\t\t\t\tvar reg = /:(focus|active)\\b/gi;\r\n\t\t\t\tif(reg.test(simpleSelector)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// mouse events should be listened\r\n\t\t\t\t\teventStream = new CompositeEventStream(\r\n\t\t\t\t\t\tnew FocusEventStream(),\r\n\t\t\t\t\t\teventStream\r\n\t\t\t\t\t);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// simplify simpleSelector\r\n\t\t\t\t\tvar reg = /:(focus)\\b/gi;\r\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, ''); // :active has other hooks\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// detect the presence of mouse-button-related pseudo-classes\r\n\t\t\t\tvar reg = /:(active)\\b/gi;\r\n\t\t\t\tif(reg.test(simpleSelector)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// mouse events should be listened\r\n\t\t\t\t\teventStream = new CompositeEventStream(\r\n\t\t\t\t\t\tnew MouseButtonEventStream(),\r\n\t\t\t\t\t\teventStream\r\n\t\t\t\t\t);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// simplify simpleSelector\r\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// detect the presence of user input pseudo-classes\r\n\t\t\t\tvar reg = /:(target|checked|indeterminate|valid|invalid|in-range|out-of-range|user-error)\\b/gi;\r\n\t\t\t\tif(reg.test(simpleSelector)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// slowly dynamic stuff do happen\r\n\t\t\t\t\teventStream = new CompositeEventStream(\r\n\t\t\t\t\t\tnew TimeoutEventStream(250),\r\n\t\t\t\t\t\teventStream\r\n\t\t\t\t\t);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// simplify simpleSelector\r\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\r\n\r\n\t\t\t\t\tvar reg = /:(any-link|link|visited|local-link|enabled|disabled|read-only|read-write|required|optional)\\b/gi;\r\n\t\t\t\t\t// simplify simpleSelector\r\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// detect the presence of nearly-static pseudo-classes\r\n\t\t\t\tvar reg = /:(any-link|link|visited|local-link|enabled|disabled|read-only|read-write|required|optional)\\b/gi;\r\n\t\t\t\tif(reg.test(simpleSelector)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// nearly static stuff do happen\r\n\t\t\t\t\teventStream = new CompositeEventStream(\r\n\t\t\t\t\t\tnew TimeoutEventStream(333),\r\n\t\t\t\t\t\teventStream\r\n\t\t\t\t\t);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// simplify simpleSelector\r\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// detect the presence of mouse-related pseudo-classes\r\n\t\t\t\tvar reg = /:(hover)\\b/gi;\r\n\t\t\t\tif(reg.test(simpleSelector)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// mouse events should be listened\r\n\t\t\t\t\teventStream = new CompositeEventStream(\r\n\t\t\t\t\t\tnew MouseEventStream(),\r\n\t\t\t\t\t\teventStream\r\n\t\t\t\t\t);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// simplify simpleSelector\r\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// detect the presence of unknown pseudo-classes\r\n\t\t\t\tif(simpleSelector.indexOf(':') !== -1) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// other stuff do happen, too (let's give up on events)\r\n\t\t\t\t\teventStream = new AnimationFrameEventStream(); \r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t// start handling changes\r\n\t\tloop(eventStream);\r\n\t\t\r\n\t}\r\n\t\r\n\treturn querySelectorLive;\r\n\t\r\n})(window, document);\nrequire.define('src/core/dom-query-selector-live.js');","// TODO: comment about the 'no_auto_stylesheet_detection' flag?\r\n\r\nmodule.exports = (function(window, document) { \"use strict\";\r\n\t\r\n\t// import dependencies\r\n\trequire('src/core/polyfill-dom-console.js');\r\n\trequire('src/core/polyfill-dom-requestAnimationFrame.js');\r\n\tvar cssSyntax = require('src/core/css-syntax.js');\r\n\tvar domEvents = require('src/core/dom-events.js');\r\n\tvar querySelectorLive = require('src/core/dom-query-selector-live.js');\r\n\t\r\n\t// define the module\r\n\tvar cssCascade = {\r\n\t\t\r\n\t\t//\r\n\t\t// returns the priority of a unique selector (NO COMMA!)\r\n\t\t// { the return value is an integer, with the same formula as webkit }\r\n\t\t//\r\n\t\tcomputeSelectorPriorityOf: function computeSelectorPriorityOf(selector) {\r\n\t\t\tif(typeof selector == \"string\") selector = cssSyntax.parse(selector.trim()+\"{}\").value[0].selector;\r\n\t\t\t\r\n\t\t\tvar numberOfIDs = 0;\r\n\t\t\tvar numberOfClasses = 0;\r\n\t\t\tvar numberOfTags = 0;\r\n\t\t\t\r\n\t\t\t// TODO: improve this parser, or find one on the web\r\n\t\t\tfor(var i = 0; i < selector.length; i++) {\r\n\t\t\t\t\r\n\t\t\t\tif(selector[i] instanceof cssSyntax.IdentifierToken) {\r\n\t\t\t\t\tnumberOfTags++;\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(selector[i] instanceof cssSyntax.DelimToken) {\r\n\t\t\t\t\tif(selector[i].value==\".\") {\r\n\t\t\t\t\t\tnumberOfClasses++; i++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(selector[i] instanceof cssSyntax.ColonToken) {\r\n\t\t\t\t\tif(selector[++i] instanceof cssSyntax.ColonToken) {\r\n\t\t\t\t\t\tnumberOfTags++; i++;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else if((selector[i] instanceof cssSyntax.Func) && (/^(not|matches)$/i).test(selector[i].name)) {\r\n\t\t\t\t\t\tvar nestedPriority = this.computeSelectorPriorityOf(selector[i].value);\r\n\t\t\t\t\t\tnumberOfTags += nestedPriority % 256; nestedPriority /= 256;\r\n\t\t\t\t\t\tnumberOfClasses += nestedPriority % 256; nestedPriority /= 256;\r\n\t\t\t\t\t\tnumberOfIDs += nestedPriority;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tnumberOfClasses++;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(selector[i] instanceof cssSyntax.SimpleBlock) {\r\n\t\t\t\t\tif(selector[i].name==\"[\") {\r\n\t\t\t\t\t\tnumberOfClasses++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(selector[i] instanceof cssSyntax.HashToken) {\r\n\t\t\t\t\tnumberOfIDs++;\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// TODO: stop ignoring unknown symbols?\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(numberOfIDs>255) numberOfIds=255;\r\n\t\t\tif(numberOfClasses>255) numberOfClasses=255;\r\n\t\t\tif(numberOfTags>255) numberOfTags=255;\r\n\t\t\t\r\n\t\t\treturn ((numberOfIDs*256)+numberOfClasses)*256+numberOfTags;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// returns an array of the css rules matching an element\r\n\t\t//\r\n\t\tfindAllMatchingRules: function findAllMatchingRules(element) {\r\n\t\t\treturn this.findAllMatchingRulesWithPseudo(element);\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// returns an array of the css rules matching a pseudo-element\r\n\t\t//\r\n\t\tfindAllMatchingRulesWithPseudo: function findAllMatchingRules(element,pseudo) {\r\n\t\t\tpseudo = pseudo ? (''+pseudo).toLowerCase() : pseudo;\r\n\t\t\t\r\n\t\t\t// let's look for new results if needed...\r\n\t\t\tvar results = [];\r\n\t\t\t\r\n\t\t\t// walk the whole stylesheet...\r\n\t\t\tvar visit = function(rules) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tfor(var r = rules.length; r--; ) {\r\n\t\t\t\t\t\tvar rule = rules[r]; \r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// media queries hook\r\n\t\t\t\t\t\tif(rule.disabled) continue;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif(rule instanceof cssSyntax.StyleRule) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// consider each selector independently\r\n\t\t\t\t\t\t\tvar subrules = rule.subRules || cssCascade.splitRule(rule);\r\n\t\t\t\t\t\t\tfor(var sr = subrules.length; sr--; ) {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tvar selector = subrules[sr].selector.toCSSString().replace(/ *(\\/\\*\\*\\/|  ) */g,' ').trim();\r\n\t\t\t\t\t\t\t\tif(pseudo) {\r\n\t\t\t\t\t\t\t\t\t// WE ONLY ACCEPT SELECTORS ENDING WITH THE PSEUDO\r\n\t\t\t\t\t\t\t\t\tvar selectorLow = selector.toLowerCase();\r\n\t\t\t\t\t\t\t\t\tvar newLength = selector.length-pseudo.length-1;\r\n\t\t\t\t\t\t\t\t\tif(newLength<=0) continue;\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tif(selectorLow.lastIndexOf('::'+pseudo)==newLength-1) {\r\n\t\t\t\t\t\t\t\t\t\tselector = selector.substr(0,newLength-1);\r\n\t\t\t\t\t\t\t\t\t} else if(selectorLow.lastIndexOf(':'+pseudo)==newLength) {\r\n\t\t\t\t\t\t\t\t\t\tselector = selector.substr(0,newLength);\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// fix selectors like \"#element > :first-child ~ ::before\"\r\n\t\t\t\t\t\t\t\t\tif(selector.trim().length == 0) { selector = '*' }\r\n\t\t\t\t\t\t\t\t\telse if(selector[selector.length-1] == ' ') { selector += '*' }\r\n\t\t\t\t\t\t\t\t\telse if(selector[selector.length-1] == '+') { selector += '*' }\r\n\t\t\t\t\t\t\t\t\telse if(selector[selector.length-1] == '>') { selector += '*' }\r\n\t\t\t\t\t\t\t\t\telse if(selector[selector.length-1] == '~') { selector += '*' }\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// look if the selector matches\r\n\t\t\t\t\t\t\t\tvar isMatching = false;\r\n\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\tif(element.matches) isMatching=element.matches(selector)\r\n\t\t\t\t\t\t\t\t\telse if(element.matchesSelector) isMatching=element.matchesSelector(selector)\r\n\t\t\t\t\t\t\t\t\telse if(element.oMatchesSelector) isMatching=element.oMatchesSelector(selector)\r\n\t\t\t\t\t\t\t\t\telse if(element.msMatchesSelector) isMatching=element.msMatchesSelector(selector)\r\n\t\t\t\t\t\t\t\t\telse if(element.mozMatchesSelector) isMatching=element.mozMatchesSelector(selector)\r\n\t\t\t\t\t\t\t\t\telse if(element.webkitMatchesSelector) isMatching=element.webkitMatchesSelector(selector)\r\n\t\t\t\t\t\t\t\t\telse { throw new Error(\"no element.matches?\") }\r\n\t\t\t\t\t\t\t\t} catch(ex) { debugger; setImmediate(function() { throw ex; }) }\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// if yes, add it to the list of matched selectors\r\n\t\t\t\t\t\t\t\tif(isMatching) { results.push(subrules[sr]); }\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t} else if(rule instanceof cssSyntax.AtRule && rule.name==\"media\") {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// visit the nested rules\r\n\t\t\t\t\t\t\tvisit(rules[i].getStylesheet().value);\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (ex) {\r\n\t\t\t\t\tsetImmediate(function() { throw ex; });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor(var s=cssCascade.stylesheets.length; s--; ) {\r\n\t\t\t\tvar rules = cssCascade.stylesheets[s];\r\n\t\t\t\tvisit(rules);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn results;\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// a list of all properties supported by the current browser\r\n\t\t//\r\n\t\tallCSSProperties: null,\r\n\t\tgetAllCSSProperties: function getAllCSSProperties() {\r\n\t\t\t\r\n\t\t\tif(this.allCSSProperties) return this.allCSSProperties;\r\n\t\t\t\r\n\t\t\t// get all claimed properties\r\n\t\t\tvar s = getComputedStyle(document.documentElement); var ps = new Array(s.length);\r\n\t\t\tfor(var i=s.length; i--; ) {\r\n\t\t\t\tps[i] = s[i];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// FIX A BUG WHERE WEBKIT DOESN'T REPORT ALL PROPERTIES\r\n\t\t\tif(ps.indexOf('content')==-1) {ps.push('content');}\r\n\t\t\tif(ps.indexOf('counter-reset')==-1) {\r\n\t\t\t\t\r\n\t\t\t\tps.push('counter-reset');\r\n\t\t\t\tps.push('counter-increment');\r\n\t\t\t\t\r\n\t\t\t\t// FIX A BUG WHERE WEBKIT RETURNS SHIT FOR THE COMPUTED VALUE OF COUNTER-RESET\r\n\t\t\t\tcssCascade.computationUnsafeProperties['counter-reset']=true;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// save in a cache for faster access the next times\r\n\t\t\treturn this.allCSSProperties = ps;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t// \r\n\t\t// those properties are not safe for computation->specified round-tripping\r\n\t\t// \r\n\t\tcomputationUnsafeProperties: {\r\n\t\t\t\"bottom\"          : true,\r\n\t\t\t\"direction\"       : true,\r\n\t\t\t\"display\"         : true,\r\n\t\t\t\"font-size\"       : true,\r\n\t\t\t\"height\"          : true,\r\n\t\t\t\"left\"            : true,\r\n\t\t\t\"line-height\"     : true,\r\n\t\t\t\"margin-left\"     : true,\r\n\t\t\t\"margin-right\"    : true,\r\n\t\t\t\"margin-bottom\"   : true,\r\n\t\t\t\"margin-top\"      : true,\r\n\t\t\t\"max-height\"      : true,\r\n\t\t\t\"max-width\"       : true,\r\n\t\t\t\"min-height\"      : true,\r\n\t\t\t\"min-width\"       : true,\r\n\t\t\t\"padding-left\"    : true,\r\n\t\t\t\"padding-right\"   : true,\r\n\t\t\t\"padding-bottom\"  : true,\r\n\t\t\t\"padding-top\"     : true,\r\n\t\t\t\"right\"           : true,\r\n\t\t\t\"text-align\"      : true,\r\n\t\t\t\"text-align-last\" : true,\r\n\t\t\t\"top\"             : true,\r\n\t\t\t\"width\"           : true,\r\n\t\t\t__proto__         : null,\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// a list of property we should inherit...\r\n\t\t//\r\n\t\tinheritingProperties: {\r\n\t\t\t\"border-collapse\"       : true,\r\n\t\t\t\"border-spacing\"        : true,\r\n\t\t\t\"caption-side\"          : true,\r\n\t\t\t\"color\"                 : true,\r\n\t\t\t\"cursor\"                : true,\r\n\t\t\t\"direction\"             : true,\r\n\t\t\t\"empty-cells\"           : true,\r\n\t\t\t\"font-family\"           : true,\r\n\t\t\t\"font-size\"             : true,\r\n\t\t\t\"font-style\"            : true,\r\n\t\t\t\"font-variant\"          : true,\r\n\t\t\t\"font-weight\"           : true,\r\n\t\t\t\"font\"                  : true,\r\n\t\t\t\"letter-spacing\"        : true,\r\n\t\t\t\"line-height\"           : true,\r\n\t\t\t\"list-style-image\"      : true,\r\n\t\t\t\"list-style-position\"   : true,\r\n\t\t\t\"list-style-type\"       : true,\r\n\t\t\t\"list-style\"            : true,\r\n\t\t\t\"orphans\"               : true,\r\n\t\t\t\"quotes\"                : true,\r\n\t\t\t\"text-align\"            : true,\r\n\t\t\t\"text-indent\"           : true,\r\n\t\t\t\"text-transform\"        : true,\r\n\t\t\t\"visibility\"            : true,\r\n\t\t\t\"white-space\"           : true,\r\n\t\t\t\"widows\"                : true,\r\n\t\t\t\"word-break\"            : true,\r\n\t\t\t\"word-spacing\"          : true,\r\n\t\t\t\"word-wrap\"             : true,\r\n\t\t\t__proto__               : null,\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// returns the default style for a tag\r\n\t\t//\r\n\t\tdefaultStylesForTag: Object.create ? Object.create(null) : {},\r\n\t\tgetDefaultStyleForTag: function getDefaultStyleForTag(tagName) {\r\n\t\t\t\r\n\t\t\t// get result from cache\r\n\t\t\tvar result = cssRegionsHelpers[tagName];\r\n\t\t\tif(result) return result;\r\n\t\t\t\r\n\t\t\t// create dummy virtual element\r\n\t\t\tvar element = document.createElement(tagName);\r\n\t\t\tvar style = cssRegionsHelpers[tagName] = getComputedStyle(element);\r\n\t\t\tif(style.display) return style;\r\n\t\t\t\r\n\t\t\t// webkit fix: insert the dummy element anywhere (head -> display:none)\r\n\t\t\tdocument.head.insertBefore(element, document.head.firstChild);\r\n\t\t\treturn style;\r\n\t\t},\r\n\t\t\r\n\t\t// \r\n\t\t// returns the specified style of an element. \r\n\t\t// REMARK: may or may not unwrap \"inherit\" and \"initial\" depending on implementation\r\n\t\t// REMARK: giving \"matchedRules\" as a parameter allow you to mutualize the \"findAllMatching\" rules calls\r\n\t\t// REMARK: giving \"stringOnly\" as a \"true\" parameter allows to return a fake token list which returns the good string value\r\n\t\t// \r\n\t\tgetSpecifiedStyle: function getSpecifiedStyle(element, cssPropertyName, matchedRules, stringOnly) {\r\n\t\t\t\r\n\t\t\t// hook for css regions\r\n\t\t\tvar fragmentSource;\r\n\t\t\tif(fragmentSource=element.getAttribute('data-css-regions-fragment-of')) {\r\n\t\t\t\tfragmentSource = document.querySelector('[data-css-regions-fragment-source=\"'+fragmentSource+'\"]');\r\n\t\t\t\tif(fragmentSource) return cssCascade.getSpecifiedStyle(fragmentSource, cssPropertyName);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// give IE a thumbs up for this!\r\n\t\t\tif(element.currentStyle && !window.opera) {\r\n\t\t\t\t\r\n\t\t\t\t// ask IE to manage the style himself...\r\n\t\t\t\tvar bestValue = element.myStyle[cssPropertyName] || element.currentStyle[cssPropertyName];\r\n\t\t\t\t\r\n\t\t\t\t// return a parsed representation of the value\r\n\t\t\t\treturn cssSyntax.parseCSSValue(bestValue, stringOnly);\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// TODO: support the \"initial\" and \"inherit\" things?\r\n\t\t\t\t\r\n\t\t\t\t// first, let's try inline style as it's fast and generally accurate\r\n\t\t\t\t// TODO: what if important rules override that?\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif(bestValue = element.style.getPropertyValue(cssPropertyName) || element.myStyle[cssPropertyName]) {\r\n\t\t\t\t\t\treturn cssSyntax.parseCSSValue(bestValue, stringOnly);\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch(ex) {}\r\n\t\t\t\t\r\n\t\t\t\t// find all relevant style rules\r\n\t\t\t\tvar isBestImportant=false; var bestPriority = 0; var bestValue = new cssSyntax.TokenList();\r\n\t\t\t\tvar rules = matchedRules || (\r\n\t\t\t\t\tcssPropertyName in cssCascade.monitoredProperties\r\n\t\t\t\t\t? element.myMatchedRules || []\r\n\t\t\t\t\t: cssCascade.findAllMatchingRules(element)\r\n\t\t\t\t);\r\n\t\t\t\t\r\n\t\t\t\tvar visit = function(rules) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tfor(var i=rules.length; i--; ) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// media queries hook\r\n\t\t\t\t\t\tif(rules[i].disabled) continue;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find a relevant declaration\r\n\t\t\t\t\t\tif(rules[i] instanceof cssSyntax.StyleRule) {\r\n\t\t\t\t\t\t\tvar decls = rules[i].getDeclarations();\r\n\t\t\t\t\t\t\tfor(var j=decls.length-1; j>=0; j--) {\r\n\t\t\t\t\t\t\t\tif(decls[j].type==\"DECLARATION\") {\r\n\t\t\t\t\t\t\t\t\tif(decls[j].name==cssPropertyName) {\r\n\t\t\t\t\t\t\t\t\t\t// only works if selectors containing a \",\" are deduplicated\r\n\t\t\t\t\t\t\t\t\t\tvar currentPriority = cssCascade.computeSelectorPriorityOf(rules[i].selector);\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\tif(isBestImportant) {\r\n\t\t\t\t\t\t\t\t\t\t\t// only an important declaration can beat another important declaration\r\n\t\t\t\t\t\t\t\t\t\t\tif(decls[j].important) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tif(currentPriority >= bestPriority) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tbestPriority = currentPriority;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tbestValue = decls[j].value;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t// an important declaration beats any non-important declaration\r\n\t\t\t\t\t\t\t\t\t\t\tif(decls[j].important) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tisBestImportant = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\tbestPriority = currentPriority;\r\n\t\t\t\t\t\t\t\t\t\t\t\tbestValue = decls[j].value;\r\n\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\t// the selector priority has to be higher otherwise\r\n\t\t\t\t\t\t\t\t\t\t\t\tif(currentPriority >= bestPriority) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tbestPriority = currentPriority;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tbestValue = decls[j].value;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if((rules[i] instanceof cssSyntax.AtRule) && (rules[i].name==\"media\")) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// visit the nested rules\r\n\t\t\t\t\t\t\tvisit(rules[i].getStylesheet().value);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tvisit(rules);\r\n\t\t\t\t\r\n\t\t\t\t// return our best guess...\r\n\t\t\t\treturn bestValue;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t\r\n\t\t//\r\n\t\t// start monitoring a new stylesheet\r\n\t\t// (should usually not be used because stylesheets load automatically)\r\n\t\t//\r\n\t\tstylesheets: [],\r\n\t\tloadStyleSheet: function loadStyleSheet(cssText,i) {\r\n\t\t\t\r\n\t\t\t// load in order\r\n\t\t\t\r\n\t\t\t// parse the stylesheet content\r\n\t\t\tvar rules = cssSyntax.parse(cssText).value;\r\n\t\t\t\r\n\t\t\t// add the stylesheet into the object model\r\n\t\t\tif(typeof(i)!==\"undefined\") { cssCascade.stylesheets[i]=rules; } \r\n\t\t\telse { i=cssCascade.stylesheets.push(rules);}\r\n\t\t\t\r\n\t\t\t// make sure to monitor the required rules\r\n\t\t\tcssCascade.startMonitoringStylesheet(rules)\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// start monitoring a new stylesheet\r\n\t\t// (should usually not be used because stylesheets load automatically)\r\n\t\t//\r\n\t\tloadStyleSheetTag: function loadStyleSheetTag(stylesheet,i) {\r\n\t\t\t\r\n\t\t\tif(stylesheet.hasAttribute('data-css-polyfilled')) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(stylesheet.tagName=='LINK') {\r\n\t\t\t\t\r\n\t\t\t\t// oh, no, we have to download it...\r\n\t\t\t\ttry {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// dummy value in-between\r\n\t\t\t\t\tcssCascade.stylesheets[i] = new cssSyntax.TokenList();\r\n\t\t\t\t\t\r\n\t\t\t\t\t//\r\n\t\t\t\t\tvar xhr = new XMLHttpRequest(); xhr.href = stylesheet.href;\r\n\t\t\t\t\txhr.open('GET',stylesheet.href,true); xhr.ruleIndex = i; \r\n\t\t\t\t\txhr.onreadystatechange = function() {\r\n\t\t\t\t\t\tif(this.readyState==4) { \r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// status 0 is a webkit bug for local files\r\n\t\t\t\t\t\t\tif(this.status==200||this.status==0) {\r\n\t\t\t\t\t\t\t\tcssCascade.loadStyleSheet(this.responseText,this.ruleIndex)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcssConsole.log(\"css-cascade polyfill failled to load: \" + this.href);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t\txhr.send();\r\n\t\t\t\t\t\r\n\t\t\t\t} catch(ex) {\r\n\t\t\t\t\tcssConsole.log(\"css-cascade polyfill failled to load: \" + stylesheet.href);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// oh, cool, we just have to parse the content!\r\n\t\t\t\tcssCascade.loadStyleSheet(stylesheet.textContent,i);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// mark the stylesheet as ok\r\n\t\t\tstylesheet.setAttribute('data-css-polyfilled',true);\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// calling this function will load all currently existing stylesheets in the document\r\n\t\t// (should usually not be used because stylesheets load automatically)\r\n\t\t//\r\n\t\tselectorForStylesheets: \"style:not([data-no-css-polyfill]):not([data-css-polyfilled]), link[rel=stylesheet]:not([data-no-css-polyfill]):not([data-css-polyfilled])\",\r\n\t\tloadAllStyleSheets: function loadAllStyleSheets() {\r\n\t\t\t\r\n\t\t\t// for all stylesheets in the <head> tag...\r\n\t\t\tvar head = document.head || document.documentElement;\r\n\t\t\tvar stylesheets = head.querySelectorAll(cssCascade.selectorForStylesheets);\r\n\t\t\t\r\n\t\t\tvar intialLength = this.stylesheets.length;\r\n\t\t\tthis.stylesheets.length += stylesheets.length\r\n\t\t\t\r\n\t\t\t// for all of them...\r\n\t\t\tfor(var i = stylesheets.length; i--;) {\r\n\t\t\t\t\r\n\t\t\t\t// \r\n\t\t\t\t// load the stylesheet\r\n\t\t\t\t// \r\n\t\t\t\tvar stylesheet = stylesheets[i]; \r\n\t\t\t\tcssCascade.loadStyleSheetTag(stylesheet,intialLength+i)\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// this is where we store event handlers for monitored properties\r\n\t\t//\r\n\t\tmonitoredProperties: Object.create ? Object.create(null) : {},\r\n\t\tmonitoredPropertiesHandler: {\r\n\t\t\tonupdate: function(element, rule) {\r\n\t\t\t\t\r\n\t\t\t\t// we need to find all regexps that matches\r\n\t\t\t\tvar mps = cssCascade.monitoredProperties;\r\n\t\t\t\tvar decls = rule.getDeclarations();\r\n\t\t\t\tfor(var j=decls.length-1; j>=0; j--) {\r\n\t\t\t\t\tif(decls[j].type==\"DECLARATION\") {\r\n\t\t\t\t\t\tif(decls[j].name in mps) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// call all handlers waiting for this\r\n\t\t\t\t\t\t\tvar hs = mps[decls[j].name];\r\n\t\t\t\t\t\t\tfor(var hi=hs.length; hi--;) {\r\n\t\t\t\t\t\t\t\ths[hi].onupdate(element,rule);\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// don't call twice\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// add an handler to some properties (aka fire when their value *MAY* be affected)\r\n\t\t// REMARK: because this event does not promise the value changed, you may want to figure it out before relayouting\r\n\t\t//\r\n\t\tstartMonitoringProperties: function startMonitoringProperties(properties, handler) {\r\n\t\t\t\r\n\t\t\tfor(var i=properties.length; i--; ) {\r\n\t\t\t\tvar property = properties[i];\r\n\t\t\t\tvar handlers = (\r\n\t\t\t\t\tcssCascade.monitoredProperties[property]\r\n\t\t\t\t\t|| (cssCascade.monitoredProperties[property] = [])\r\n\t\t\t\t);\r\n\t\t\t\thandlers.push(handler)\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor(var s=0; s<cssCascade.stylesheets.length; s++) {\r\n\t\t\t\tvar currentStylesheet = cssCascade.stylesheets[s];\r\n\t\t\t\tcssCascade.startMonitoringStylesheet(currentStylesheet);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// calling this function will detect monitored rules in the stylesheet\r\n\t\t// (should usually not be used because stylesheets load automatically)\r\n\t\t//\r\n\t\tstartMonitoringStylesheet: function startMonitoringStylesheet(rules) {\r\n\t\t\tfor(var i=0; i<rules.length; i++) {\r\n\t\t\t\t\r\n\t\t\t\t// only consider style rules\r\n\t\t\t\tif(rules[i] instanceof cssSyntax.StyleRule) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// try to see if the current rule is worth monitoring\r\n\t\t\t\t\tif(rules[i].isMonitored) continue;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// for that, let's see if we can find a declaration we should watch\r\n\t\t\t\t\tvar decls = rules[i].getDeclarations();\r\n\t\t\t\t\tfor(var j=decls.length-1; j>=0; j--) {\r\n\t\t\t\t\t\tif(decls[j].type==\"DECLARATION\") {\r\n\t\t\t\t\t\t\tif(decls[j].name in cssCascade.monitoredProperties) {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// if we found some, start monitoring\r\n\t\t\t\t\t\t\t\tcssCascade.startMonitoringRule(rules[i]);\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(rules[i] instanceof cssSyntax.AtRule) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// handle @media\r\n\t\t\t\t\tif(rules[i].name == \"media\" && window.matchMedia) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcssCascade.startMonitoringMedia(rules[i]);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// calling this function will detect media query updates and fire events accordingly\r\n\t\t// (should usually not be used because stylesheets load automatically)\r\n\t\t//\r\n\t\tstartMonitoringMedia: function startMonitoringMedia(atrule) {\r\n\t\t\ttry {\r\n\t\t\t\t\r\n\t\t\t\tvar media = window.matchMedia(atrule.prelude.toCSSString());\r\n\t\t\t\t\r\n\t\t\t\t// update all the rules when needed\r\n\t\t\t\tvar rules = atrule.getStylesheet().value;\r\n\t\t\t\tcssCascade.updateMedia(rules, !media.matches, false);\r\n\t\t\t\tmedia.addListener(\r\n\t\t\t\t\tfunction(newMedia) { cssCascade.updateMedia(rules, !newMedia.matches, true); }\r\n\t\t\t\t);\r\n\t\t\t\t\r\n\t\t\t\t// it seems I like taking risks...\r\n\t\t\t\tcssCascade.startMonitoringStylesheet(rules);\r\n\t\t\t\t\r\n\t\t\t} catch(ex) {\r\n\t\t\t\tsetImmediate(function() { throw ex; })\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// define what happens when a media query status changes\r\n\t\t//\r\n\t\tupdateMedia: function(rules,disabled,update) {\r\n\t\t\tfor(var i=rules.length; i--; ) {\r\n\t\t\t\trules[i].disabled = disabled;\r\n\t\t\t\t// TODO: should probably get handled by a setter on the rule...\r\n\t\t\t\tvar sr = rules[i].subRules;\r\n\t\t\t\tif(sr) {\r\n\t\t\t\t\tfor(var j=sr.length; j--; ) {\r\n\t\t\t\t\t\tsr[j].disabled = disabled;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// in case of update, all elements matching the selector went potentially updated...\r\n\t\t\tif(update) {\r\n\t\t\t\tfor(var i=rules.length; i--; ) {\r\n\t\t\t\t\tvar els = document.querySelectorAll(rules[i].selector.toCSSString());\r\n\t\t\t\t\tfor(var j=els.length; j--; ) {\r\n\t\t\t\t\t\tcssCascade.monitoredPropertiesHandler.onupdate(els[j],rules[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t// \r\n\t\t// splits a rule if it has multiple selectors\r\n\t\t// \r\n\t\tsplitRule: function splitRule(rule) {\r\n\t\t\t\r\n\t\t\t// create an array for all the subrules\r\n\t\t\tvar rules = [];\r\n\t\t\t\r\n\t\t\t// fill the array\r\n\t\t\tvar currentRule = new cssSyntax.StyleRule(); currentRule.disabled=rule.disabled;\r\n\t\t\tfor(var i=0; i<rule.selector.length; i++) {\r\n\t\t\t\tif(rule.selector[i] instanceof cssSyntax.DelimToken && rule.selector[i].value==\",\") {\r\n\t\t\t\t\tcurrentRule.value = rule.value; rules.push(currentRule);\r\n\t\t\t\t\tcurrentRule = new cssSyntax.StyleRule(); currentRule.disabled=rule.disabled;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurrentRule.selector.push(rule.selector[i])\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcurrentRule.value = rule.value; rules.push(currentRule);\r\n\t\t\t\r\n\t\t\t// save the result of the split as subrules\r\n\t\t\treturn rule.subRules = rules;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t// \r\n\t\t// ask the css-selector implementation to notify changes for the rules\r\n\t\t// \r\n\t\tstartMonitoringRule: function startMonitoringRule(rule) {\r\n\t\t\t\r\n\t\t\t// avoid monitoring rules twice\r\n\t\t\tif(!rule.isMonitored) { rule.isMonitored=true } else { return; }\r\n\t\t\t\r\n\t\t\t// split the rule if it has multiple selectors\r\n\t\t\tvar rules = rule.subRules || cssCascade.splitRule(rule);\r\n\t\t\t\r\n\t\t\t// monitor the rules\r\n\t\t\tfor(var i=0; i<rules.length; i++) {\r\n\t\t\t\trule = rules[i];\r\n\t\t\t\tquerySelectorLive(rule.selector.toCSSString(), {\r\n\t\t\t\t\tonadded: function(e) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// add the rule to the matching list of this element\r\n\t\t\t\t\t\t(e.myMatchedRules = e.myMatchedRules || []).push(rule); // TODO: does not respect priority order\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// generate an update event\r\n\t\t\t\t\t\tcssCascade.monitoredPropertiesHandler.onupdate(e, rule);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t},\r\n\t\t\t\t\tonremoved: function(e) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// remove the rule from the matching list of this element\r\n\t\t\t\t\t\tif(e.myMatchedRules) e.myMatchedRules.splice(e.myMatchedRules.indexOf(rule), 1);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// generate an update event\r\n\t\t\t\t\t\tcssCascade.monitoredPropertiesHandler.onupdate(e, rule);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// converts a css property name to a javascript name\r\n\t\t//\r\n\t\ttoCamelCase: function toCamelCase(variable) { \r\n\t\t\treturn variable.replace(\r\n\t\t\t\t/-([a-z])/g, \r\n\t\t\t\tfunction(str,letter) { \r\n\t\t\t\t\treturn letter.toUpperCase();\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// add some magic code to support properties on the style interface\r\n\t\t//\r\n\t\tpolyfillStyleInterface: function(cssPropertyName) {\r\n\t\t\t\r\n\t\t\tvar prop = {\r\n\t\t\t\t\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// check we know which element we work on\r\n\t\t\t\t\ttry { if(!this.parentElement) throw new Error(\"Please use the anHTMLElement.myStyle property to get polyfilled properties\") }\r\n\t\t\t\t\tcatch(ex) { setImmediate(function() { throw ex; }); return ''; }\r\n\t\t\t\t\t\r\n\t\t\t\t\ttry { \r\n\t\t\t\t\t\t// non-computed style: return the local style of the element\r\n\t\t\t\t\t\tthis.clip = (this.clip===undefined?'':this.clip);\r\n\t\t\t\t\t\treturn this.parentElement.getAttribute('data-style-'+cssPropertyName);\r\n\t\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t\t// computed style: return the specified style of the element\r\n\t\t\t\t\t\tvar value = cssCascade.getSpecifiedStyle(this.parentElement, cssPropertyName, undefined, true);\r\n\t\t\t\t\t\treturn value && value.length>0 ? value.toCSSString() : '';\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t},\r\n\t\t\t\t\r\n\t\t\t\tset: function(v) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// check that the style is writable\r\n\t\t\t\t\tthis.clip = (this.clip===undefined?'':this.clip);\r\n\r\n\t\t\t\t\t// check we know which element we work on\r\n\t\t\t\t\ttry { if(!this.parentElement) throw new Error(\"Please use the anHTMLElement.myStyle property to set polyfilled properties\") }\r\n\t\t\t\t\tcatch(ex) { setImmediate(function() { throw ex; }); return; }\r\n\t\t\t\t\t\r\n\t\t\t\t\t// modify the local style of the element\r\n\t\t\t\t\tif(this.parentElement.getAttribute('data-style-'+cssPropertyName) != v) {\r\n\t\t\t\t\t\tthis.parentElement.setAttribute('data-style-'+cssPropertyName,v);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tvar styleProtos = [];\r\n\t\t\ttry { styleProtos.push(Object.getPrototypeOf(document.documentElement.style) || CSSStyleDeclaration); } catch (ex) {}\r\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(getComputedStyle(document.documentElement))); } catch (ex) {}\r\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.currentStyle)); } catch (ex) {}\r\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.runtimeStyle)); } catch (ex) {}\r\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.specifiedStyle)); } catch (ex) {}\r\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.cascadedStyle)); } catch (ex) {}\r\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.usedStyle)); } catch (ex) {}\r\n\t\t\t\r\n\t\t\tfor(var i = styleProtos.length; i--;) {\r\n\t\t\t\tvar styleProto = styleProtos[i];\r\n\t\t\t\tObject.defineProperty(styleProto,cssPropertyName,prop);\r\n\t\t\t\tObject.defineProperty(styleProto,cssCascade.toCamelCase(cssPropertyName),prop);\r\n\t\t\t}\r\n\t\t\tcssCascade.startMonitoringRule(cssSyntax.parse('[style*=\"'+cssPropertyName+'\"]{'+cssPropertyName+':attr(style)}').value[0]);\r\n\t\t\tcssCascade.startMonitoringRule(cssSyntax.parse('[data-style-'+cssPropertyName+']{'+cssPropertyName+':attr(style)}').value[0]);\r\n\t\t\t\r\n\t\t\t// add to the list of polyfilled properties...\r\n\t\t\tcssCascade.getAllCSSProperties().push(cssPropertyName);\r\n\t\t\tcssCascade.computationUnsafeProperties[cssPropertyName] = true;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t};\r\n\r\n\t//\r\n\t// polyfill for browsers not support CSSStyleDeclaration.parentElement (all of them right now)\r\n\t//\r\n\tdomEvents.EventTarget.implementsIn(cssCascade);\r\n\tObject.defineProperty(Element.prototype,'myStyle',{\r\n\t\tget: function() {\r\n\t\t\tvar style = this.style; \r\n\t\t\tif(!style.parentElement) style.parentElement = this;\r\n\t\t\treturn style;\r\n\t\t}\r\n\t});\r\n\r\n\t//\r\n\t// load all stylesheets at the time the script is loaded\r\n\t// then do it again when all stylesheets are downloaded\r\n\t// and again if some style tag is added to the DOM\r\n\t//\r\n\tif(!(\"no_auto_stylesheet_detection\" in window)) {\r\n\t\t\r\n\t\tcssCascade.loadAllStyleSheets();\r\n\t\tdocument.addEventListener(\"DOMContentLoaded\", function() {\r\n\t\t\tcssCascade.loadAllStyleSheets();\r\n\t\t\tif(window.querySelectorLive) {\r\n\t\t\t\twindow.querySelectorLive(\r\n\t\t\t\t\tcssCascade.selectorForStylesheets,\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tonadded: function(e) {\r\n\t\t\t\t\t\t\t// TODO: respect DOM order?\r\n\t\t\t\t\t\t\tcssCascade.loadStyleSheetTag(e);\r\n\t\t\t\t\t\t\tcssCascade.dispatchEvent('stylesheetadded');\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\t\r\n\treturn cssCascade;\r\n\r\n})(window, document);\nrequire.define('src/core/css-cascade.js');","//\r\n// The CSS Style module attempts to provide helpers to deal with Style Declarations and elements\r\n// [0] http://lists.w3.org/Archives/Public/www-style/2013Sep/0283.html\r\n//\r\nmodule.exports = (function(window, document) { \"use strict\";\r\n\r\n\tfunction usedStyleOf(element) {\r\n\t\tvar style = element.usedStyle || getComputedStyle(element);\r\n\t\tif(!style.parentElement) { style.parentElement = element; }\r\n\t\treturn style;\r\n\t}\r\n\t\r\n\tfunction currentStyleOf(element) {\r\n\t\tvar style = element.cascadedStyle || element.specifiedStyle || element.currentStyle || getComputedStyle(element); // TODO: check CSSOM spec for real name\r\n\t\tif(!style.parentElement) { style.parentElement = element; }\r\n\t\treturn style;\r\n\t}\r\n\t\r\n\tfunction styleOf(element) {\r\n\t\tvar style = element.style;\r\n\t\tif(!style.parentElement) { style.parentElement = element; }\r\n\t\treturn style;\r\n\t}\r\n\t\r\n\tfunction runtimeStyleOf(element) {\r\n\t\tvar style = /*element.runtimeStyle || */element.style;\r\n\t\tif(!style.parentElement) { style.parentElement = element; }\r\n\t\treturn style;\r\n\t}\r\n\t\r\n\tfunction enforceStyle(element, property, value) {\r\n\t\t\r\n\t\tvar propertyBackup = null;\r\n\t\tvar usedValue = usedStyleOf(element).getPropertyValue(property);\r\n\t\tif(value instanceof Array) {\r\n\t\t\tif(value.indexOf(usedValue) >= 0) return null;\r\n\t\t\tvalue = ''+value[0];\r\n\t\t} else {\r\n\t\t\tvalue = ''+value;\r\n\t\t}\r\n\t\t\r\n\t\tif(usedValue != value) {\r\n\t\t\tvar style = runtimeStyleOf(element);\r\n\t\t\tpropertyBackup = { \r\n\t\t\t\tvalue:     style.getPropertyValue(property),\r\n\t\t\t\tpriority:  style.getPropertyPriority(property),\r\n\t\t\t\tproperty:  property\r\n\t\t\t};\r\n\t\t\tstyle.setProperty(property, \"\", \"\"); // reset [0]\r\n\t\t\tstyle.setProperty(property, \"\" + value, \"important\");\r\n\t\t}\r\n\t\t\r\n\t\treturn propertyBackup;\r\n\t\t\r\n\t}\r\n\t\r\n\tfunction enforceStyles(element, propertyValues, backups) {\r\n\t\tvar backups = backups || [];\r\n\t\tfor(var property in propertyValues) { if(propertyValues.hasOwnProperty(key)) {\r\n\t\t\tvar currentBackup = enforceStyle(element, property, propertyValues[property]);\r\n\t\t\tif(currentBackup) { backups.push(currentBackup) }\r\n\t\t}}\r\n\t\treturn backups;\r\n\t}\r\n\r\n\tfunction restoreStyle(element, backup) {\r\n\r\n\t\tif(backup) {\r\n\t\t\r\n\t\t\t// get the element runtime style\r\n\t\t\tvar style = runtimeStyleOf(element);\r\n\t\t\t\r\n\t\t\t// reset [0]\r\n\t\t\tstyle.setProperty(backup.property, \"\", \"\");\r\n\t\t\t\r\n\t\t\t// restore\r\n\t\t\tif(backup.value) {\r\n\t\t\t\tstyle.setProperty(backup.property, backup.value, \"\");\r\n\t\t\t\tstyle.setProperty(backup.property, backup.value, backup.priority);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n\tfunction restoreStyles(element, backups) {\r\n\t\tif(!backups || !(backups.length > 0)) { return; }\r\n\t\tfor(var i=backups.length; i--;) {\r\n\t\t\trestoreStyle(element, backups[i]);\r\n\t\t}\r\n\t}\r\n\t\r\n\tvar cssStyle = {\r\n\t\tstyleOf: styleOf,\r\n\t\tusedStyleOf: usedStyleOf,\r\n\t\tcurrentStyleOf: currentStyleOf,\r\n\t\truntimeStyleOf: runtimeStyleOf,\r\n\t\tenforceStyle: enforceStyle,\r\n\t\tenforceStyles: enforceStyles,\r\n\t\trestoreStyle: restoreStyle,\r\n\t\trestoreStyles: restoreStyles,\r\n\t};\r\n\t\r\n\treturn cssStyle;\r\n\r\n})(window);\nrequire.define('src/core/css-style.js');","void function() {\r\n\tif(!('uniqueID' in document.documentElement)) {\r\n\t\tvar uniqueID_counter = 0;\r\n\t\tObject.defineProperty(Element.prototype, 'uniqueID', {get: function() {\r\n\t\t\tif(this.id) {\r\n\t\t\t\treturn(this.id);\r\n\t\t\t} else {\r\n\t\t\t\treturn(this.id = (\"EL__\"+(++uniqueID_counter)+\"__\"));\r\n\t\t\t}\r\n\t\t}});\r\n\t}\r\n}();\nrequire.define('src/core/polyfill-dom-uniqueID.js');","module.exports = (function(window, document) {\r\n\t\r\n\t// import dependencies\r\n\tvar cssStyle  = require('src/core/css-style.js'),\r\n\t    usedStyleOf     = cssStyle.usedStyleOf,\r\n\t    currentStyleOf  = cssStyle.currentStyleOf,\r\n\t    enforceStyle    = cssStyle.enforceStyle,\r\n\t    restoreStyle    = cssStyle.restoreStyle;\r\n\t\r\n\t// define the module\r\n\tvar cssSizing = {\r\n\t\t\r\n\t\tabsoluteMinWidthOf: function(element) {\r\n\r\n\t\t\t//\r\n\t\t\t// make the parent a relative container (if necessary)\r\n\t\t\t//\r\n\t\t\tvar parentPositionBackup = enforceStyle(element.parentNode, \"position\", \"relative\");\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// remove the element from the flow (if necessary)\r\n\t\t\t//\r\n\t\t\tvar positionBackup = enforceStyle(element, \"position\", \"absolute\");\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// put impossible sizing constraints to the element\r\n\t\t\t//\r\n\t\t\tvar widthBackup = enforceStyle(element, \"width\", \"0px\");\r\n\t\t\tvar minWidthBackup = enforceStyle(element, \"min-width\", \"0px\");\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// see what size is finally being used\r\n\t\t\t//\r\n\t\t\tvar result = element.offsetWidth;\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// restore styling where needed\r\n\t\t\t//\r\n\t\t\trestoreStyle(element, minWidthBackup);\r\n\t\t\trestoreStyle(element, widthBackup);\r\n\t\t\trestoreStyle(element, positionBackup);\r\n\t\t\trestoreStyle(element.parentNode, parentPositionBackup);\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// return the result\r\n\t\t\t//\r\n\t\t\treturn result;\r\n\t\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tminWidthOf: function(element) {\r\n\t\t\r\n\t\t\t//\r\n\t\t\t// make the parent an infinite relative container (if necessary)\r\n\t\t\t//\r\n\t\t\tvar parentPositionBackup = enforceStyle(element.parentNode, \"position\", \"relative\");\r\n\t\t\tvar parentWidthBackup = enforceStyle(element.parentNode, \"width\", \"0px\");\r\n\t\t\tvar parentMinWidthBackup = enforceStyle(element.parentNode, \"min-width\", \"0px\");\r\n\t\t\tvar parentMaxWidthBackup = enforceStyle(element.parentNode, \"max-width\", \"0px\");\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// remove the element from the flow (if necessary)\r\n\t\t\t//\r\n\t\t\tvar positionBackup = enforceStyle(element, \"position\", \"absolute\");\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// put impossible sizing constraints to the element\r\n\t\t\t//\r\n\t\t\tvar widthBackup = enforceStyle(element, \"width\", \"auto\");\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// see what size is finally being used\r\n\t\t\t//\r\n\t\t\tvar result = element.offsetWidth;\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// restore styling where needed\r\n\t\t\t//\r\n\t\t\trestoreStyle(element, widthBackup);\r\n\t\t\trestoreStyle(element, positionBackup);\r\n\t\t\trestoreStyle(element.parentNode, parentWidthBackup);\r\n\t\t\trestoreStyle(element.parentNode, parentMaxWidthBackup);\r\n\t\t\trestoreStyle(element.parentNode, parentMinWidthBackup);\r\n\t\t\trestoreStyle(element.parentNode, parentPositionBackup);\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// return the result\r\n\t\t\t//\r\n\t\t\treturn result;\r\n\t\t},\r\n\t\t\r\n\t\tmaxWidthOf: function(element) {\r\n\t\t\r\n\t\t\t//\r\n\t\t\t// make the parent a relative container (if necessary)\r\n\t\t\t//\r\n\t\t\tvar parentPositionBackup = enforceStyle(element.parentNode, \"position\", \"relative\");\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// remove the element from the flow (if necessary)\r\n\t\t\t//\r\n\t\t\tvar positionBackup = enforceStyle(element, \"position\", \"absolute\");\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// put impossible sizing constraints to the element\r\n\t\t\t//\r\n\t\t\tvar widthBackup = enforceStyle(element, \"width\", \"auto\");\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// see what size is finally being used\r\n\t\t\t//\r\n\t\t\tvar result = element.offsetWidth;\r\n\t\t\t\t\t\r\n\t\t\t//\r\n\t\t\t// restore styling where needed\r\n\t\t\t//\r\n\t\t\trestoreStyle(element, widthBackup);\r\n\t\t\trestoreStyle(element, positionBackup);\r\n\t\t\trestoreStyle(element.parentNode, parentPositionBackup);\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// return the result\r\n\t\t\t//\r\n\t\t\treturn result;\r\n\t\t},\r\n\t\t\r\n\t\tabsoluteMaxWidthOf: function(element) {\r\n\t\t\r\n\t\t\t//\r\n\t\t\t// make the parent an infinite relative container (if necessary)\r\n\t\t\t//\r\n\t\t\tvar parentPositionBackup = enforceStyle(element.parentNode, \"position\", \"relative\");\r\n\t\t\tvar parentWidthBackup = enforceStyle(element.parentNode, \"width\", \"9999px\");\r\n\t\t\tvar parentMinWidthBackup = enforceStyle(element.parentNode, \"min-width\", \"9999px\");\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// remove the element from the flow (if necessary)\r\n\t\t\t//\r\n\t\t\tvar positionBackup = enforceStyle(element, \"position\", \"absolute\");\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// put impossible sizing constraints to the element\r\n\t\t\t//\r\n\t\t\tvar widthBackup = enforceStyle(element, \"width\", \"auto\");\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// see what size is finally being used\r\n\t\t\t//\r\n\t\t\tvar result = element.offsetWidth;\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// restore styling where needed\r\n\t\t\t//\r\n\t\t\trestoreStyle(element, widthBackup);\r\n\t\t\trestoreStyle(element, positionBackup);\r\n\t\t\trestoreStyle(element.parentNode, parentWidthBackup);\r\n\t\t\trestoreStyle(element.parentNode, parentMinWidthBackup);\r\n\t\t\trestoreStyle(element.parentNode, parentPositionBackup);\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// return the result\r\n\t\t\t//\r\n\t\t\treturn result;\r\n\t\t},\r\n\t\t\r\n\t};\r\n\t\r\n\treturn cssSizing;\r\n\t\r\n})(window, document)\nrequire.define('src/core/css-sizing.js');","//\r\n// The Box module defines algorithms for dealing with css boxes\r\n//\r\nmodule.exports = (function(window, document) {\r\n\t\r\n\t// Original code licensed by Adobe Systems Incorporated under the Apache License 2.0. \r\n\t// https://github.com/adobe-webplatform/brackets-css-shapes-editor/blob/master/thirdparty/CSSShapesEditor.js#L442\r\n\r\n\tvar cssBox = cssBox || {};\r\n\tcssBox.getBox = \r\n\t\t\r\n\t\t// returns {top/left/bottom/right} for 'content/padding/border/margin-box' relative to the border box top-left corner.\r\n\t\tfunction getBox(element, boxType){\r\n\t\t\tvar width = element.offsetWidth,\r\n\t\t\t\theight = element.offsetHeight,\r\n\r\n\t\t\t\tstyle = getComputedStyle(element),\r\n\r\n\t\t\t\tleftBorder = parseFloat(style.borderLeftWidth),\r\n\t\t\t\trightBorder = parseFloat(style.borderRightWidth),\r\n\t\t\t\ttopBorder = parseFloat(style.borderTopWidth),\r\n\t\t\t\tbottomBorder = parseFloat(style.borderBottomWidth),\r\n\r\n\t\t\t\tleftPadding = parseFloat(style.paddingLeft),\r\n\t\t\t\trightPadding = parseFloat(style.paddingRight),\r\n\t\t\t\ttopPadding = parseFloat(style.paddingTop),\r\n\t\t\t\tbottomPadding = parseFloat(style.paddingBottom),\r\n\r\n\t\t\t\tleftMargin = parseFloat(style.marginLeft),\r\n\t\t\t\trightMargin = parseFloat(style.marginRight),\r\n\t\t\t\ttopMargin = parseFloat(style.marginTop),\r\n\t\t\t\tbottomMargin = parseFloat(style.marginBottom);\r\n\r\n\t\t\tvar box = {\r\n\t\t\t\ttop: 0,\r\n\t\t\t\tleft: 0,\r\n\t\t\t\twidth: 0,\r\n\t\t\t\theight: 0\r\n\t\t\t};\r\n\r\n\t\t\tswitch (boxType||'border-box'){\r\n\t\t\tcase 'content-box':\r\n\t\t\t\tbox.top = topBorder + topPadding;\r\n\t\t\t\tbox.left = leftBorder + leftPadding;\r\n\t\t\t\tbox.width = width - leftBorder - leftPadding - rightPadding - rightBorder;\r\n\t\t\t\tbox.height = height - topBorder - topPadding - bottomPadding - bottomBorder;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'padding-box':\r\n\t\t\t\tbox.top = topPadding;\r\n\t\t\t\tbox.left = leftPadding;\r\n\t\t\t\tbox.width = width - leftBorder - rightBorder;\r\n\t\t\t\tbox.height = height - topBorder - bottomBorder;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'border-box':\r\n\t\t\t\tbox.top = 0;\r\n\t\t\t\tbox.left = 0;\r\n\t\t\t\tbox.width = width;\r\n\t\t\t\tbox.height = height;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'margin-box':\r\n\t\t\t\tbox.top = 0 - topMargin;\r\n\t\t\t\tbox.left = 0 - leftMargin;\r\n\t\t\t\tbox.width = width + leftMargin + rightMargin;\r\n\t\t\t\tbox.height = height + topMargin + bottomMargin;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new TypeError('Invalid parameter, boxType: ' + boxType);\r\n\t\t\t}\r\n\r\n\t\t\treturn box;\r\n\t\t};\r\n\t\r\n\treturn cssBox;\r\n\t\r\n})(window, document);\nrequire.define('src/core/css-box.js');","//\r\n// The CSS Units module is handling conversions between units\r\n//\r\nmodule.exports = (function(window, document) {\r\n\t\r\n\t// import dependencies\r\n\tvar getBox = require('src/core/css-box.js').getBox;\r\n\t\r\n\t// define the module\r\n\tvar cssUnits = {\r\n\t\t\r\n\t\t// converts \"cssLength\" from its inherent unit to pixels, and returns the result as a float\r\n\t\tconvertToPixels: function convertToPixels(cssLength, element, opts) {\r\n\t\t\t\r\n\t\t\tif(typeof cssLength == \"string\") {\r\n\t\t\t\r\n\t\t\t\tvar match = cssLength.match(/^\\s*(-?\\d+(?:\\.\\d+)?)(\\S*)\\s*$/);\r\n\t\t\t\tvar currentLength = match ? parseFloat(match[1]) : 0.0;\r\n\t\t\t\tvar currentUnit = match ? match[2] : '';\r\n\t\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\tvar currentLength = cssLength.value;\r\n\t\t\t\tvar currentUnit = cssLength.unit;\r\n\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\t\tvar converter = convertToPixels.converters[currentUnit];\r\n\t\t\tif (!converter) throw new Error(\"No suitable conversion from unit '\"+currentUnit+\"' to unit 'px'\");\r\n\t\t\t\r\n\t\t\tvar convertedLength = converter.call(null, currentLength, element||document.documentElement, opts)\r\n\t\t\treturn Math.round(20*convertedLength)/20;\r\n\t\t\t\r\n\t\t},\r\n\r\n\t\t// converts \"pixelLength\" from pixels to \"destinUnit\", and returns the result as a float\r\n\t\tconvertFromPixels: function convertFromPixels(pixelLength, destinUnit, element, opts) {\r\n\r\n\t\t\tvar converter = convertFromPixels.converters[destinUnit];\r\n\t\t\tif (!converter) throw new Error(\"No suitable conversion to unit '\"+destinUnit+\"' from unit 'px'\");\r\n\r\n\t\t\tvar convertedLength = converter.call(null, pixelLength, element||document.documentElement, opts)\r\n\t\t\treturn Math.round(20*convertedLength)/20;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t}\r\n\t\r\n\tcssUnits.convertToPixels.converters = {\r\n\t\t'px' : function(x) { return x; },\r\n\t\t'in' : function(x) { return x * 96; },\r\n\t\t'cm' : function(x) { return x / 0.02645833333; },\r\n\t\t'mm' : function(x) { return x / 0.26458333333; },\r\n\t\t'pt' : function(x) { return x / 0.75; },\r\n\t\t'pc' : function(x) { return x / 0.0625; },\r\n\t\t'em' : function(x, e) { return x*parseFloat(e?getComputedStyle(e).fontSize:16); },\r\n\t\t'rem': function(x, e) { return x*parseFloat(e?getComputedStyle(e.ownerDocument.documentElement).fontSize:16); },\r\n\t\t'vw' : function(x, e) { return x/100*window.innerWidth; },\r\n\t\t'vh' : function(x, e) { return x/100*window.innerHeight; },\r\n\t\t'%'  : function(x, e, opts) {\r\n\t\t\topts = opts || {};\r\n\r\n\t\t\t// get the box from which to compute the percentages\r\n\t\t\tvar box = e ? cssUtils.getBox(e, opts.boxType) : {\r\n\t\t\t\ttop: 0,\r\n\t\t\t\tleft: 0,\r\n\t\t\t\twidth: 0,\r\n\t\t\t\theight: 0\r\n\t\t\t};\r\n\r\n\t\t\t// now apply the conversion algorithm\r\n\t\t\tswitch(true) {\r\n\t\t\t\tcase opts.isRadius:\r\n\t\t\t\t\tvar radius = Math.sqrt( box.height*box.height + box.width*box.width ) / Math.sqrt(2);\r\n\t\t\t\t\treturn Math.round(x/100*radius);\r\n\t\t\t\t\t\r\n\t\t\t\tcase opts.isHeightRelated:\r\n\t\t\t\t\treturn x/100*box.height;\r\n\t\t\t\t\t\r\n\t\t\t\tcase opts.isWidthRelated: default:\r\n\t\t\t\t\treturn x/100*box.width;\r\n\t\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tcssUnits.convertFromPixels.converters = {\r\n\t\t'px' : function(x) { return x; },\r\n\t\t'in' : function(x) { return x / 96; },\r\n\t\t'cm' : function(x) { return x * 0.02645833333; },\r\n\t\t'mm' : function(x) { return x * 0.26458333333; },\r\n\t\t'pt' : function(x) { return x * 0.75; },\r\n\t\t'pc' : function(x) { return x * 0.0625; },\r\n\t\t'em' : function(x, e) { return x/parseFloat(e?getComputedStyle(e).fontSize:16); },\r\n\t\t'rem': function(x, e) { return x/parseFloat(e?getComputedStyle(e.ownerDocument.documentElement).fontSize:16); },\r\n\t\t'vw' : function(x, e) { return x*100/window.innerWidth; },\r\n\t\t'vh' : function(x, e) { return x*100/window.innerHeight; },\r\n\t\t'%'  : function(x, e, opts) {\r\n\t\t\topts = opts || {};\r\n\r\n\t\t\t// get the box from which to compute the percentages\r\n\t\t\tvar box = e ? cssUtils.getBox(e, opts.boxType) : {\r\n\t\t\t\ttop: 0,\r\n\t\t\t\tleft: 0,\r\n\t\t\t\twidth: 0,\r\n\t\t\t\theight: 0\r\n\t\t\t};\r\n\r\n\t\t\t// now apply the conversion algorithm\r\n\t\t\tswitch(true) {\r\n\t\t\t\tcase opts.isRadius:\r\n\t\t\t\t\tvar radius = Math.sqrt( box.height*box.height + box.width*box.width ) / Math.sqrt(2);\r\n\t\t\t\t\treturn Math.round(x*100/radius);\r\n\t\t\t\t\t\r\n\t\t\t\tcase opts.isHeightRelated:\r\n\t\t\t\t\treturn x*100/box.height;\r\n\t\t\t\t\t\r\n\t\t\t\tcase opts.isWidthRelated: default:\r\n\t\t\t\t\treturn x*100/box.width;\r\n\t\t\t\t\t\r\n\t\t\t}\r\n\r\n\r\n\t\t}\r\n\t};\r\n\t\r\n\treturn cssUnits;\r\n\r\n})(window, document);\nrequire.define('src/core/css-units.js');","module.exports = (function(window, document) { \"use strict\";\r\n\t\r\n\t// import dependencies\r\n\t\r\n\tvar cssSyntax = require('src/core/css-syntax.js');\r\n\t\r\n\tvar cssStyle  = require('src/core/css-style.js'),\r\n\t    usedStyleOf     = cssStyle.usedStyleOf,\r\n\t    currentStyleOf  = cssStyle.currentStyleOf,\r\n\t    enforceStyle    = cssStyle.enforceStyle,\r\n\t    restoreStyle    = cssStyle.restoreStyle;\r\n\t\r\n\trequire('src/core/polyfill-dom-uniqueID.js');\r\n\trequire('src/core/polyfill-dom-requestAnimationFrame.js');\r\n\t\r\n\tvar createRuntimeStyle = function(reason, element) {\r\n\t\t\r\n\t\t// expand the reason\r\n\t\tif(element) {\r\n\t\t\treason = (element.id || element.uniqueID) + '-' + reason;\r\n\t\t}\r\n\t\t\r\n\t\t// create style element\r\n\t\tvar styleElement = document.getElementById(reason+'-polyfill-overrides');\r\n\t\tif(!styleElement) {\r\n\t\t\tstyleElement = document.createElement('style');\r\n\t\t\tstyleElement.id = reason+'-polyfill-overrides';\r\n\t\t\tstyleElement.setAttribute('data-css-polyfilled', true);\r\n\t\t\tstyleElement.appendChild(document.createTextNode(\"\")); // WebKit fix\r\n\t\t\tdocument.querySelector(':root > head').appendChild(styleElement);\r\n\t\t}\r\n\t\t\r\n\t\t// get the associated style sheet\r\n\t\tvar ss = styleElement.sheet;\r\n\t\t\r\n\t\t// return a wrapper\r\n\t\treturn {\r\n\t\t\tset: function(element, properties) {\r\n\t\t\t\t\r\n\t\t\t\t// give an id to the element\r\n\t\t\t\tif(!element.id) { element.id = element.uniqueID; }\r\n\t\t\t\r\n\t\t\t\t// compute the css rule to add\r\n\t\t\t\tvar rule = \"#\"+element.id+\" {\";\r\n\t\t\t\tfor(var property in properties) {\r\n\t\t\t\t\tif(properties.hasOwnProperty(property)) {\r\n\t\t\t\t\t\trule += property + \": \" + properties[property] + \" !important; \";\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\trule += \"}\";\r\n\t\t\t\t\r\n\t\t\t\t// and then add it\r\n\t\t\t\treturn ss.insertRule(rule, ss.length);\r\n\t\t\t\t\r\n\t\t\t},\r\n\t\t\trevoke: function() {\r\n\t\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t\t},\r\n\t\t\tenable: function() {\r\n\t\t\t\tss.disabled = false;\r\n\t\t\t},\r\n\t\t\tdisable: function() {\r\n\t\t\t\tss.disabled = true;\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tvar cssSizing = require('src/core/css-sizing.js');\r\n\t\r\n\tvar cssUnits = require('src/core/css-units.js');\r\n\t\r\n\t// define the module\r\n\tvar LOCATE_AUTO = 0;\r\n\tvar LOCATE_LINE = 1;\r\n\tvar LOCATE_SPAN = 2;\r\n\tvar LOCATE_AREA = 3;\r\n\t\r\n\tvar ALIGN_START  = 0;\r\n\tvar ALIGN_CENTER = 1;\r\n\tvar ALIGN_END    = 2;\r\n\tvar ALIGN_FIT    = 3;\r\n\t\r\n\tvar TRACK_BREADTH_AUTO        = 0;\r\n\tvar TRACK_BREADTH_LENGTH      = 1;\r\n\tvar TRACK_BREADTH_FRACTION    = 2;\r\n\tvar TRACK_BREADTH_PERCENTAGE  = 3;\r\n\tvar TRACK_BREADTH_MIN_CONTENT = 4;\r\n\tvar TRACK_BREADTH_MAX_CONTENT = 5;\r\n\t\r\n\tfunction GridTrackBreadth() {\r\n\t\tthis.minType = TRACK_BREADTH_AUTO;\r\n\t\tthis.minValue = \"auto\";\r\n\t\tthis.maxType = TRACK_BREADTH_AUTO;\r\n\t\tthis.maxValue = \"auto\";\r\n\t}\r\n\t\r\n\tGridTrackBreadth.prototype = {\r\n\t\ttoString: function() {\r\n\t\t\tif(this.minType==this.maxType && this.minValue==this.maxValue) {\r\n\t\t\t\tswitch(this.minType) {\r\n\t\t\t\t\tcase TRACK_BREADTH_AUTO: return \"auto\";\r\n\t\t\t\t\tcase TRACK_BREADTH_LENGTH: return this.minValue+\"px\";\r\n\t\t\t\t\tcase TRACK_BREADTH_FRACTION: return this.minValue+\"fr\";\r\n\t\t\t\t\tcase TRACK_BREADTH_PERCENTAGE: return this.minValue+\"%\";\r\n\t\t\t\t\tcase TRACK_BREADTH_MIN_CONTENT: return \"min-content\";\r\n\t\t\t\t\tcase TRACK_BREADTH_MAX_CONTENT: return \"max-content\";\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar min = \"auto\";\r\n\t\t\t\tvar max = \"auto\";\r\n\t\t\t\tswitch(this.minType) {\r\n\t\t\t\t\tcase TRACK_BREADTH_AUTO: min = \"auto\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_LENGTH: min = this.minValue+\"px\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_FRACTION: min = this.minValue+\"fr\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_PERCENTAGE: min = this.minValue+\"%\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_MIN_CONTENT: min = \"min-content\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_MAX_CONTENT: min = \"max-content\"; break;\r\n\t\t\t\t}\r\n\t\t\t\tswitch(this.maxType) {\r\n\t\t\t\t\tcase TRACK_BREADTH_AUTO: max = \"auto\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_LENGTH: max = this.maxValue+\"px\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_FRACTION: max = this.maxValue+\"fr\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_PERCENTAGE: max = this.maxValue+\"%\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_MIN_CONTENT: max = \"min-content\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_MAX_CONTENT: max = \"max-content\"; break;\r\n\t\t\t\t}\r\n\t\t\t\treturn \"minmax(\" + min + \", \" + max + \")\";\r\n\t\t\t}\r\n\t\t},\r\n\t\tsetValue: function(type, val) {\r\n\t\t\tthis.minType  = this.maxType  = type;\r\n\t\t\tthis.minValue = this.maxValue = val;\r\n\t\t},\r\n\t\tsetMaxValue: function(type, val) {\r\n\t\t\tthis.maxType  = type;\r\n\t\t\tthis.maxValue = val;\r\n\t\t},\r\n\t\tsetMinValue: function(type, val) {\r\n\t\t\tthis.minType  = type;\r\n\t\t\tthis.minValue = val;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction GridItemPosition(type, name, index) {\r\n\t\tthis.type = type|LOCATE_AUTO;\r\n\t\tthis.name = name;\r\n\t\tthis.index = index|0;\r\n\t}\r\n\t\r\n\tGridItemPosition.prototype = {\r\n\t\textractXLineIndex: function(grid, TODO_args) {\r\n\t\t\tthrow \"Not implemented\";\r\n\t\t},\r\n\t\textractYLineIndex: function(grid, TODO_args) {\r\n\t\t\tthrow \"Not implemented\";\r\n\t\t},\r\n\t\ttoString: function() {\r\n\t\t\t\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction GridItem(element, parentGrid) {\r\n\t\t\r\n\t\tthis.element = element;\r\n\t\tthis.parentGrid = element.parentGridLayout = parentGrid;\r\n\t\t\r\n\t\tthis.reset();\r\n\t\tthis.buggy = true;\r\n\t\t\r\n\t}\r\n\t\r\n\tGridItem.prototype = {\r\n\t\t\r\n\t\tdispose: function() {\r\n\t\t\tthis.element.parentGridLayout = undefined;\r\n\t\t},\r\n\t\t\r\n\t\treset: function() {\r\n\t\t\t\r\n\t\t\tthis.minWidth = 0;\r\n\t\t\tthis.maxWidth = 0;\r\n\t\t\t\r\n\t\t\tthis.hMargins = 0;\r\n\t\t\tthis.vMargins = 0;\r\n\t\t\tthis.hPaddings = 0;\r\n\t\t\tthis.vPaddings = 0;\r\n\t\t\tthis.hBorders = 0;\r\n\t\t\tthis.vBorders = 0;\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tthis.xStart = -1;\r\n\t\t\tthis.xEnd = -1;\r\n\t\t\t\r\n\t\t\tthis.specifiedXStart = this.specifiedXStart || new GridItemPosition();\r\n\t\t\tthis.specifiedXStart.type = LOCATE_AUTO;\r\n\t\t\tthis.specifiedXStart.name = undefined;\r\n\t\t\tthis.specifiedXStart.index = undefined;\r\n\t\t\t\r\n\t\t\tthis.specifiedXEnd = this.specifiedXEnd || new GridItemPosition();\r\n\t\t\tthis.specifiedXEnd.type = LOCATE_AUTO;\r\n\t\t\tthis.specifiedXEnd.name = undefined;\r\n\t\t\tthis.specifiedXEnd.index = undefined;\r\n\r\n\t\t\t\r\n\t\t\tthis.yStart = -1;\r\n\t\t\tthis.yEnd = -1;\r\n\t\t\t\r\n\t\t\tthis.specifiedYStart = this.specifiedYStart || new GridItemPosition();\r\n\t\t\tthis.specifiedYStart.type = LOCATE_AUTO;\r\n\t\t\tthis.specifiedYStart.name = undefined;\r\n\t\t\tthis.specifiedYStart.index = undefined;\r\n\t\t\t\r\n\t\t\tthis.specifiedYEnd = this.specifiedYEnd || new GridItemPosition();\r\n\t\t\tthis.specifiedYEnd.type = LOCATE_AUTO;\r\n\t\t\tthis.specifiedYEnd.name = undefined;\r\n\t\t\tthis.specifiedYEnd.index = undefined;\r\n\t\t\t\r\n\t\t\tthis.marginAlignX = ALIGN_CENTER;\r\n\t\t\tthis.marginAlignY = ALIGN_CENTER;\r\n\t\t\t\r\n\t\t\tthis.paddingAlignX = ALIGN_FIT;\r\n\t\t\tthis.paddingAlignY = ALIGN_FIT;\r\n\t\t\t\r\n\t\t\t\r\n\t\t},\r\n\t\r\n\t\tupdateFromElement: function() {\r\n\t\t\t\r\n\t\t\tvar element = this.element;\r\n\t\t\tvar usedStyle = usedStyleOf(element);\r\n\t\t\tvar style = currentStyleOf(element);\r\n\t\t\tvar getStyle = function(prop) {\r\n\t\t\t\tvar value = style[prop];\r\n\t\t\t\tif(typeof(value)==\"undefined\") { return \"\"; }\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis.reset(); \r\n\t\t\tthis.buggy = false;\r\n\t\t\t\r\n\t\t\t// compute size\r\n\t\t\tthis.minWidth = cssSizing.minWidthOf(element);\r\n\t\t\tthis.maxWidth = cssSizing.maxWidthOf(element);\r\n\t\t\t\r\n\t\t\tthis.hMargins = parseInt(usedStyle.getPropertyValue('margin-left')) + parseInt(usedStyle.getPropertyValue('margin-right'));\r\n\t\t\tthis.vMargins = parseInt(usedStyle.getPropertyValue('margin-top')) + parseInt(usedStyle.getPropertyValue('margin-bottom'));\r\n\t\t\tthis.hPaddings = parseInt(usedStyle.getPropertyValue('padding-left')) + parseInt(usedStyle.getPropertyValue('padding-right'));\r\n\t\t\tthis.vPaddings = parseInt(usedStyle.getPropertyValue('padding-top')) + parseInt(usedStyle.getPropertyValue('padding-bottom'));\r\n\t\t\tthis.hBorders = parseInt(usedStyle.getPropertyValue('border-left-width')) + parseInt(usedStyle.getPropertyValue('border-right-width'));\r\n\t\t\tthis.vBorders = parseInt(usedStyle.getPropertyValue('border-top-width')) + parseInt(usedStyle.getPropertyValue('border-bottom-width'));\r\n\t\t\t\r\n\t\t\t// locate x and y lines together\r\n\t\t\tif(style[\"grid-area\"]) {\r\n\t\t\t\tvar parts = getStyle(\"grid-area\").split('/');\r\n\t\t\t\tvar is_ident = /^\\s*([a-z][-_a-z0-9]*)\\s*$/i;\r\n\t\t\t\tvar row_start = parts[0] || 'auto';\r\n\t\t\t\tvar col_start = parts[1] || (is_ident.test(row_start) ? row_start : 'auto');\r\n\t\t\t\tvar row_end = parts[2] || (is_ident.test(row_start) ? row_start : 'auto');\r\n\t\t\t\tvar col_end = parts[3] || (is_ident.test(col_start) ? col_start : 'auto');\r\n\t\t\t\tthis.parseLocationInstructions(this.specifiedXStart, this.specifiedXEnd, col_start + \" / \" + col_end);\r\n\t\t\t\tthis.parseLocationInstructions(this.specifiedYStart, this.specifiedYEnd, row_start + \" / \" + row_end);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// locate x lines\r\n\t\t\tif(style[\"grid-column\"] || style[\"grid-column-start\"] || style[\"grid-column-end\"]) {\r\n\t\t\t\tvar parts = getStyle(\"grid-column\").split('/');\r\n\t\t\t\tvar start = getStyle(\"grid-column-start\") || parts[0] || 'auto';\r\n\t\t\t\tvar end   = getStyle(\"grid-column-end\") || parts[1] || parts[0] || start;\r\n\t\t\t\tthis.parseLocationInstructions(this.specifiedXStart, this.specifiedXEnd, start + \" / \" + end);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// locate y lines\r\n\t\t\tif(style[\"grid-row\"] || style[\"grid-row-start\"] || style[\"grid-row-end\"]) {\r\n\t\t\t\tvar parts = getStyle(\"grid-row\").split('/');\r\n\t\t\t\tvar start = getStyle(\"grid-row-start\") || parts[0];\r\n\t\t\t\tvar end   = getStyle(\"grid-row-end\") || parts[1] || parts[0];\r\n\t\t\t\tthis.parseLocationInstructions(this.specifiedYStart, this.specifiedYEnd, start + \" / \" + end);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// FIXME: is it possible to understand cascading here, and not use a fixed order?\r\n\t\t\t// TODO: other positioning methods\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tparseLocationInstructions: function(specifiedStart, specifiedEnd, cssText) {\r\n\t\t\t\r\n\t\t\tvar unfiltred_value = cssSyntax.parseCSSValue(cssText);\r\n\t\t\tvar value = unfiltred_value.filter(function(o) { return !(o instanceof cssSyntax.WhitespaceToken); });\r\n\t\t\tvalue.toCSSString = function() { return unfiltred_value.toCSSString(); }\r\n\t\t\tvar I = 0;\r\n\t\t\t\r\n\t\t\tvar updateNameOrIndex = function(data) {\r\n\t\t\t\tif(value[I] instanceof cssSyntax.IdentifierToken) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// grid-column: C;\r\n\t\t\t\t\tif(data.name) { \r\n\t\t\t\t\t\t// duplicate line-name value\r\n\t\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (duplicate line name)\");\r\n\t\t\t\t\t\tthis.buggy = true;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdata.name = value[I++].value;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(value[I] instanceof cssSyntax.NumberToken) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// grid-column: 3\r\n\t\t\t\t\tdata.index = value[I].value|0;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// only accept integer values\r\n\t\t\t\t\tif(value[I].value != data.index) {\r\n\t\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (non-integer number)\");\r\n\t\t\t\t\t\tthis.buggy = true;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// do not accept zero\r\n\t\t\t\t\tif(data.index == 0) {\r\n\t\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (line index can't be zero)\");\r\n\t\t\t\t\t\tthis.buggy = true;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// do not accept negative spans\r\n\t\t\t\t\tif(data.index <= 0 && data.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (negative spans not allowed)\");\r\n\t\t\t\t\t\tthis.buggy = true;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tI++;\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(value[I] instanceof cssSyntax.DelimToken && value[I].value == \"/\") {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// break grid-column-start detection\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// this is wrong\r\n\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (invalid token)\");\r\n\t\t\t\t\tthis.buggy = true;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tvar gatherNameIndexPair = function(data) {\r\n\r\n\t\t\t\t// first token to be analyzed (may be either kind)\r\n\t\t\t\tupdateNameOrIndex.call(this, data);\r\n\t\t\t\t\r\n\t\t\t\t// abort if no second token or buggy\r\n\t\t\t\tif(this.buggy || !value[I]) { return; }\r\n\t\t\t\r\n\t\t\t\t// second token to be analyzed (will have to be the other kind)\r\n\t\t\t\tupdateNameOrIndex.call(this, data);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(!value[I]) { console.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (empty declaration)\"); this.buggy = true; return; }\r\n\t\t\t\r\n\r\n\t\t\t// first part\r\n\t\t\tgridColumnStart: while(true) {\r\n\t\t\t\tif(value[I] instanceof cssSyntax.IdentifierToken) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(value[I].value == \"span\") {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif(!value[++I]) {console.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (span is not a valid line name, more tokens expected)\"); this.buggy = true; return; }\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tspecifiedStart.type = LOCATE_SPAN;\r\n\t\t\t\t\t\tspecifiedStart.name = undefined;\r\n\t\t\t\t\t\tspecifiedStart.index = undefined;\r\n\t\t\t\t\t\tgatherNameIndexPair.call(this, specifiedStart);\r\n\t\t\t\t\t\tif(this.buggy) { return; }\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\t\t} else if(value[I].value == \"auto\") {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tspecifiedStart.type = LOCATE_AUTO;\r\n\t\t\t\t\t\tspecifiedStart.name = undefined;\r\n\t\t\t\t\t\tspecifiedStart.index = undefined;\r\n\t\t\t\t\t\tI++; break;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// grid-column: start-line...\r\n\t\t\t\t\t\tspecifiedStart.type = LOCATE_LINE;\r\n\t\t\t\t\t\tspecifiedStart.name = undefined;\r\n\t\t\t\t\t\tspecifiedStart.index = undefined;\r\n\t\t\t\t\t\tgatherNameIndexPair.call(this, specifiedStart);\r\n\t\t\t\t\t\tif(this.buggy) { return; }\r\n\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(value[I] instanceof cssSyntax.DelimToken && value[I].value == \"/\") {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// this is wrong\r\n\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (no token to analyze before the slash token)\");\r\n\t\t\t\t\tthis.buggy = true;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\tspecifiedStart.type = LOCATE_LINE;\r\n\t\t\t\t\tgatherNameIndexPair.call(this, specifiedStart);\r\n\t\t\t\t\tif(this.buggy) { return; }\r\n\t\t\t\t\t\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// test whether there is a second part\r\n\t\t\tif(value[I]) {\r\n\t\t\t\t\r\n\t\t\t\tif(value[I] instanceof cssSyntax.DelimToken && value[I].value == \"/\") {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// second part will start now\r\n\t\t\t\t\tif(!value[++I]) {\r\n\t\t\t\t\t\t// unexpected lack token at the start of the second part\r\n\t\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (expected at least one more token after the slash token)\");\r\n\t\t\t\t\t\tthis.buggy = true; \r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t\t// unexpected token at the end of the first part\r\n\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (expected slash / or end of declaration)\");\r\n\t\t\t\t\tthis.buggy = true; \r\n\t\t\t\t\treturn;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// end of declaration\r\n\t\t\t\tif(specifiedStart.type == LOCATE_LINE && specifiedStart.name != undefined && specifiedStart.index == undefined) {\r\n\t\t\t\t\t// a value consisting of a custom ident is duplicated to the other side\r\n\t\t\t\t\tspecifiedEnd.type = LOCATE_LINE;\r\n\t\t\t\t\tspecifiedEnd.name = specifiedStart.name;\r\n\t\t\t\t\tspecifiedEnd.index = undefined;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// the default value (auto) is a 1-line span in all other cases\r\n\t\t\t\t\tspecifiedEnd.type = LOCATE_AUTO;\r\n\t\t\t\t\tspecifiedEnd.name = undefined;\r\n\t\t\t\t\tspecifiedEnd.index = undefined;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// second part (after the \"/\" token)\r\n\t\t\tgridColumnEnd: while(value[I]) {\r\n\t\t\t\t\r\n\t\t\t\tif(value[I] instanceof cssSyntax.IdentifierToken) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(value[I].value == \"span\") {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif(!value[++I]) {console.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (span is not a valid line name, more tokens expected)\"); this.buggy = true; return; }\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tspecifiedEnd.type = LOCATE_SPAN;\r\n\t\t\t\t\t\tspecifiedEnd.name = undefined;\r\n\t\t\t\t\t\tspecifiedEnd.index = undefined;\r\n\t\t\t\t\t\tgatherNameIndexPair.call(this, specifiedEnd);\r\n\t\t\t\t\t\tif(this.buggy) { return; }\r\n\t\t\t\t\t\r\n\t\t\t\t\t} else if(value[I].value == \"auto\") {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tspecifiedEnd.type = LOCATE_AUTO;\r\n\t\t\t\t\t\tspecifiedEnd.name = undefined;\r\n\t\t\t\t\t\tspecifiedEnd.index = undefined;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// grid-column: start-line...\r\n\t\t\t\t\t\tspecifiedEnd.type = LOCATE_LINE;\r\n\t\t\t\t\t\tspecifiedEnd.name = undefined;\r\n\t\t\t\t\t\tspecifiedEnd.name = undefined;\r\n\t\t\t\t\t\tspecifiedEnd.index = undefined;\r\n\t\t\t\t\t\tgatherNameIndexPair.call(this, specifiedEnd);\r\n\t\t\t\t\t\tif(this.buggy) { return; }\r\n\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(value[I] instanceof cssSyntax.DelimToken && value[I].value == \"/\") {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// this is wrong\r\n\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (no token to analyze before the slash token)\");\r\n\t\t\t\t\tthis.buggy = true;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\tspecifiedEnd.type = LOCATE_LINE;\r\n\t\t\t\t\tgatherNameIndexPair.call(this, specifiedEnd);\r\n\t\t\t\t\tif(this.buggy) { return; }\r\n\t\t\t\t\t\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tbreak;\t\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(value[I]) {\r\n\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (tokens after end)\");\r\n\t\t\t\tthis.buggy = true; \r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// If the <integer> is omitted, it defaults to 1.\r\n\t\t\t//if(specifiedStart.name && specifiedStart.index == undefined) { specifiedStart.index = 1; }\r\n\t\t\t//if(specifiedEnd.name && specifiedEnd.index == undefined) { specifiedEnd.index = 1; }\r\n\t\t\t\r\n\t\t\t// If both grid-row/column-start and grid-row/column-end specify a span, the end span is ignored. \r\n\t\t\tif(specifiedEnd.type == LOCATE_SPAN && specifiedStart.type == LOCATE_SPAN) { specifiedEnd.type = LOCATE_AUTO; specifiedEnd.index = undefined; specifiedEnd.name = undefined; }\r\n\t\t\t\r\n\t\t\treturn [specifiedStart, specifiedEnd];\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\r\n\t};\t\r\n\r\n\tfunction GridLayout(element) {\r\n\t\r\n\t\t// items\r\n\t\tthis.element = element; this.element.gridLayout = this;\r\n\t\tthis.items = []; // array of GridItem\r\n\r\n\t\t// reset\r\n\t\tthis.reset();\r\n\t\t\r\n\t\t// other fields\r\n\t\tthis.isLayoutScheduled = false;\r\n\t\t\r\n\t}\r\n\t\r\n\tGridLayout.prototype = {\r\n\t\r\n\t\treset: function() {\r\n\t\t\t\r\n\t\t\t// computed\r\n\t\t\tthis.xLines = []; // array of array of names\r\n\t\t\tthis.xSizes = []; // array of numbers (in pixels)\r\n\t\t\t\r\n\t\t\tthis.yLines = [];\r\n\t\t\tthis.ySizes = [];\r\n\r\n\t\t\tthis.growX = false;\r\n\t\t\tthis.growY = true;\r\n\t\t\tthis.growDense = false;\r\n\t\t\t\r\n\t\t\tthis.rcMatrix = []; // array of array of (whatever is not undefined, probably \"true\")\r\n\t\t\t\r\n\t\t\t// specified\r\n\t\t\tthis.specifiedXLines = [];\r\n\t\t\tthis.specifiedXSizes = [];\r\n\t\t\t\r\n\t\t\tthis.specifiedYLines = [];\r\n\t\t\tthis.specifiedYSizes = [];\r\n\t\t\t\r\n\t\t\tthis.defaultXSize = new GridTrackBreadth();\r\n\t\t\tthis.defaultYSize = new GridTrackBreadth();\r\n\r\n\t\t},\r\n\t\r\n\t\tR: function R(x,y) { \r\n\t\t\tif(this.growY) {\r\n\t\t\t\t// we grow by adding rows (normal behavior)\r\n\t\t\t\treturn y;\r\n\t\t\t} else {\r\n\t\t\t\t// we grow by adding columns (inversed behavior)\r\n\t\t\t\treturn x;\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\tC: function C(x,y) { \r\n\t\t\tif(this.growY) {\r\n\t\t\t\t// we grow by adding rows (normal behavior)\r\n\t\t\t\treturn x;\r\n\t\t\t} else {\r\n\t\t\t\t// we grow by adding columns (inversed behavior)\r\n\t\t\t\treturn y;\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\tdispose: function() {\r\n\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i];\r\n\t\t\t\titem.dispose();\r\n\t\t\t}\r\n\t\t\tthis.element.gridLayout = undefined;\r\n\t\t},\r\n\t\t\r\n\t\tupdateFromElement: function() {\r\n\t\t\t\r\n\t\t\t// delete old items\r\n\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i];\r\n\t\t\t\titem.dispose();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// add new items\r\n\t\t\tthis.items.length = 0;\r\n\t\t\tvar currentItem = this.element.firstElementChild;\r\n\t\t\twhile(currentItem) {\r\n\t\t\t\t\r\n\t\t\t\t// add a new grid item for the element\r\n\t\t\t\tvar newGridItem = new GridItem(currentItem, this);\r\n\t\t\t\tnewGridItem.updateFromElement();\r\n\t\t\t\tthis.items.push(newGridItem);\r\n\t\t\t\t\r\n\t\t\t\t// move to the next element\r\n\t\t\t\tcurrentItem = currentItem.nextElementSibling;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// reset the style\r\n\t\t\tthis.reset();\r\n\t\t\t\r\n\t\t\t// update its own style\r\n\t\t\tvar style = usedStyleOf(this.element); var cssText = '';\r\n\t\t\tif(cssText=style[\"grid-template\"])         { this.parseGridTemplate(cssText);    }\r\n\t\t\tif(cssText=style[\"grid-template-rows\"])    { this.parseRowsTemplate(cssText);    }\r\n\t\t\tif(cssText=style[\"grid-template-columns\"]) { this.parseColumnsTemplate(cssText); }\r\n\t\t\tif(cssText=style[\"grid-template-areas\"])   { this.parseAreasTemplate(cssText);   }\r\n\t\t\tif(cssText=style[\"grid-auto-rows\"]) { this.parseAutoRowsBreadth(cssText); }\r\n\t\t\tif(cssText=style[\"grid-auto-columns\"]) { this.parseAutoColumnsBreadth(cssText); }\r\n\t\t\tif(cssText=style[\"grid-auto-flow\"]) { // FIXME: should be in a function\r\n\t\t\t\t\r\n\t\t\t\t// FIXME: not a real parse...\r\n\t\t\t\tvar tokens = cssText.trim().toLowerCase().split(/\\s+/g);\r\n\t\t\t\t\r\n\t\t\t\t// direction\r\n\t\t\t\tif(tokens.indexOf('row')>=0) {\r\n\t\t\t\t\tthis.growX = false;\r\n\t\t\t\t\tthis.growY = true;\r\n\t\t\t\t} else if(tokens.indexOf('column')>=0) {\r\n\t\t\t\t\tthis.growX = true;\r\n\t\t\t\t\tthis.growY = false;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// algorithm\r\n\t\t\t\t// FIXME: should also support 'stack' (wtf)\r\n\t\t\t\tif(tokens.indexOf('dense')>=0) {\r\n\t\t\t\t\tthis.growDense = true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.growDense = false;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tresetItems: function() {\r\n\t\t\tfor(var i = this.items.length; i--;) {\r\n\t\t\t\tvar item = this.items[i]; \r\n\t\t\t\titem.xStart = item.xEnd = item.yStart = item.yEnd = -1;\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\tresetLinesToSpecified: function() {\r\n\t\t\tthis.xLines = this.specifiedXLines.slice(0);\r\n\t\t\tthis.xSizes = this.specifiedXSizes.slice(0);\r\n\t\t\tthis.yLines = this.specifiedYLines.slice(0);\r\n\t\t\tthis.ySizes = this.specifiedYSizes.slice(0);\r\n\t\t},\r\n\t\t\r\n\t\tparseTrackBreadthToken: function(cssToken) {\r\n\t\t\t\r\n\t\t\t// try to match a pattern\r\n\t\t\tif(cssToken instanceof cssSyntax.IdentifierToken) {\r\n\t\t\t\t\r\n\t\t\t\tif(cssToken.value == \"auto\") {\r\n\t\t\t\t\treturn { type: TRACK_BREADTH_AUTO, value:\"auto\" };\r\n\t\t\t\t} else if(cssToken.value == \"min-content\") {\r\n\t\t\t\t\treturn { type: TRACK_BREADTH_MIN_CONTENT, value:\"min-content\" };\r\n\t\t\t\t} else if(cssToken.value == \"max-content\") {\r\n\t\t\t\t\treturn { type: TRACK_BREADTH_MAX_CONTENT, value:\"max-content\" };\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else if(cssToken instanceof cssSyntax.DimensionToken) {\r\n\t\t\t\t\r\n\t\t\t\tif(cssToken.unit == \"fr\") {\r\n\t\t\t\t\treturn { type: TRACK_BREADTH_FRACTION, value:cssToken.num };\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn { type: TRACK_BREADTH_LENGTH, value:cssUnits.convertToPixels(cssToken.toCSSString(), this.element) };\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else if(cssToken instanceof cssSyntax.PercentageToken) {\r\n\t\t\t\t\r\n\t\t\t\treturn { type: TRACK_BREADTH_PERCENTAGE, value:cssToken.value };\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// TODO: recognize \"calc()\", too\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn null;\r\n\t\t},\r\n\t\t\r\n\t\tparseTrackBreadth: function(value, I) {\r\n\t\t\r\n\t\t\t// TODO: try catch on null parsed token\r\n\t\t\tvar buggy = false;\r\n\t\t\t\r\n\t\t\tvar currentTrackBreadth = new GridTrackBreadth();\r\n\t\t\tvar parseTrackBreadthToken = function() {\r\n\t\t\t\t\r\n\t\t\t\t// try to match a pattern\r\n\t\t\t\tvar result = this.parseTrackBreadthToken(value[I]);\r\n\t\t\t\tif(result) { I++; return result; }\r\n\t\t\t\t\r\n\t\t\t\t// no pattern matched, so the declaration is invalid:\r\n\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-template-rows/columns: \"+value.toCSSString()+\" (unrecognized track breadth)\");\r\n\t\t\t\tbuggy = true;\r\n\t\t\t\treturn;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(value[I] instanceof cssSyntax.Func && value[I].name==\"minmax\") {\r\n\t\t\t\t\r\n\t\t\t\t// we need to parse two subvalues\r\n\t\t\t\tvar value_backup = value;\r\n\t\t\t\tvar I_backup = I;\r\n\t\t\t\t\r\n\t\t\t\t// check we have exactly two arguments\r\n\t\t\t\tvar args = value_backup[I_backup].getArguments();\r\n\t\t\t\tif(args.length != 2) { \r\n\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-template-rows/columns: \"+value_backup.toCSSString()+\" (invalid number of arguments to the minmax function)\");\r\n\t\t\t\t\tbuggy = true;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// here's the first one:\r\n\t\t\t\tvalue = args[0].value.filter(function(t) { return !(t instanceof cssSyntax.WhitespaceToken) }); I = 0;\t\t\t\t\r\n\t\t\t\tvar data = parseTrackBreadthToken.call(this);\r\n\t\t\t\tcurrentTrackBreadth.minType = data.type;\r\n\t\t\t\tcurrentTrackBreadth.minValue = data.value;\r\n\t\t\t\t\r\n\t\t\t\t// here's the second one:\r\n\t\t\t\tvalue = args[1].value.filter(function(t) { return !(t instanceof cssSyntax.WhitespaceToken) }); I = 0;\t\t\t\t\r\n\t\t\t\tvar data = parseTrackBreadthToken.call(this);\r\n\t\t\t\tcurrentTrackBreadth.maxType  = data.type;\r\n\t\t\t\tcurrentTrackBreadth.maxValue = data.value;\r\n\t\t\t\t\r\n\t\t\t\t// restore context\r\n\t\t\t\tvalue = value_backup;\r\n\t\t\t\tI = I_backup+1;\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\r\n\t\t\t\t// we need to parse only one value\r\n\t\t\t\tvar data = parseTrackBreadthToken.call(this);\r\n\t\t\t\tcurrentTrackBreadth.minType  = currentTrackBreadth.maxType  = data.type;\r\n\t\t\t\tcurrentTrackBreadth.minValue = currentTrackBreadth.maxValue = data.value;\r\n\r\n\t\t\t}\r\n\t\t\t\t\r\n\t\t\treturn { result: currentTrackBreadth, I:I };\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tparseAutoRowsBreadth: function(cssText) {\r\n\t\t\r\n\t\t\t// TODO: check that no tokens are left when the parsing is done (+columns)\r\n\t\t\t\r\n\t\t\t// parse value into tokens:\r\n\t\t\tvar unfiltred_value = cssSyntax.parseCSSValue(cssText);\r\n\t\t\tvar value = unfiltred_value.filter(function(o) { return !(o instanceof cssSyntax.WhitespaceToken); });\r\n\t\t\tvalue.toCSSString = function() { return unfiltred_value.toCSSString(); }\r\n\t\t\t\r\n\t\t\t// parse tokens into data:\r\n\t\t\tvar data = this.parseTrackBreadth(value, 0);\r\n\t\t\tif(data.result) { this.defaultYSize = data.result; } else { throw \"TODO: better error message\"; }\r\n\t\t\treturn;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tparseAutoColumnsBreadth: function(cssText) {\r\n\t\t\t\r\n\t\t\t// parse value into tokens:\r\n\t\t\tvar unfiltred_value = cssSyntax.parseCSSValue(cssText);\r\n\t\t\tvar value = unfiltred_value.filter(function(o) { return !(o instanceof cssSyntax.WhitespaceToken); });\r\n\t\t\tvalue.toCSSString = function() { return unfiltred_value.toCSSString(); }\r\n\t\t\t\r\n\t\t\t// parse tokens into data:\r\n\t\t\tvar data = this.parseTrackBreadth(value, 0);\r\n\t\t\tif(data.result) { this.defaultXSize = data.result; } else { throw \"TODO: better error message\"; }\r\n\t\t\treturn;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tparseGridTemplate: function(cssText) { // TODO: I used some lazy heuristics here\r\n\t\t\tvar buggy = false; \r\n\t\t\r\n\t\t\t// step 1: columns are defined before the slash, if any\r\n\t\t\tvar cssText = cssText.replace(/\\/\\*(.*?)\\*\\//g,\"\");\r\n\t\t\tvar cssTextSections = cssText.split(\"/\");\r\n\t\t\tif(cssTextSections.length == 2) {\r\n\t\t\t\tif(this.parseColumnsTemplate(cssTextSections[0])) { return buggy=true; }\r\n\t\t\t\tcssText = cssTextSections[1];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// check that the syntax makes sense\r\n\t\t\telse if(cssTextSections.length >= 3) { \r\n\t\t\t\treturn buggy=true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// check if we can find any string\r\n\t\t\tif(/\"|'/.test(cssText)) {\r\n\t\t\t\r\n\t\t\t\t// extract strings from the value\r\n\t\t\t\tvar strings = [];\r\n\t\t\t\tcssText = cssText.replace(/\\s*(\"(?:.*?)\"|'(?:.*?)')\\s*([-_a-zA-Z0-9]*)\\s*/g,function(data,str,size) { strings.push(str); return ' '+(size||\"auto\")+' '; });\r\n\t\t\t\t\r\n\t\t\t\t// remove duplicate line name blocks\r\n\t\t\t\tcssText = cssText.replace(/\\)\\s*\\(/g,\" \");\r\n\t\t\t\t\r\n\t\t\t\t// parse rows now\r\n\t\t\t\tif(this.parseRowsTemplate(cssText)) { return buggy=true; }\r\n\t\t\t\t\r\n\t\t\t\t// parse areas now\r\n\t\t\t\tif(this.parseAreasTemplate(strings.join(' '))) { return buggy=true; }\r\n\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// parse rows now\r\n\t\t\t\tif(this.parseRowsTemplate(cssText)) { return buggy=true; }\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn buggy;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tparseAreasTemplate: function(cssText) {\r\n\t\t\t\r\n\t\t\t// parse value into tokens:\r\n\t\t\tvar unfiltred_value = cssSyntax.parseCSSValue(cssText);\r\n\t\t\tvar value = unfiltred_value.filter(function(o) { return !(o instanceof cssSyntax.WhitespaceToken); });\r\n\t\t\tvalue.toCSSString = function() { return unfiltred_value.toCSSString(); }\r\n\t\t\t\r\n\t\t\t// parse tokens into data:\r\n\t\t\tvar I = 0;\r\n\t\t\tvar buggy = false;\r\n\t\t\tvar regexp = /^([-_a-zA-Z0-9]+|\\.)\\s*/;\r\n\t\t\tvar grid = [], areas = Object.create(null);\r\n\t\t\twhile(value[I]) {\r\n\t\t\t\t\r\n\t\t\t\tvar str = ''+value[I++].value;\r\n\t\t\t\t\r\n\t\t\t\tvar columns = [];\r\n\t\t\t\twhile(str!=='') {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// extract next token\r\n\t\t\t\t\tvar data = regexp.exec(str); if(!data || data.length != 2) { return buggy=true; }\r\n\t\t\t\t\tstr = str.substr(data[0].length); var cell = data[1];\r\n\t\t\t\t\t\r\n\t\t\t\t\t// update cell max pos (ignore empty cells)\r\n\t\t\t\t\tif(cell!='.') {\r\n\t\t\t\t\t\tif(!areas[cell]) { areas[cell] = { xStart:columns.length, xEnd:columns.length+1, yStart: I-1, yEnd: I }; }\r\n\t\t\t\t\t\tif(areas[cell].xStart > columns.length) { return buggy=true; } \r\n\t\t\t\t\t\tif(areas[cell].yStart > I-1) { return buggy=true; }\r\n\t\t\t\t\t\tareas[cell].xEnd = Math.max(areas[cell].xEnd, columns.length+1);\r\n\t\t\t\t\t\tareas[cell].yEnd = Math.max(areas[cell].yEnd, I);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// add the cell to this row\r\n\t\t\t\t\tcolumns.push(data[1]);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tgrid.push(columns);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// validate areas\r\n\t\t\tfor(var a in areas) {\r\n\t\t\t\tvar area = areas[a];\r\n\t\t\t\tfor(var y = area.yStart; y<area.yEnd; y++) {\r\n\t\t\t\t\tfor(var x = area.xStart; x<area.xEnd; x++) {\r\n\t\t\t\t\t\tif(grid[y][x] != a) { return buggy=true; }\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// add autogenerated line names\r\n\t\t\tfor(var a in areas) {\r\n\t\t\t\tvar area = areas[a];\r\n\t\t\t\t\r\n\t\t\t\t// make sure we have enough y lines for the areas to fit:\r\n\t\t\t\twhile(this.specifiedYLines.length<=area.yEnd) {\r\n\t\t\t\t\tthis.specifiedYLines.push([]);\r\n\t\t\t\t\tthis.specifiedYSizes.push(this.defaultYSize);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// add the y line name\r\n\t\t\t\tthis.specifiedYLines[area.yStart].push(a+\"-start\");\r\n\t\t\t\tthis.specifiedYLines[area.yEnd].push(a+\"-end\");\r\n\t\t\t\t\r\n\t\t\t\t// make sure we have enough x lines for the areas to fit:\r\n\t\t\t\twhile(this.specifiedXLines.length<=area.xEnd) {\r\n\t\t\t\t\tthis.specifiedXLines.push([]);\r\n\t\t\t\t\tthis.specifiedXSizes.push(this.defaultXSize);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// add the x line name\r\n\t\t\t\tthis.specifiedXLines[area.xStart].push(a+\"-start\");\r\n\t\t\t\tthis.specifiedXLines[area.xEnd].push(a+\"-end\");\r\n\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\t},\r\n\t\t\r\n\t\tparseTrackDefinitions: function(lineNames, trackBreadths, cssText) {\r\n\t\t\t\r\n\t\t\t// replace the repeat() function by its full representation\r\n\t\t\tcssText = cssText.replace(/repeat\\(\\s*([0-9]+)\\s*\\,((?:\\([^()]*\\)|[^()])+)\\)/gi, function(s, n, v) {\r\n\t\t\t\tvar result = ' ';\r\n\t\t\t\tfor(var i = parseInt(n); i--;) { \r\n\t\t\t\t\tresult += v + ' ';\r\n\t\t\t\t}\r\n\t\t\t\treturn result;\r\n\t\t\t});\r\n\t\t\t'TODO: improve the repeat support';\r\n\t\t\t\r\n\t\t\t// merge duplicate name-definitions\r\n\t\t\tcssText = cssText.replace(/\\)\\s*\\(/g, ' ');\r\n\t\t\t'TODO: improve the duplicate name-definitions support';\r\n\t\t\t\r\n\t\t\t// parse value into tokens:\r\n\t\t\tvar unfiltred_value = cssSyntax.parseCSSValue(cssText);\r\n\t\t\tvar value = unfiltred_value.filter(function(o) { return !(o instanceof cssSyntax.WhitespaceToken); });\r\n\t\t\tvalue.toCSSString = function() { return unfiltred_value.toCSSString(); }\r\n\t\t\t\r\n\t\t\t// parse tokens into data:\r\n\t\t\tvar I = 0;\r\n\t\t\tvar buggy = false;\r\n\t\t\t\r\n\t\t\tvar parseLineNames = function() {\r\n\t\t\t\t\r\n\t\t\t\tvar currentLineNames = []; // array of string\r\n\t\t\t\t\r\n\t\t\t\tif(value[I] instanceof cssSyntax.SimpleBlock && value[I].name == \"(\") {\r\n\t\t\t\t\tvar tokens = value[I].value;\r\n\t\t\t\t\tfor(var J=tokens.length; J--;) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (tokens[J] instanceof cssSyntax.IdentifierToken) {\r\n\t\t\t\t\t\t\tcurrentLineNames.push(tokens[J].value);\r\n\t\t\t\t\t\t} else if (tokens[J] instanceof cssSyntax.WhitespaceToken) {\r\n\t\t\t\t\t\t\t// ignore\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// unrecognized token, so the declaration is invalid:\r\n\t\t\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-template-rows/columns: \"+value.toCSSString()+\" (unrecognized line name)\");\r\n\t\t\t\t\t\t\tbuggy = true;\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tI++;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tlineNames.push(currentLineNames); \r\n\t\t\t\tcurrentLineNames = [];\r\n\t\t\t\t\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tvar parseTrackBreadth = function() {\r\n\t\t\t\t\r\n\t\t\t\tvar data = this.parseTrackBreadth(value, I);\r\n\t\t\t\ttrackBreadths.push(data.result);\r\n\t\t\t\tI = data.I;\r\n\t\t\t\t\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tparseLineNames(); \r\n\t\t\twhile(value[I]) {\r\n\t\t\t\tparseTrackBreadth.call(this); if(buggy) { break; }\r\n\t\t\t\tparseLineNames(); if(buggy) { break; }\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tparseColumnsTemplate: function(cssText) {\r\n\t\t\treturn this.parseTrackDefinitions(this.specifiedXLines, this.specifiedXSizes, cssText);\r\n\t\t},\r\n\t\t\r\n\t\tparseRowsTemplate: function(cssText) {\r\n\t\t\treturn this.parseTrackDefinitions(this.specifiedYLines, this.specifiedYSizes, cssText);\r\n\t\t},\r\n\t\t\r\n\t\tparseTracksTemplate: function(columnsTemplate, rowsTemplate, areasTemplate) {\r\n\t\t\tif(rowsTemplate   ) this.parseRowsTemplate(rowsTemplate);\r\n\t\t\tif(columnsTemplate) this.parseColumnsTemplate(columnsTemplate);\r\n\t\t\tif(areasTemplate  ) this.parseAreasTemplate(areasTemplate);\r\n\t\t},\r\n\t\t\r\n\t\tbuildExplicitMatrix: function() {\r\n\t\t\t\r\n\t\t\t// reset\r\n\t\t\tthis.resetLinesToSpecified();\r\n\t\t\tthis.rcMatrix = [];\r\n\t\t\t\r\n\t\t\t// simple autogrow\r\n\t\t\tif(this.growY) {\r\n\t\t\t\tthis.ensureRows(this.ySizes.length);\r\n\t\t\t\tthis.ensureColumns(this.xSizes.length);\r\n\t\t\t} else {\r\n\t\t\t\tthis.ensureColumns(this.xSizes.length);\r\n\t\t\t\tthis.ensureRows(this.ySizes.length);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}, \r\n\t\t\r\n\t\tbuildImplicitMatrix: function() { /* see http://dev.w3.org/csswg/css-grid/#auto-placement-algo */\r\n\t\t\r\n\t\t\t// start by building the explicit matrix\r\n\t\t\tthis.buildExplicitMatrix();\r\n\t\t\t\r\n\t\t\t// [1] position non-auto items\r\n\t\t\tthis.positionNonAutoItems();\r\n\t\t\t\r\n\t\t\t// [2] position auto-in-column-only items\r\n\t\t\tthis.positionAutoInColumnOnlyItems();\r\n\t\t\t\r\n\t\t\t// [3] make room for implicit tracks\r\n\t\t\tthis.autoGrow();\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tensureRows: function(yEnd) {\r\n\t\t\t\r\n\t\t\tif(this.growY) {\r\n\t\t\t\t\r\n\t\t\t\t// add rows as necessary\r\n\t\t\t\twhile(this.ySizes.length<yEnd) {\r\n\t\t\t\t\tthis.ySizes.push(this.defaultYSize);\r\n\t\t\t\t}\r\n\t\t\t\twhile(this.rcMatrix.length<yEnd) {\r\n\t\t\t\t\tthis.rcMatrix.push([]);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// add rows as necessary\r\n\t\t\t\twhile(this.ySizes.length<yEnd) {\r\n\t\t\t\t\tthis.ySizes.push(this.defaultYSize);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// walk through columns\r\n\t\t\t\tfor(var x = this.rcMatrix.length; x--;) {\r\n\t\t\t\t\r\n\t\t\t\t\t// add rows as necessary\r\n\t\t\t\t\tif(this.rcMatrix[x].length < yEnd) {\r\n\t\t\t\t\t\tthis.rcMatrix[x].length = yEnd;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tensureColumns: function(xEnd) {\r\n\t\t\t\r\n\t\t\tif(this.growY) {\r\n\t\t\t\r\n\t\t\t\t// add columns as necessary\r\n\t\t\t\twhile(this.xSizes.length<xEnd) {\r\n\t\t\t\t\tthis.xSizes.push(this.defaultXSize);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// walk through rows\r\n\t\t\t\tfor(var y = this.rcMatrix.length; y--;) {\r\n\t\t\t\t\r\n\t\t\t\t\t// add columns as necessary\r\n\t\t\t\t\tif(this.rcMatrix[y].length < xEnd) {\r\n\t\t\t\t\t\tthis.rcMatrix[y].length = xEnd;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// add columns as necessary\r\n\t\t\t\twhile(this.xSizes.length<xEnd) {\r\n\t\t\t\t\tthis.xSizes.push(this.defaultXSize);\r\n\t\t\t\t}\r\n\t\t\t\twhile(this.rcMatrix.length<xEnd) {\r\n\t\t\t\t\tthis.rcMatrix.push([]);\r\n\t\t\t\t}\r\n\t\t\t\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\tmarkAsOccupied: function(item) {\r\n\t\t\t\r\n\t\t\tvar xStart = item.xStart;\r\n\t\t\tvar yStart = item.yStart;\r\n\t\t\tvar xEnd = item.xEnd;\r\n\t\t\tvar yEnd = item.yEnd;\r\n\t\t\r\n\t\t\t// let's check the rcMatrix mode we're in:\r\n\t\t\tif(this.growY) {\r\n\t\t\t\t\r\n\t\t\t\t// add rows as necessary\r\n\t\t\t\tthis.ensureRows(yEnd);\r\n\t\t\t\t\r\n\t\t\t\t// walk through rows\r\n\t\t\t\tfor(var y = yStart; y<yEnd; y++) {\r\n\t\t\t\t\r\n\t\t\t\t\t// add columns as necessary\r\n\t\t\t\t\tif(this.rcMatrix[y].length < xEnd-1) {\r\n\t\t\t\t\t\tthis.rcMatrix[y].length = xEnd-1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// walk through columns\r\n\t\t\t\t\tfor(var x = xStart; x<xEnd; x++) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// the cell is occupied\r\n\t\t\t\t\t\tthis.rcMatrix[y][x] = item;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// add columns as necessary\r\n\t\t\t\tthis.ensureColumns(xEnd);\r\n\t\t\t\t\r\n\t\t\t\t// walk through rows\r\n\t\t\t\tfor(var x = xStart; x<xEnd; x++) {\r\n\t\t\t\t\r\n\t\t\t\t\t// add rows as necessary\r\n\t\t\t\t\tif(this.rcMatrix[x].length < yEnd-1) {\r\n\t\t\t\t\t\tthis.rcMatrix[x].length = yEnd-1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// walk through rows\r\n\t\t\t\t\tfor(var y = yStart; y<yEnd; y++) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// the cell is occupied\r\n\t\t\t\t\t\tthis.rcMatrix[x][y] = item;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\t},\r\n\t\t\r\n\t\tpositionNonAutoItems: function() {\r\n\t\t\t\r\n\t\t\tfor(var i=0, l=this.items.length; i<l; i++) {\r\n\t\t\t\tvar item = this.items[i];\r\n\t\t\t\t\r\n\t\t\t\t// if the element has a specific column associated to it\r\n\t\t\t\tif(item.specifiedXStart.type == LOCATE_LINE) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if the element has a specified row associated to it\r\n\t\t\t\t\tif(item.specifiedYStart.type == LOCATE_LINE) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find the start position (x axis)\r\n\t\t\t\t\t\tvar xStart = this.findXStart(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find the start position (y axis)\r\n\t\t\t\t\t\tvar yStart = this.findYStart(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find the end position (x axis)\r\n\t\t\t\t\t\tvar xEnd = this.findXEnd(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find the end position (y axis)\r\n\t\t\t\t\t\tvar yEnd = this.findYEnd(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// we're done! this is so cool dude!\r\n\t\t\t\t\t\titem.xStart = xStart;\r\n\t\t\t\t\t\titem.yStart = yStart;\r\n\t\t\t\t\t\titem.xEnd = xEnd;\r\n\t\t\t\t\t\titem.yEnd = yEnd;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// we should fill the explicit matrix now!\r\n\t\t\t\t\t\tthis.markAsOccupied(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tpositionAutoInColumnOnlyItems: function() {\r\n\t\t\t\r\n\t\t\tif(this.growY) {\r\n\t\t\t\t\r\n\t\t\t\tfor(var i=0, l=this.items.length; i<l; i++) {\r\n\t\t\t\t\tvar item = this.items[i];\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if the element has a specified row associated to it, but is not positioned yet\r\n\t\t\t\t\tif(item.specifiedYStart.type == LOCATE_LINE && (item.yStart==-1)) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find the start position (y axis)\r\n\t\t\t\t\t\tvar yStart = this.findYStart(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find the end position (y axis)\r\n\t\t\t\t\t\tvar yEnd = this.findYEnd(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// assumption: X is either AUTO + SPAN or AUTO + AUTO\r\n\t\t\t\t\t\tvar spanX = 1;\r\n\t\t\t\t\t\tif(item.specifiedXEnd.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\t\tif(item.specifiedXEnd.name === undefined) {\r\n\t\t\t\t\t\t\t\t// The span is defined as this value\r\n\t\t\t\t\t\t\t\tspanX = item.specifiedXEnd.index;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\r\n\t\t\t\t\t\t\t\tspanX = 1; console.error('[CSS-GRID] UNSUPPORTED: grid-row/column: auto / span [0-9]+ [A-Z]+');\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// add rows as necessary\r\n\t\t\t\t\t\tthis.ensureRows(yEnd);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// walk through columns to find a suitable position\r\n\t\t\t\t\t\tIncrementalColumnAttempts: for(var sx = 0;;sx++) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tfor(var x = sx+spanX-1; x>=sx; x--) {\r\n\t\t\t\t\t\t\t\tfor(var y = yStart; y<yEnd; y++) {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// if the cell is occupied\r\n\t\t\t\t\t\t\t\t\tif(this.rcMatrix[y][x]) {\r\n\t\t\t\t\t\t\t\t\t\tcontinue IncrementalColumnAttempts;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar xStart = sx;\r\n\t\t\t\t\t\tvar xEnd = sx+spanX;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// we're done! this is so cool dude!\r\n\t\t\t\t\t\titem.xStart = xStart;\r\n\t\t\t\t\t\titem.yStart = yStart;\r\n\t\t\t\t\t\titem.xEnd = xEnd;\r\n\t\t\t\t\t\titem.yEnd = yEnd;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// we should fill the explicit matrix now!\r\n\t\t\t\t\t\tthis.markAsOccupied(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\tfor(var i=0, l=this.items.length; i<l; i++) {\r\n\t\t\t\t\tvar item = this.items[i];\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if the element has a specified column associated to it, but is not positioned yet\r\n\t\t\t\t\tif(item.specifiedXStart.type == LOCATE_LINE && (item.xStart==-1)) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find the start position (x axis)\r\n\t\t\t\t\t\tvar xStart = this.findXStart(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find the end position (x axis)\r\n\t\t\t\t\t\tvar xEnd = this.findXEnd(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// assumption: Y is either AUTO + SPAN or AUTO + AUTO\r\n\t\t\t\t\t\tvar spanY = 1;\r\n\t\t\t\t\t\tif(item.specifiedYEnd.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\t\tif(item.specifiedYEnd.name === undefined) {\r\n\t\t\t\t\t\t\t\t// The span is defined as this value\r\n\t\t\t\t\t\t\t\tspanY = item.specifiedYEnd.index;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\r\n\t\t\t\t\t\t\t\tspanY = 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// add rows as necessary\r\n\t\t\t\t\t\tthis.ensureColumns(xEnd);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// walk through columns to find a suitable position\r\n\t\t\t\t\t\tIncrementalRowAttempts: for(var sy = 0;;sy++) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tfor(var y = sy+spanY-1; y>=sy; y--) {\r\n\t\t\t\t\t\t\t\tfor(var x = xStart; x<xEnd; x++) {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// if the cell is occupied\r\n\t\t\t\t\t\t\t\t\tif(this.rcMatrix[x][y]) {\r\n\t\t\t\t\t\t\t\t\t\tcontinue IncrementalRowAttempts;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar yStart = sy;\r\n\t\t\t\t\t\tvar yEnd = sy+spanY;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// we're done! this is so cool dude!\r\n\t\t\t\t\t\titem.xStart = xStart;\r\n\t\t\t\t\t\titem.yStart = yStart;\r\n\t\t\t\t\t\titem.xEnd = xEnd;\r\n\t\t\t\t\t\titem.yEnd = yEnd;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// we should fill the explicit matrix now!\r\n\t\t\t\t\t\tthis.markAsOccupied(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\t\r\n\t\tautoGrow: function() {\r\n\t\t\t\r\n\t\t\t// helpers\r\n\t\t\tvar growX = function(index) {\r\n\t\t\t\twhile(index >= this.xLines.length) {\r\n\t\t\t\t\tthis.xLines.push(['*']);\r\n\t\t\t\t\tthis.xSizes.push(this.defaultXSize);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar growY = function(index) {\r\n\t\t\t\twhile(index >= this.yLines.length) {\r\n\t\t\t\t\tthis.yLines.push(['*']);\r\n\t\t\t\t\tthis.ySizes.push(this.defaultYSize);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// reset the lines to the specified ones if necessary\r\n\t\t\tthis.resetLinesToSpecified(); // TODO: why?\r\n\t\t\t\r\n\t\t\t// ensure there's at least one cell\r\n\t\t\tgrowX.call(this,1); growY.call(this,1);\r\n\t\t\t\r\n\t\t\t// check if an item is explicitly positioned outside the explicit grid, and expand it if needed\r\n\t\t\tfor(var i = this.items.length; i--;) {\r\n\t\t\t\t\r\n\t\t\t\tvar item = this.items[i];\r\n\t\t\t\t\r\n\t\t\t\t// CONSIDER: items already positioned\r\n\t\t\t\tif(item.xEnd > 0) { growX.call(this,item.xEnd); }\r\n\t\t\t\tif(item.yEnd > 0) { growY.call(this,item.yEnd); }\r\n\t\t\t\tif(item.xEnd > 0 && item.yEnd > 0) { continue; }\r\n\t\t\t\t\r\n\t\t\t\t// CONSIDER: elements with a known location\r\n\t\t\t\t\r\n\t\t\t\t// (x axis):\r\n\t\t\t\tif(item.specifiedXEnd.type == LOCATE_LINE || item.specifiedXStart.type == LOCATE_LINE) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar xStart = this.findXStart(item);\r\n\t\t\t\t\tvar xEnd = this.findXEnd(item);\r\n\t\t\t\t\tgrowX.call(this,xEnd);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// (y axis):\r\n\t\t\t\tif(item.specifiedYEnd.type == LOCATE_LINE || item.specifiedYStart.type == LOCATE_LINE) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar yStart = this.findYStart(item);\r\n\t\t\t\t\tvar yEnd = this.findYEnd(item);\r\n\t\t\t\t\tif(yEnd <= yStart) { yEnd = yStart+1; }\r\n\t\t\t\t\tgrowY.call(this,yEnd);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// CONSIDER: known spans\r\n\t\t\t\t// // NOTE: I don't support \"grid-row/column-start: span X\";\r\n\t\t\t\tif(item.specifiedXEnd.type == LOCATE_SPAN && item.specifiedXEnd.name===undefined) {\r\n\t\t\t\t\tgrowX.call(this,item.specifiedXEnd.index);\r\n\t\t\t\t}\r\n\t\t\t\tif(item.specifiedYEnd.type == LOCATE_SPAN && item.specifiedYEnd.name===undefined) {\r\n\t\t\t\t\tgrowY.call(this,item.specifiedYEnd.index);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// grow the grid matrix:\r\n\t\t\tif(this.growY) {\r\n\t\t\t\twhile(this.ySizes.length>this.rcMatrix.length) {\r\n\t\t\t\t\tthis.rcMatrix.push([]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(var r=this.rcMatrix.length; r--;) {\r\n\t\t\t\t\tthis.rcMatrix[r].length = this.xSizes.length;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\twhile(this.xSizes.length>this.rcMatrix.length) {\r\n\t\t\t\t\tthis.rcMatrix.push([]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(var r=this.rcMatrix.length; r--;) {\r\n\t\t\t\t\tthis.rcMatrix[r].length = this.ySizes.length;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tscheduleRelayout: function() {\r\n\t\t\tvar This = this;\r\n\t\t\tif(!This.isLayoutScheduled) {\r\n\t\t\t\tThis.isLayoutScheduled = true;\r\n\t\t\t\trequestAnimationFrame(function() {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tThis.revokePolyfilledStyle();\r\n\t\t\t\t\t\tThis.updateFromElement();\r\n\t\t\t\t\t\tThis.performLayout();\r\n\t\t\t\t\t\tThis.generatePolyfilledStyle();\r\n\t\t\t\t\t} finally {\r\n\t\t\t\t\t\tThis.isLayoutScheduled = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\tperformLayout: function() {\r\n\t\t\r\n\t\t\t// process non-automatic items\r\n\t\t\tthis.buildImplicitMatrix();\r\n\r\n\t\t\t// position the remaining grid items. \r\n\t\t\tvar cursor = { x: 0, y: 0 };\r\n\r\n\t\t\tif(this.growY) {\r\n\t\t\t\t\r\n\t\t\t\t//For each grid item that hasnt been positioned by the previous steps, in order-modified document order:\r\n\t\t\t\tfor(var i=0; i<this.items.length; i++) {\r\n\t\t\t\t\tvar item = this.items[i]; if(item.xEnd!=-1 && item.yEnd!=-1) { continue; }\r\n\t\t\t\t\t\r\n\t\t\t\t\t// reset the cursor if the algorithm is set to 'dense'\r\n\t\t\t\t\tif(this.growDense) { cursor = { x: 0, y: 0 }; }\r\n\t\t\t\t\t\r\n\t\t\t\t\t//If the item has a definite column position: \r\n\t\t\t\t\tif(item.specifiedXStart.type == LOCATE_LINE) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// 1. Set the column position of the cursor to be equal to the inline-start index of the grid item. \r\n\t\t\t\t\t\tvar xStart = this.findXStart(item); if(cursor.x > xStart) { cursor.y++; } cursor.x = xStart;\r\n\t\t\t\t\t\tvar xEnd = this.findXEnd(item); if(xStart>=xEnd) { xEnd=xStart+1}\r\n\t\t\t\t\t\titem.xStart=xStart; item.xEnd=xEnd;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// assumption: Y is either AUTO + SPAN or AUTO + AUTO\r\n\t\t\t\t\t\tvar spanY = 1;\r\n\t\t\t\t\t\tif(item.specifiedYEnd.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\t\tif(item.specifiedYEnd.name === undefined) {\r\n\t\t\t\t\t\t\t\t// The span is defined as this value\r\n\t\t\t\t\t\t\t\tspanY = item.specifiedYEnd.index;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\r\n\t\t\t\t\t\t\t\tspanY = 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// 2. Increment the auto-placement cursors row position until a value is found where the grid item does not overlap any occupied grid cells (creating new rows in the implicit grid as necessary).\r\n\t\t\t\t\t\tIncrementalRowAttempts: while(true) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// make room for the currently attempted position\r\n\t\t\t\t\t\t\tthis.ensureRows(cursor.y+spanY);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// check the non-overlap condition\r\n\t\t\t\t\t\t\tfor(var y = cursor.y+spanY-1; y>=cursor.y; y--) {\r\n\t\t\t\t\t\t\t\tfor(var x = xStart; x<xEnd; x++) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// if the cell is occupied\r\n\t\t\t\t\t\t\t\t\tif(this.rcMatrix[y][x]) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// move to the next row\r\n\t\t\t\t\t\t\t\t\t\tcursor.y=y+1; continue IncrementalRowAttempts;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// settle the position\r\n\t\t\t\t\t\titem.xStart = xStart;\r\n\t\t\t\t\t\titem.xEnd = xEnd;\r\n\t\t\t\t\t\titem.yStart = cursor.y;\r\n\t\t\t\t\t\titem.yEnd = cursor.y+spanY;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tthis.markAsOccupied(item);\t\t\t\t\t\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else { // If the item has an automatic grid position in both axes: \r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// assumption: X is either AUTO + SPAN or AUTO + AUTO\r\n\t\t\t\t\t\tvar spanX = 1;\r\n\t\t\t\t\t\tif(item.specifiedXEnd.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\t\tif(item.specifiedXEnd.name === undefined) {\r\n\t\t\t\t\t\t\t\t// The span is defined as this value\r\n\t\t\t\t\t\t\t\tspanX = item.specifiedXEnd.index;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\r\n\t\t\t\t\t\t\t\tspanX = 1; console.error('[CSS-GRID] UNSUPPORTED: grid-row/column: auto / span [0-9]+ [A-Z]+');\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// assumption: Y is either AUTO + SPAN or AUTO + AUTO\r\n\t\t\t\t\t\tvar spanY = 1;\r\n\t\t\t\t\t\tif(item.specifiedYEnd.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\t\tif(item.specifiedYEnd.name === undefined) {\r\n\t\t\t\t\t\t\t\t// The span is defined as this value\r\n\t\t\t\t\t\t\t\tspanY = item.specifiedYEnd.index;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\r\n\t\t\t\t\t\t\t\tspanY = 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Increment the auto-placement cursors row/column position (creating new rows in the implicit grid as necessary)\r\n\t\t\t\t\t\tvar nextStep = function() {\r\n\t\t\t\t\t\t\tcursor.x++; if(cursor.x+spanX>this.rcMatrix[0].length) { cursor.y++; this.ensureRows(cursor.y + spanY); cursor.x=0; }\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// 1. Increment the column position of the auto-placement cursor until this items grid area does not overlap any occupied grid cells\r\n\t\t\t\t\t\tIncrementalYXPositionAttempts: while(true) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// make room for the currently attempted position\r\n\t\t\t\t\t\t\tthis.ensureRows(cursor.y+spanY);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// check the non-overlap condition\r\n\t\t\t\t\t\t\tfor(var y = cursor.y+spanY-1; y>=cursor.y; y--) {\r\n\t\t\t\t\t\t\t\tfor(var x = cursor.x+spanX-1; x>=cursor.x; x--) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// if the cell is occupied\r\n\t\t\t\t\t\t\t\t\tif(this.rcMatrix[y][x]) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// move to the next row/column\r\n\t\t\t\t\t\t\t\t\t\tnextStep.call(this); continue IncrementalYXPositionAttempts;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// settle the position\r\n\t\t\t\t\t\titem.xStart = cursor.x;\r\n\t\t\t\t\t\titem.xEnd = cursor.x+spanX;\r\n\t\t\t\t\t\titem.yStart = cursor.y;\r\n\t\t\t\t\t\titem.yEnd = cursor.y+spanY;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tthis.markAsOccupied(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t//For each grid item that hasnt been positioned by the previous steps, in order-modified document order:\r\n\t\t\t\tfor(var i=0; i<this.items.length; i++) {\r\n\t\t\t\t\tvar item = this.items[i]; if(item.xEnd!=-1 && item.yEnd!=-1) { continue; }\r\n\t\t\t\t\t\r\n\t\t\t\t\t// reset the cursor if the algorithm is set to 'dense'\r\n\t\t\t\t\tif(this.growDense) { cursor = { x: 0, y: 0 }; }\r\n\t\t\t\t\t\r\n\t\t\t\t\t//If the item has a definite row position: \r\n\t\t\t\t\tif(item.specifiedYStart.type == LOCATE_LINE) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// 1. Set the column position of the cursor to be equal to the inline-start index of the grid item. \r\n\t\t\t\t\t\tvar yStart = this.findYStart(item); if(cursor.y > yStart) { cursor.x++; } cursor.y = yStart;\r\n\t\t\t\t\t\tvar yEnd = this.findYEnd(item); if(yStart>=yEnd) { yEnd=yStart+1}\r\n\t\t\t\t\t\titem.yStart=yStart; item.yEnd=yEnd;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// assumption: X is either AUTO + SPAN or AUTO + AUTO\r\n\t\t\t\t\t\tvar spanX = 1;\r\n\t\t\t\t\t\tif(item.specifiedXEnd.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\t\tif(item.specifiedXEnd.name === undefined) {\r\n\t\t\t\t\t\t\t\t// The span is defined as this value\r\n\t\t\t\t\t\t\t\tspanX = item.specifiedXEnd.index;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\r\n\t\t\t\t\t\t\t\tspanX = 1; console.error('[CSS-GRID] UNSUPPORTED: grid-row/column: auto / span [0-9]+ [A-Z]+');\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// 2. Increment the auto-placement cursors row position until a value is found where the grid item does not overlap any occupied grid cells (creating new rows in the implicit grid as necessary).\r\n\t\t\t\t\t\tIncrementalColumnAttempts: while(true) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// make room for the currently attempted position\r\n\t\t\t\t\t\t\tthis.ensureColumns(cursor.x+spanX);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// check the non-overlap condition\r\n\t\t\t\t\t\t\tfor(var x = cursor.x+spanX-1; x>=cursor.x; x--) {\r\n\t\t\t\t\t\t\t\tfor(var y = yStart; y<yEnd; y++) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// if the cell is occupied\r\n\t\t\t\t\t\t\t\t\tif(this.rcMatrix[x][y]) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// move to the next row\r\n\t\t\t\t\t\t\t\t\t\tcursor.x=x+1; continue IncrementalColumnAttempts;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// settle the position\r\n\t\t\t\t\t\titem.yStart = yStart;\r\n\t\t\t\t\t\titem.yEnd = yEnd;\r\n\t\t\t\t\t\titem.xStart = cursor.x;\r\n\t\t\t\t\t\titem.yEnd = cursor.x+spanX;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tthis.markAsOccupied(item);\t\t\t\t\t\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else { // If the item has an automatic grid position in both axes: \r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// assumption: Y is either AUTO + SPAN or AUTO + AUTO\r\n\t\t\t\t\t\tvar spanY = 1;\r\n\t\t\t\t\t\tif(item.specifiedYEnd.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\t\tif(item.specifiedYEnd.name === undefined) {\r\n\t\t\t\t\t\t\t\t// The span is defined as this value\r\n\t\t\t\t\t\t\t\tspanY = item.specifiedYEnd.index;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\r\n\t\t\t\t\t\t\t\tspanY = 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// assumption: X is either AUTO + SPAN or AUTO + AUTO\r\n\t\t\t\t\t\tvar spanX = 1;\r\n\t\t\t\t\t\tif(item.specifiedXEnd.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\t\tif(item.specifiedXEnd.name === undefined) {\r\n\t\t\t\t\t\t\t\t// The span is defined as this value\r\n\t\t\t\t\t\t\t\tspanX = item.specifiedXEnd.index;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\r\n\t\t\t\t\t\t\t\tspanX = 1; console.error('[CSS-GRID] UNSUPPORTED: grid-row/column: auto / span [0-9]+ [A-Z]+');\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Increment the auto-placement cursors row/column position (creating new rows in the implicit grid as necessary)\r\n\t\t\t\t\t\tvar nextStep = function() {\r\n\t\t\t\t\t\t\tcursor.y++; if(cursor.y+spanY>this.rcMatrix[0].length) { cursor.x++; this.ensureRows(cursor.x + spanX); cursor.y=0; }\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// 1. Increment the column position of the auto-placement cursor until this items grid area does not overlap any occupied grid cells\r\n\t\t\t\t\t\tIncrementalXYPositionAttempts: while(true) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// make room for the currently attempted position\r\n\t\t\t\t\t\t\tthis.ensureColumns(cursor.x+spanX);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// check the non-overlap condition\r\n\t\t\t\t\t\t\tfor(var x = cursor.x+spanX-1; x>=cursor.x; x--) {\r\n\t\t\t\t\t\t\t\tfor(var y = cursor.y+spanY-1; y>=cursor.y; y--) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// if the cell is occupied\r\n\t\t\t\t\t\t\t\t\tif(this.rcMatrix[x][y]) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// move to the next row/column\r\n\t\t\t\t\t\t\t\t\t\tnextStep.call(this); continue IncrementalXYPositionAttempts;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// settle the position\r\n\t\t\t\t\t\titem.xStart = cursor.x;\r\n\t\t\t\t\t\titem.xEnd = cursor.x+spanX;\r\n\t\t\t\t\t\titem.yStart = cursor.y;\r\n\t\t\t\t\t\titem.yEnd = cursor.y+spanY;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tthis.markAsOccupied(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\tthis.computeAbsoluteTrackBreadths();\r\n\r\n\t\t\t\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tcomputeAbsoluteTrackBreadths: function() {\r\n\t\t\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t// hide child elements, to get free width/height\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\tvar runtimeStyle = createRuntimeStyle('no-children', this.element);\r\n\t\t\truntimeStyle.set(this.element, {\r\n\t\t\t\t\"border\"       : \"none\",\r\n\t\t\t\t\"padding\"      : \"0px\",\r\n\t\t\t\t\"min-height\"   : \"0px\",\r\n\t\t\t});\r\n\t\t\tfor(var i = this.items.length; i--;) {\r\n\t\t\t\truntimeStyle.set(this.items[i],{\"display\":\"none\"});\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t// hide child elements, to get free width/height\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\tvar LIMIT_IS_INFINITE = 1;\t\t\r\n\t\t\tvar infinity = 9999999.0;\r\n\t\t\tvar fullWidth = this.element.offsetWidth;\r\n\t\t\tvar fullHeight = this.element.offsetHeight;\r\n\t\t\t\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t// show child elements again\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\truntimeStyle.revoke();\r\n\t\t\t\r\n\t\t\t// \r\n\t\t\t// 10.3  Initialize Track Sizes\r\n\t\t\t// \r\n\t\t\tvar initializeFromConstraints = function(v) {\r\n\t\t\t\t\r\n\t\t\t\tvar base = 0, limit = infinity;\r\n\t\t\t\tswitch(v.minType) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// For fixed track sizes, resolve to an absolute length and use that size. \r\n\t\t\t\t\tcase TRACK_BREADTH_LENGTH:      base = v.minValue; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_PERCENTAGE:  base = v.minValue*fullSize/100; break;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tswitch(v.maxType) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// For fixed track sizes, resolve to an absolute length and use that size. \r\n\t\t\t\t\tcase TRACK_BREADTH_LENGTH:      limit = v.minValue; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_PERCENTAGE:  limit = v.minValue*fullSize/100; break;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// For flexible track sizes, use the tracks initial base size as its initial growth limit.  \r\n\t\t\t\t\tcase TRACK_BREADTH_FRACTION:    limit = base; break;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// For intrinsic track sizes, use an initial growth limit of infinity. \r\n\t\t\t\t\tdefault:                        limit = infinity; break;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn { base:base, limit:limit, breadth:0, flags:((limit==infinity)?LIMIT_IS_INFINITE:0)|0 };\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// Equal distribution algorithm\r\n\t\t\t//\r\n\t\t\tvar distributeEquallyAmongTracks = function distributeEquallyAmongTracks(xSizes, kind, tracks, spaceToDistribute, enforceLimit) {\r\n\t\t\t\t// Distribute space to base sizes\r\n\t\t\t\tvar trackAmount = tracks.length;\r\n\t\t\t\tvar spacePerTrack = spaceToDistribute/trackAmount;\r\n\t\t\t\tif(kind=='base') {\r\n\t\t\t\t\r\n\t\t\t\t\t// if we enforce the limit, grow up to the most limitating track\r\n\t\t\t\t\tif(enforceLimit) {\r\n\t\t\t\t\t\tfor(var t = tracks.length; t--;) { var cx = tracks[t].x;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// find the lowest acceptable increase for all tracks\r\n\t\t\t\t\t\t\tvar newBase = xSizes[cx].base + spacePerTrack;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// if limits are enfo\r\n\t\t\t\t\t\t\tif(enforceLimit && (xSizes[cx].flags & LIMIT_IS_INFINITE == 0) && newBase > xSizes[cx].limit) {\r\n\t\t\t\t\t\t\t\tspacePerTrack -= newBase - xSizes[cx].limit;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tfor(var t = tracks.length; t--;) { var cx = tracks[t].x;\r\n\t\t\t\t\t\txSizes[cx].base += spacePerTrack;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(kind == 'limit') {\r\n\t\t\t\t\r\n\t\t\t\t\t// Update the tracks' affected sizes by folding in the calculated increase so that the next round of space distribution will account for the increase.\r\n\t\t\t\t\tfor(var t = tracks.length; t--;) { var cx = tracks[t].x;\r\n\t\t\t\t\t\t// If the growth limit is infinite...\r\n\t\t\t\t\t\tif(xSizes[cx].flags & LIMIT_IS_INFINITE) {\r\n\t\t\t\t\t\t\t// set it to the tracks base size plus the calculated increase\r\n\t\t\t\t\t\t\tif(xSizes[cx].limit == infinity) {\r\n\t\t\t\t\t\t\t\txSizes[cx].limit = xSizes[cx].base + spacePerTrack;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\txSizes[cx].limit += spacePerTrack; // TODO: THERE IS A BUG HERE ?\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// otherwise just increase the limit\r\n\t\t\t\t\t\t\txSizes[cx].limit += spacePerTrack;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t\r\n\t\t\t// \r\n\t\t\t// 10.4  Resolve Content-Based Track Sizing Functions\r\n\t\t\t// \r\n\t\t\tvar computeTrackBreadth = function(xSizes, specifiedSizes, getMinWidthOf, getMaxWidthOf, getXStartOf, getXEndOf) {\r\n\t\t\t\t\r\n\t\t\t\t// For each track\r\n\t\t\t\tvar items_done = 0; // items already consumed for this algorithm\r\n\t\t\t\tfor(var x = specifiedSizes.length; x--;) {\r\n\t\t\t\t\r\n\t\t\t\t\tvar dontCountMaxItems = false;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// If the track has a min-content min track sizing function\r\n\t\t\t\t\tif(specifiedSizes[x].minType == TRACK_BREADTH_MIN_CONTENT || specifiedSizes[x].minType == TRACK_BREADTH_AUTO) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Consider the items in it with a span of 1: \r\n\t\t\t\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i]; var item_xStart = getXStartOf(item); var item_xEnd = getXEndOf(item);\r\n\t\t\t\t\t\t\tif(item_xStart>x || item_xEnd<=x || item_xEnd-item_xStart != 1) continue;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Set its base size to the maximum of the items min-content contributions. \r\n\t\t\t\t\t\t\txSizes[x].base = Math.max(xSizes[x].base, getMinWidthOf(item)); items_done++; dontCountMaxItems=true;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// If the track has a max-content min track sizing function\r\n\t\t\t\t\telse if(specifiedSizes[x].minType == TRACK_BREADTH_MAX_CONTENT) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Consider the items in it with a span of 1: \r\n\t\t\t\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i]; var item_xStart = getXStartOf(item); var item_xEnd = getXEndOf(item);\r\n\t\t\t\t\t\t\tif(item_xStart>x || item_xEnd<=x || item_xEnd-item_xStart != 1) continue;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Set its base size to the maximum of the items max-content contributions. \r\n\t\t\t\t\t\t\txSizes[x].base = Math.max(xSizes[x].base, getMaxWidthOf(item)); items_done++; dontCountMaxItems=true;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// If the track has a min-content max track sizing function\r\n\t\t\t\t\tif(specifiedSizes[x].maxType == TRACK_BREADTH_MIN_CONTENT) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Consider the items in it with a span of 1: \r\n\t\t\t\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i]; var item_xStart = getXStartOf(item); var item_xEnd = getXEndOf(item);\r\n\t\t\t\t\t\t\tif(item_xStart>x || item_xEnd<=x || item_xEnd-item_xStart != 1) continue;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Set its growth limit to the maximum of the items min-content contributions. \r\n\t\t\t\t\t\t\tif(xSizes[x].limit == infinity) { xSizes[x].limit = getMinWidthOf(item); }\r\n\t\t\t\t\t\t\telse { xSizes[x].limit = Math.max(xSizes[x].limit, getMinWidthOf(item)); }\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif(!dontCountMaxItems) { items_done++; }\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} \r\n\t\t\t\t\t\r\n\t\t\t\t\t// If the track has a max-content max track sizing function\r\n\t\t\t\t\telse if(specifiedSizes[x].maxType == TRACK_BREADTH_MAX_CONTENT || specifiedSizes[x].minType == TRACK_BREADTH_AUTO) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Consider the items in it with a span of 1: \r\n\t\t\t\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i]; var item_xStart = getXStartOf(item); var item_xEnd = getXEndOf(item);\r\n\t\t\t\t\t\t\tif(item_xStart>x || item_xEnd<=x || item_xEnd-item_xStart != 1) continue;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Set its growth limit to the maximum of the items max-content contributions. \r\n\t\t\t\t\t\t\tif(xSizes[x].limit == infinity) { xSizes[x].limit = getMaxWidthOf(item); }\r\n\t\t\t\t\t\t\telse { xSizes[x].limit = Math.max(xSizes[x].limit, getMaxWidthOf(item)); }\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif(!dontCountMaxItems) { items_done++; }\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// update infinity flag\r\n\t\t\t\t\tif(xSizes[x].limit != infinity) {\r\n\t\t\t\t\t\txSizes[x].flags = xSizes[x].flags & ~LIMIT_IS_INFINITE;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// Next, consider the items with a span of 2 that do not span a track with a flexible sizing function: \r\n\t\t\t\t// Repeat incrementally for items with greater spans until all items have been considered.\r\n\t\t\t\tfor(var span = 2; items_done < this.items.length && span <= specifiedSizes.length; span++) {\r\n\t\t\t\t\tItemLoop: for(var i = this.items.length; i--;) { var item = this.items[i]; var item_xStart = getXStartOf(item); var item_xEnd = getXEndOf(item);\r\n\t\t\t\t\t\tif(item_xEnd-item_xStart != span) continue ItemLoop;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// gather some pieces of data about the tracks\r\n\t\t\t\t\t\tvar full_base = 0; var full_limit = 0;\r\n\t\t\t\t\t\tfor(var cx = item_xStart; cx<item_xEnd; cx++) { \r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// 1. we want to make sure none is flexible\r\n\t\t\t\t\t\t\tif(specifiedSizes[cx].maxType == TRACK_BREADTH_FRACTION) continue ItemLoop;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// 2. compute aggregated sizes\r\n\t\t\t\t\t\t\tfull_base += xSizes[cx].base;\r\n\t\t\t\t\t\t\tfull_limit += xSizes[cx].limit;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(full_limit > infinity) full_limit=infinity;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar distributeFreeSpace = function(requiredSpace, kind /*'base'|'limit'*/, target /*'min-content'|'max-content'*/) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\twhile (true) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// compute the required extra space\r\n\t\t\t\t\t\t\t\tvar spaceToDistribute = requiredSpace;\r\n\t\t\t\t\t\t\t\tfor(var cx = item_xStart; cx<item_xEnd; cx++) {\r\n\t\t\t\t\t\t\t\t\tspaceToDistribute -= xSizes[cx][kind];\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// if no space to distribute, just lock auto columns:\r\n\t\t\t\t\t\t\t\tif(spaceToDistribute<=0) {\r\n\t\t\t\t\t\t\t\t\tfor(var cx = item_xStart; cx<item_xEnd; cx++) {\r\n\t\t\t\t\t\t\t\t\t\tif(xSizes[cx].limit == infinity) {\r\n\t\t\t\t\t\t\t\t\t\t\txSizes[cx].limit = xSizes[cx].base;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// sort rows by growth limit\r\n\t\t\t\t\t\t\t\tvar rows_and_limits = [];\r\n\t\t\t\t\t\t\t\tfor(var cx = item_xStart; cx<item_xEnd; cx++) {\r\n\t\t\t\t\t\t\t\t\trows_and_limits.push({ \r\n\t\t\t\t\t\t\t\t\t\tx:cx, \r\n\t\t\t\t\t\t\t\t\t\tbase:xSizes[cx].base,\r\n\t\t\t\t\t\t\t\t\t\tlimit:xSizes[cx].limit,\r\n\t\t\t\t\t\t\t\t\t\tminIsMinContent: specifiedSizes[cx].minType == TRACK_BREADTH_MIN_CONTENT || specifiedSizes[cx].minType == TRACK_BREADTH_AUTO,\r\n\t\t\t\t\t\t\t\t\t\tminIsMaxContent: specifiedSizes[cx].minType == TRACK_BREADTH_MAX_CONTENT,\r\n\t\t\t\t\t\t\t\t\t\tmaxIsMinContent: specifiedSizes[cx].maxType == TRACK_BREADTH_MIN_CONTENT,\r\n\t\t\t\t\t\t\t\t\t\tmaxIsMaxContent: specifiedSizes[cx].maxType == TRACK_BREADTH_MAX_CONTENT || specifiedSizes[cx].maxType == TRACK_BREADTH_AUTO\r\n\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\trows_and_limits.sort(function(a,b) { return a.limit-b.limit; });\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// remove non-affected tracks\r\n\t\t\t\t\t\t\t\trows_and_limits = rows_and_limits.filter(function(b) {\r\n\t\t\t\t\t\t\t\t\tif(kind=='base') {\r\n\t\t\t\t\t\t\t\t\t\tif(target=='min-content') {\r\n\t\t\t\t\t\t\t\t\t\t\treturn b.minIsMinContent||b.minIsMaxContent;\r\n\t\t\t\t\t\t\t\t\t\t} else if(target=='max-content') {\r\n\t\t\t\t\t\t\t\t\t\t\treturn b.minIsMaxContent;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t} else if (kind == 'limit') {\r\n\t\t\t\t\t\t\t\t\t\tif(target=='min-content') {\r\n\t\t\t\t\t\t\t\t\t\t\treturn b.maxIsMinContent||b.maxIsMaxContent;\r\n\t\t\t\t\t\t\t\t\t\t} else if(target=='max-content') {\r\n\t\t\t\t\t\t\t\t\t\t\treturn b.maxIsMaxContent;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// check that there is at least one affected track\r\n\t\t\t\t\t\t\t\tif(rows_and_limits.length == 0) { return; }\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// apply the algorithm\r\n\t\t\t\t\t\t\t\tif(kind=='base') {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// Distribute space up to growth limits\r\n\t\t\t\t\t\t\t\t\tvar tracks = rows_and_limits.filter(function(b) { return b.base<b.limit; }, 0);\r\n\t\t\t\t\t\t\t\t\tvar trackAmount = tracks.length;\r\n\t\t\t\t\t\t\t\t\tif(trackAmount > 0) {\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, kind, tracks, spaceToDistribute, /*enforceLimit:*/true);\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// Distribute space beyond growth limits\r\n\t\t\t\t\t\t\t\t\t\t// If space remains after all tracks are frozen, unfreeze and continue to distribute space to \r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// - when handling min-content base sizes: \r\n\t\t\t\t\t\t\t\t\t\tif(target=='min-content') {\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t// any affected track that happens to also have an intrinsic max track sizing function; \r\n\t\t\t\t\t\t\t\t\t\t\tvar tracks = rows_and_limits.filter(function(b) { return b.maxIsMinContent||b.maxIsMaxContent; }, 0);\r\n\t\t\t\t\t\t\t\t\t\t\tvar trackAmount = tracks.length;\r\n\t\t\t\t\t\t\t\t\t\t\tif(trackAmount>=1) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t// (such tracks exist:)\r\n\t\t\t\t\t\t\t\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, kind, tracks, spaceToDistribute, /*enforceLimit:*/false);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t// if there are no such tracks, then all affected tracks. \r\n\t\t\t\t\t\t\t\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, kind, rows_and_limits, spaceToDistribute, /*enforceLimit:*/false);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// - when handling max-content base sizes: \r\n\t\t\t\t\t\t\t\t\t\telse if(target=='max-content') {\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t// any affected track that happens to also have a max-content max track sizing function;\r\n\t\t\t\t\t\t\t\t\t\t\tvar tracks = rows_and_limits.filter(function(b) { return b.maxIsMaxContent; }, 0);\r\n\t\t\t\t\t\t\t\t\t\t\tvar trackAmount = tracks.length;\r\n\t\t\t\t\t\t\t\t\t\t\tif(trackAmount>=1) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t// (such tracks exist:)\r\n\t\t\t\t\t\t\t\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, kind, tracks, spaceToDistribute, /*enforceLimit:*/false);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t// if there are no such tracks, then all affected tracks. \r\n\t\t\t\t\t\t\t\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, kind, rows_and_limits, spaceToDistribute, /*enforceLimit:*/false);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\telse if (kind == 'limit') {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// distribute among all tracks\r\n\t\t\t\t\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, kind, rows_and_limits, spaceToDistribute);\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar updateInfiniteLimitFlag = function() {\r\n\t\t\t\t\t\t\tfor(var x = xSizes.length; x--;) {\r\n\t\t\t\t\t\t\t\tif(xSizes[x].limit != infinity) {\r\n\t\t\t\t\t\t\t\t\txSizes[x].flags = xSizes[x].flags & ~LIMIT_IS_INFINITE;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t// 1. For intrinsic minimums: First increase the base size of tracks with a min track sizing function of min-content or max-content by distributing extra space as needed to account for these items' min-content contributions. \r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\tdistributeFreeSpace(getMinWidthOf(item), 'base', 'min-content');\r\n\t\t\t\t\t\tupdateInfiniteLimitFlag();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t// 2. For max-content minimums: Next continue to increase the base size of tracks with a min track sizing function of max-content by distributing extra space as needed to account for these items' max-content contributions. \r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\tdistributeFreeSpace(getMaxWidthOf(item), 'base', 'max-content');\r\n\t\t\t\t\t\tupdateInfiniteLimitFlag();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t// 3. For intrinsic maximums: Third increase the growth limit of tracks with a max track sizing function of min-content or max-content by distributing extra space as needed to account for these items' min-content contributions. \r\n\t\t\t\t\t\t// Mark any tracks whose growth limit changed from infinite to finite in this step as infinitely growable for the next step. \r\n\t\t\t\t\t\t// (aka do not update infinity flag)\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\tdistributeFreeSpace(getMinWidthOf(item), 'limit', 'min-content');\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t// 4. For max-content maximums: Lastly continue to increase the growth limit of tracks with a max track sizing function of max-content by distributing extra space as needed to account for these items' max-content contributions. \r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\tdistributeFreeSpace(getMaxWidthOf(item), 'limit', 'max-content');\r\n\t\t\t\t\t\tupdateInfiniteLimitFlag();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\titems_done++;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar computeTrackBreadthIncrease = function(xSizes, specifiedSizes, fullSize, getMinWidthOf, getMaxWidthOf, getXStartOf, getXEndOf) {\r\n\t\t\t\t\r\n\t\t\t\t// sort rows by growth limit\r\n\t\t\t\tvar rows_and_limits = xSizes.map(function(item, cx) { \r\n\t\t\t\t\treturn { \r\n\t\t\t\t\t\tx:cx, \r\n\t\t\t\t\t\tbase:xSizes[cx].base,\r\n\t\t\t\t\t\tlimit:xSizes[cx].limit,\r\n\t\t\t\t\t\tminIsMinContent: specifiedSizes[cx].minType == TRACK_BREADTH_MIN_CONTENT || specifiedSizes[cx].minType == TRACK_BREADTH_AUTO,\r\n\t\t\t\t\t\tminIsMaxContent: specifiedSizes[cx].minType == TRACK_BREADTH_MAX_CONTENT,\r\n\t\t\t\t\t\tmaxIsMinContent: specifiedSizes[cx].maxType == TRACK_BREADTH_MIN_CONTENT,\r\n\t\t\t\t\t\tmaxIsMaxContent: specifiedSizes[cx].maxType == TRACK_BREADTH_MAX_CONTENT || specifiedSizes[cx].maxType == TRACK_BREADTH_AUTO\r\n\t\t\t\t\t};\r\n\t\t\t\t});\r\n\t\t\t\trows_and_limits.sort(function(a,b) { return a.limit-b.limit; });\r\n\t\t\t\t\r\n\t\t\t\twhile(true) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// compute size to distribute\r\n\t\t\t\t\tvar spaceToDistribute = fullSize;\r\n\t\t\t\t\tfor(var cx = xSizes.length; cx--;) {\r\n\t\t\t\t\t\tspaceToDistribute -= xSizes[cx].base;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// check that there is some space to distribute\r\n\t\t\t\t\tif(spaceToDistribute <= 0) { return; }\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Distribute space up to growth limits\r\n\t\t\t\t\tvar tracks = rows_and_limits = rows_and_limits.filter(function(b) { return ((b.minIsMinContent||b.minIsMaxContent) && b.base<b.limit); }, 0);\r\n\t\t\t\t\tvar trackAmount = tracks.length; if(trackAmount <= 0) { return; }\r\n\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, 'base', tracks, spaceToDistribute, /*enforceLimit:*/true);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar computeFlexibleTrackBreadth = function(xSizes, specifiedSizes, fullSize, getMinWidthOf, getMaxWidthOf, getXStartOf, getXEndOf) {\r\n\t\t\t\t\r\n\t\t\t\t// If the free space is an indefinite length: \r\n\t\t\t\tif(fullSize==0) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t//The used flex fraction is the maximum of: \r\n\t\t\t\t\tvar currentFraction = 0;\r\n\t\t\t\t\t\r\n\t\t\t\t\t//  Each flexible tracks base size divided by its flex factor. \r\n\t\t\t\t\t'TODO: I believe this is completely useless, but CSSWG will not change it.';\r\n\t\t\t\t\t\r\n\t\t\t\t\t//  The result of finding the size of an fr for each grid item that crosses a flexible track, using all the grid tracks that the item crosses and a space to fill of the items max-content contribution. \r\n\t\t\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i]; var item_xStart = getXStartOf(item); var item_xEnd = getXEndOf(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// gather some pieces of data about the tracks\r\n\t\t\t\t\t\tvar spaceToDistribute = getMaxWidthOf(item); var flexFactorSum = 0;\r\n\t\t\t\t\t\tfor(var cx = item_xStart; cx<item_xEnd; cx++) { \r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif(specifiedSizes[cx].maxType == TRACK_BREADTH_FRACTION) {\r\n\t\t\t\t\t\t\t\t// compute how much flexible tracks are required\r\n\t\t\t\t\t\t\t\tflexFactorSum += specifiedSizes[cx].maxValue;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// deduce non-flexible tracks from the space to distribute\r\n\t\t\t\t\t\t\t\tspaceToDistribute -= xSizes[cx].base;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// compute the minimum flex fraction for this item\r\n\t\t\t\t\t\tif(spaceToDistribute > 0 && flexFactorSum > 0) {\r\n\t\t\t\t\t\t\tcurrentFraction = Math.max(currentFraction, spaceToDistribute / flexFactorSum)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// for each flexible track\r\n\t\t\t\t\tfor(var x = xSizes.length; x--;) {\r\n\t\t\t\t\t\tif(specifiedSizes[x].maxType == TRACK_BREADTH_FRACTION) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Compute the product of the hypothetical flex fraction and the tracks flex factor\r\n\t\t\t\t\t\t\tvar trackSize = currentFraction * specifiedSizes[x].maxValue;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// If that size is less than the tracks base size:\r\n\t\t\t\t\t\t\tif(xSizes[x].base < trackSize) {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// set its base size to that product.\r\n\t\t\t\t\t\t\t\txSizes[x].breadth = trackSize;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\txSizes[x].breadth = xSizes[x].base;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\txSizes[x].breadth = xSizes[x].base;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t\t// compute the leftover space\r\n\t\t\t\t\tvar spaceToDistribute = fullSize;\r\n\t\t\t\t\tvar tracks = []; var fractionSum = 0;\r\n\t\t\t\t\tfor(var x = xSizes.length; x--;) {\r\n\t\t\t\t\t\tif(specifiedSizes[x].maxType == TRACK_BREADTH_FRACTION) {\r\n\t\t\t\t\t\t\ttracks.push(x); fractionSum += specifiedSizes[x].maxValue;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tspaceToDistribute -= (xSizes[x].breadth = xSizes[x].base);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// while there are flexible tracks to size\r\n\t\t\t\t\twhile(tracks.length>0) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Let the hypothetical flex fraction be the leftover space divided by the sum of the flex factors of the flexible tracks.\r\n\t\t\t\t\t\tvar currentFraction = spaceToDistribute / fractionSum; var restart = false;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// for each flexible track\r\n\t\t\t\t\t\tfor(var i = tracks.length; i--;) { var x = tracks[i];\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Compute the product of the hypothetical flex fraction and the tracks flex factor\r\n\t\t\t\t\t\t\tvar trackSize = currentFraction * specifiedSizes[x].maxValue;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// If that size is less than the tracks base size:\r\n\t\t\t\t\t\t\tif(xSizes[x].base < trackSize) {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// set its base size to that product.\r\n\t\t\t\t\t\t\t\txSizes[x].breadth = trackSize;\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// mark as non-flexible\r\n\t\t\t\t\t\t\t\txSizes[x].breadth = xSizes[x].base;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// remove from computation\r\n\t\t\t\t\t\t\t\tfractionSum -= specifiedSizes[x].maxValue;\r\n\t\t\t\t\t\t\t\ttracks.splice(i,1);\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// restart\r\n\t\t\t\t\t\t\t\trestart=true;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif(!restart) { tracks.length = 0; }\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar computeFinalTrackBreadth = function(xSizes, this_xSizes, fullWidth, getMinWidthOf, getMaxWidthOf, getXStartOf, getXEndOf) {\r\n\t\t\t\t\r\n\t\t\t\t// compute base and limit\r\n\t\t\t\tcomputeTrackBreadth.call(\r\n\t\t\t\t\tthis,\r\n\t\t\t\t\txSizes,\r\n\t\t\t\t\tthis_xSizes,\r\n\t\t\t\t\tgetMinWidthOf,\r\n\t\t\t\t\tgetMaxWidthOf,\r\n\t\t\t\t\tgetXStartOf,\r\n\t\t\t\t\tgetXEndOf\r\n\t\t\t\t);\r\n\t\t\t\t\r\n\t\t\t\t// ResolveContentBasedTrackSizingFunctions (step 4)\r\n\t\t\t\tfor(var x = this_xSizes.length; x--;) {\r\n\t\t\t\t\tif(xSizes[x].limit == infinity) { xSizes[x].limit = xSizes[x].base; }\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// grow tracks up to their max\r\n\t\t\t\tcomputeTrackBreadthIncrease.call(\r\n\t\t\t\t\tthis,\r\n\t\t\t\t\txSizes,\r\n\t\t\t\t\tthis_xSizes,\r\n\t\t\t\t\tfullWidth,\r\n\t\t\t\t\tgetMinWidthOf,\r\n\t\t\t\t\tgetMaxWidthOf,\r\n\t\t\t\t\tgetXStartOf,\r\n\t\t\t\t\tgetXEndOf\r\n\t\t\t\t);\r\n\t\t\t\t\r\n\t\t\t\t// handle flexible things\r\n\t\t\t\tcomputeFlexibleTrackBreadth.call(\r\n\t\t\t\t\tthis,\r\n\t\t\t\t\txSizes,\r\n\t\t\t\t\tthis_xSizes,\r\n\t\t\t\t\tfullWidth,\r\n\t\t\t\t\tgetMinWidthOf,\r\n\t\t\t\t\tgetMaxWidthOf,\r\n\t\t\t\t\tgetXStartOf,\r\n\t\t\t\t\tgetXEndOf\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t// compute breadth of columns\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\tvar mode = 'x';\r\n\t\t\tvar fullSize = fullWidth;\r\n\t\t\tvar xSizes = this.xSizes.map(initializeFromConstraints);\r\n\t\t\t\r\n\t\t\tvar getMinWidthOf = function(item) { return item.minWidth+item.hMargins; };\r\n\t\t\tvar getMaxWidthOf = function(item) { return item.maxWidth+item.hMargins; };\r\n\t\t\tvar getXStartOf = function(item) { return item.xStart; }; \r\n\t\t\tvar getXEndOf = function(item) { return item.xEnd; };\r\n\t\t\t\r\n\t\t\t// compute base and limit\r\n\t\t\tcomputeFinalTrackBreadth.call(\r\n\t\t\t\tthis,\r\n\t\t\t\txSizes,\r\n\t\t\t\tthis.xSizes,\r\n\t\t\t\tfullWidth,\r\n\t\t\t\tgetMinWidthOf,\r\n\t\t\t\tgetMaxWidthOf,\r\n\t\t\t\tgetXStartOf,\r\n\t\t\t\tgetXEndOf\r\n\t\t\t);\r\n\t\t\t\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t// position each element absolutely, and set width to compute height\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\tvar usedStyle = usedStyleOf(this.element);\r\n\t\t\tvar runtimeStyle = createRuntimeStyle('temp-position', this.element);\r\n\t\t\t\r\n\t\t\tif(usedStyle.getPropertyValue('position')=='static') { \r\n\t\t\t\truntimeStyle.set(this.element, {\"position\":\"relative\"});\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis.items.forEach(function(item) {\r\n\t\t\t\t\r\n\t\t\t\t// firstly, compute the total breadth of the spanned tracks\r\n\t\t\t\tvar totalBreadth = 0;\r\n\t\t\t\tfor(var cx = item.xStart; cx<item.xEnd; cx++) {\r\n\t\t\t\t\ttotalBreadth += xSizes[cx].breadth;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// secondly, adapt to the alignment properties\r\n\t\t\t\t\"TODO: alignment\";\r\n\t\t\t\t\r\n\t\t\t\t// finally, set the style\r\n\t\t\t\truntimeStyle.set(item.element, {\r\n\t\t\t\t\t\"position\"   : \"absolute\",\r\n\t\t\t\t\t\"width\"      : \"\"+totalBreadth+\"px\",\r\n\t\t\t\t\t\"box-sizing\" : \"border-box\"\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t// compute breadth of rows\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\tvar mode = 'y';\r\n\t\t\tvar fullSize = fullHeight;\r\n\t\t\tvar ySizes = this.ySizes.map(initializeFromConstraints);\r\n\t\t\t\r\n\t\t\tvar getMinHeightOf = function(item) { return item.element.offsetHeight+item.vMargins; };\r\n\t\t\tvar getMaxHeightOf = function(item) { return item.element.offsetHeight+item.vMargins; };\r\n\t\t\tvar getYStartOf = function(item) { return item.yStart; };\r\n\t\t\tvar getYEndOf = function(item) { return item.yEnd; };\r\n\t\t\t\r\n\t\t\tcomputeFinalTrackBreadth.call(\r\n\t\t\t\tthis,\r\n\t\t\t\tySizes,\r\n\t\t\t\tthis.ySizes,\r\n\t\t\t\tfullHeight,\r\n\t\t\t\tgetMinHeightOf,\r\n\t\t\t\tgetMaxHeightOf,\r\n\t\t\t\tgetYStartOf,\r\n\t\t\t\tgetYEndOf\r\n\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t// release the override style of elements\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\truntimeStyle.revoke();\r\n\t\t\t\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t// save the results\r\n\t\t\t////\r\n\t\t\tthis.finalXSizes = xSizes;\r\n\t\t\tthis.finalYSizes = ySizes;\r\n\t\t\t\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t// log the results\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t/*console.log({\r\n\t\t\t\tx: xSizes,\r\n\t\t\t\txBreadths: xSizes.map(function(e) { return e.breadth; }),\r\n\t\t\t\ty: ySizes,\r\n\t\t\t\tyBreadths: ySizes.map(function(e) { return e.breadth; }),\r\n\t\t\t});*/\r\n\t\t\r\n\t\t},\r\n\t\t\r\n\t\tgenerateMSGridStyle: function() {\r\n\t\t\t\r\n\t\t\tthis.element.style.setProperty(\"display\",\"-ms-grid\");\r\n\t\t\tthis.element.style.setProperty(\"-ms-grid-rows\",this.ySizes.join(' '));\r\n\t\t\tthis.element.style.setProperty(\"-ms-grid-columns\",this.xSizes.join(' '));\r\n\t\t\t\r\n\t\t\tfor(var i=this.items.length; i--;) { var item = this.items[i]; \r\n\t\t\t\t\r\n\t\t\t\titem.element.style.setProperty(\"-ms-grid-row\", item.yStart+1);\r\n\t\t\t\titem.element.style.setProperty(\"-ms-grid-column\", item.xStart+1);\r\n\t\t\t\titem.element.style.setProperty(\"-ms-grid-row-span\", item.yEnd-item.yStart);\r\n\t\t\t\titem.element.style.setProperty(\"-ms-grid-column-span\", item.xEnd-item.xStart);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tgeneratePolyfilledStyle: function() {\r\n\t\t\r\n\t\t\tvar usedStyle = usedStyleOf(this.element);\r\n\t\t\tvar runtimeStyle = createRuntimeStyle(\"css-grid\", this.element);\r\n\t\t\r\n\t\t\tvar xSizes = this.finalXSizes;\r\n\t\t\tvar ySizes = this.finalYSizes;\r\n\t\t\t\r\n\t\t\tvar grid_width = 0;\r\n\t\t\tfor(var x = 0; x<xSizes.length; x++) {\r\n\t\t\t\tgrid_width += xSizes[x].breadth;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar grid_height = 0;\r\n\t\t\tfor(var y = 0; y<ySizes.length; y++) {\r\n\t\t\t\tgrid_height += ySizes[y].breadth;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar runtimeStyleData = {};\r\n\t\t\tif([\"block\",\"inline-block\"].indexOf(usedStyle.getPropertyValue(\"display\")) == -1) {\r\n\t\t\t\truntimeStyleData[\"display\"] = \"block\";\r\n\t\t\t}\r\n\t\t\tif(usedStyle.getPropertyValue('position')=='static') {\r\n\t\t\t\truntimeStyleData[\"position\"] = \"relative\";\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\truntimeStyle.set(this.element, runtimeStyleData);\r\n\t\t\t\r\n\r\n\t\t\t// set the position and sizing of each elements\r\n\t\t\tvar width = grid_width; var height = grid_height;\r\n\t\t\tvar items_widths = []; var items_heights = []; \r\n\t\t\titems_widths.length = items_heights.length = this.items.length;\r\n\t\t\tfor(var i=this.items.length; i--;) { var item = this.items[i]; \r\n\t\t\t\t\r\n\t\t\t\tvar left = 0;\r\n\t\t\t\tfor(var x = 0; x<item.xStart; x++) {\r\n\t\t\t\t\tleft += xSizes[x].breadth;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvar width = 0;\r\n\t\t\t\tfor(var x = item.xStart; x<item.xEnd; x++) {\r\n\t\t\t\t\twidth += xSizes[x].breadth;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvar top = 0;\r\n\t\t\t\tfor(var y = 0; y<item.yStart; y++) {\r\n\t\t\t\t\ttop += ySizes[y].breadth;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvar height = 0;\r\n\t\t\t\tfor(var y = item.yStart; y<item.yEnd; y++) {\r\n\t\t\t\t\theight += ySizes[y].breadth;\r\n\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\truntimeStyle.set(item.element, {\r\n\t\t\t\t\t\"position\"    : \"absolute\",\r\n\t\t\t\t\t\"box-sizing\"  : \"border-box\",\r\n\t\t\t\t\t\"top\"         : \"\"+top +\"px\",\r\n\t\t\t\t\t\"left\"        : \"\"+left+'px'\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\titems_widths[i] = width-item.hMargins;\r\n\t\t\t\titems_heights[i] = height-item.vMargins;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// if horizontal stretch\r\n\t\t\tif(true) { // TODO: horizontal stretch\r\n\t\t\t\tfor(var i=this.items.length; i--;) { var item = this.items[i]; var width = items_widths[i];\r\n\t\t\t\t\tif(item.minWidth <= width) { // TODO: fix that...\r\n\t\t\t\t\t\truntimeStyle.set(item.element, {\"width\": width +'px'});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// if vertical stretch\r\n\t\t\tif(true) { // TODO: vertical stretch\r\n\t\t\t\tfor(var i=this.items.length; i--;) { var item = this.items[i]; var height = items_heights[i];\r\n\t\t\t\t\tif(item.element.offsetHeight <= height) {\r\n\t\t\t\t\t\truntimeStyle.set(item.element, {\"height\": height+'px'});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// make sure the final size is right:\r\n\t\t\tvar runtimeStyleData = {};\r\n\t\t\t//if([\"absolute\",\"fixed\"].indexOf(usedStyle.getPropertyValue(\"position\")) >= 0) { runtimeStyleData[\"width\"] = grid_width+'px'; }\r\n\t\t\tif([\"auto\",\"0px\"].indexOf(usedStyle.getPropertyValue(\"width\")) >= 0) { runtimeStyleData[\"width\"] = grid_width+'px'; }\r\n\t\t\tif([\"auto\",\"0px\"].indexOf(usedStyle.getPropertyValue(\"height\")) >= 0) { runtimeStyleData[\"height\"] = grid_height+'px'; }\r\n\t\t\truntimeStyle.set(this.element, runtimeStyleData);\r\n\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\trevokePolyfilledStyle: function() {\r\n\t\t\t\r\n\t\t\tcreateRuntimeStyle('css-grid', this.element).revoke();\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tfindXStart: function(item) {\r\n\t\t\r\n\t\t\t//////////////////////////////////////////////////////////////////////////////\r\n\t\t\t// TODO: this doesn't reflect the spec after the changes made at my request //\r\n\t\t\t//////////////////////////////////////////////////////////////////////////////\r\n\t\t\t\r\n\t\t\tvar xStart = -1;\r\n\t\t\tif(item.specifiedXStart.type !== LOCATE_LINE) return 0;\r\n\t\t\t\r\n\t\t\tif(item.specifiedXStart.name) {\r\n\t\t\t\t\r\n\t\t\t\t//\r\n\t\t\t\t// <integer>? <custom-ident>\r\n\t\t\t\t//\r\n\t\t\t\t\r\n\t\t\t\tif(item.specifiedXStart.index === undefined) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// First attempts to match the grid areas edge to a named grid area\r\n\t\t\t\t\txStart = this.findXLine(item.specifiedXStart.name+\"-start\", 0, 0, /*dontFallback*/true);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tif(xStart==-1) {\r\n\t\t\t\t\r\n\t\t\t\t\t// Otherwise, contributes the first named line with the specified name to the grid items placement. \r\n\t\t\t\t\txStart = this.findXLine(item.specifiedXStart.name, 0, (item.specifiedXStart.index||1)-1);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t//\r\n\t\t\t\t// <integer>\r\n\t\t\t\t//\r\n\t\t\t\txStart = (item.specifiedXStart.index||1)-1;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// correct impossible values\r\n\t\t\tif(xStart < 0) { xStart=0; }\r\n\t\t\t\r\n\t\t\t// return the final result\r\n\t\t\treturn item.xStart = xStart;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tfindYStart: function(item) {\r\n\t\t\t\r\n\t\t\tvar yStart = -1;\r\n\t\t\tif(item.specifiedYStart.type !== LOCATE_LINE) return 0;\r\n\r\n\t\t\tif(item.specifiedYStart.name) {\r\n\t\t\t\t\r\n\t\t\t\t//\r\n\t\t\t\t// <interger>? <custom-ident>\r\n\t\t\t\t//\r\n\t\t\t\t\r\n\t\t\t\tif(item.specifiedYStart.index === undefined) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// First attempts to match the grid areas edge to a named grid area\r\n\t\t\t\t\tyStart = this.findYLine(item.specifiedYStart.name+\"-start\", 0, 0, /*dontFallback*/true);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tif(yStart == -1) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Otherwise, contributes the first named line with the specified name to the grid items placement. \r\n\t\t\t\t\tyStart = this.findYLine(item.specifiedYStart.name, 0,(item.specifiedYStart.index||1)-1);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t//\r\n\t\t\t\t// <integer>\r\n\t\t\t\t//\r\n\t\t\t\tyStart = (item.specifiedYStart.index||1)-1;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// correct impossible values\r\n\t\t\tif(yStart < 0) { yStart=0; }\r\n\t\t\t\r\n\t\t\t// return the final result\r\n\t\t\treturn item.yStart = yStart;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tfindXEnd: function(item) {\r\n\t\t\t\r\n\t\t\tvar xEnd = -1;\r\n\t\t\tvar xStart = item.xStart;\r\n\t\t\tswitch(item.specifiedXEnd.type) {\r\n\t\t\t\t\r\n\t\t\t\tcase LOCATE_LINE:\r\n\t\t\t\t\tif(item.specifiedXEnd.name) {\r\n\t\t\t\t\t\tif(item.specifiedXEnd.index === undefined) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// First attempts to match the grid areas edge to a named grid area\r\n\t\t\t\t\t\t\txEnd = this.findXLine(item.specifiedXEnd.name+\"-end\", 0, 0, /*dontFallback*/true);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(xEnd == -1) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Otherwise, contributes the first named line with the specified name to the grid items placement. \r\n\t\t\t\t\t\t\txEnd = this.findXLine(item.specifiedXEnd.name, 0, (item.specifiedXEnd.index||1)-1);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\txEnd = (item.specifiedXEnd.index||1)-1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\tcase LOCATE_SPAN:\r\n\t\t\t\t\tif(item.specifiedXEnd.name) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// Set the corresponding edge N lines apart from its opposite edge. \r\n\t\t\t\t\t\txEnd = this.findXLine(item.specifiedXEnd.name, xStart+1, (item.specifiedXEnd.index||1)-1);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Set the corresponding edge N lines apart from its opposite edge. \r\n\t\t\t\t\t\txEnd = xStart+((item.specifiedXEnd.index|0)||1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\tcase LOCATE_AUTO:\r\n\t\t\t\t\t// I don't support subgrids, so this is always true:\r\n\t\t\t\t\txEnd = xStart+1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(xEnd <= xStart) { xEnd = xStart+1; }\r\n\t\t\treturn item.xEnd = xEnd;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tfindYEnd: function(item) {\r\n\t\t\t\r\n\t\t\tvar yEnd = -1;\r\n\t\t\tvar yStart = item.yStart;\r\n\t\t\tswitch(item.specifiedYEnd.type) {\r\n\t\t\t\t\r\n\t\t\t\tcase LOCATE_LINE:\r\n\t\t\t\t\tif(item.specifiedYEnd.name) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t// <integer>? <identifier>\r\n\t\t\t\t\t\t// \r\n\t\t\t\t\t\tif(item.specifiedYEnd.index === undefined) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// First attempts to match the grid areas edge to a named grid area\r\n\t\t\t\t\t\t\tyEnd = this.findYLine(item.specifiedYEnd.name+\"-end\", 0, 0, /*dontFallback*/true);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(yEnd == -1) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Otherwise, contributes the first named line with the specified name to the grid items placement. \r\n\t\t\t\t\t\t\tyEnd = this.findYLine(item.specifiedYEnd.name, 0, (item.specifiedYEnd.index||1)-1);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t// <integer>\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\tyEnd = (item.specifiedYEnd.index||1)-1;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\tcase LOCATE_SPAN:\r\n\t\t\t\t\tif(item.specifiedYEnd.name) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// Set the corresponding edge N lines apart from its opposite edge. \r\n\t\t\t\t\t\tyEnd = this.findYLine(item.specifiedYEnd.name, yStart+1, (item.specifiedYEnd.index||1)-1);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// TODO: I'm having the wrong behavior here, I sent a mail to csswg to get the spec changed\r\n\t\t\t\t\t\t// \"The spec is more what you'd call 'guidelines' than actual rules\"\r\n\t\t\t\t\t\tif(yEnd==-1) { yEnd = 0; }\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Set the corresponding edge N lines apart from its opposite edge. \r\n\t\t\t\t\t\tyEnd = yStart+((item.specifiedYEnd.index|0)||1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\tcase LOCATE_AUTO:\r\n\t\t\t\t\t// I don't support subgrids, so this is always true:\r\n\t\t\t\t\tyEnd = yStart+1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// correct impossible end values\r\n\t\t\tif(yEnd <= yStart) { yEnd = yStart+1; }\r\n\t\t\t\r\n\t\t\t// return the final result\r\n\t\t\treturn item.yEnd = yEnd;\r\n\r\n\t\t},\r\n\t\t\r\n\t\tfindXLine: function(name, startIndex, skipCount, dontFallback) {\r\n\t\t\r\n\t\t\tstartIndex=startIndex|0;\r\n\t\t\tskipCount=skipCount|0;\r\n\t\t\t\r\n\t\t\t// special case for cases where the name isn't provided\r\n\t\t\tif(!name) {\r\n\t\t\t\tif(startIndex+skipCount < this.xLines.length) {\r\n\t\t\t\t\treturn startIndex+skipCount;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn this.xLines.length;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// find the 1+skipCount'th line to match the right name\r\n\t\t\tvar last = -1;\r\n\t\t\tfor(var i = startIndex; i<this.xLines.length; i++) {\r\n\t\t\t\tif(this.xLines[i].indexOf(name) >= 0 || (!dontFallback && this.xLines[i].indexOf('*') >= 0)) { \r\n\t\t\t\t\tif(skipCount>0) { last=i; skipCount--; }\r\n\t\t\t\t\telse { return i; }\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// if we still have lines to find, we know that lines of the implicit grid match all names\r\n\t\t\tif(!dontFallback) { console.warn('[CSS-GRID] Missing '+(skipCount+1)+' lines named \"'+name+'\" after line '+startIndex+'.'); last = this.xLines.length+skipCount+1; this.ensureRows(last); }\r\n\t\t\treturn last;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tfindYLine: function(name, startIndex, skipCount, dontFallback) {\r\n\r\n\t\t\tstartIndex=startIndex|0;\r\n\t\t\tskipCount=skipCount|0;\r\n\t\t\t\r\n\t\t\t// special case for cases where the name isn't provided\r\n\t\t\tif(!name) {\r\n\t\t\t\tif(startIndex+skipCount < this.yLines.length) {\r\n\t\t\t\t\treturn startIndex+skipCount;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn this.yLines.length;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// find the 1+skipCount'th line to match the right name\r\n\t\t\tvar last = -1;\r\n\t\t\tfor(var i = startIndex; i<this.yLines.length; i++) {\r\n\t\t\t\tif(this.yLines[i].indexOf(name) >= 0 || (!dontFallback && this.yLines[i].indexOf('*') >= 0)) { \r\n\t\t\t\t\tif(skipCount>0) { last=i; skipCount--; }\r\n\t\t\t\t\telse { return i; }\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// if we still have lines to find, we know that lines of the implicit grid match all names\r\n\t\t\tif(!dontFallback) { console.warn('[CSS-GRID] Missing '+(skipCount+1)+' lines named \"'+name+'\" after line '+startIndex+'.'); last = this.yLines.length+skipCount+1; this.ensureColumns(last); }\r\n\t\t\treturn last;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t}\r\n\t\r\n\tvar cssGrid = {\r\n\t\t\r\n\t\tLOCATE_LINE   :  LOCATE_LINE,\r\n\t\tLOCATE_SPAN   :  LOCATE_SPAN,\r\n\t\tLOCATE_AREA   :  LOCATE_AREA,\r\n\t\tLOCATE_AUTO   :  LOCATE_AUTO,\r\n\t\t\r\n\t\tALIGN_START   :  ALIGN_START,\r\n\t\tALIGN_CENTER  :  ALIGN_CENTER,\r\n\t\tALIGN_END     :  ALIGN_END,\r\n\t\tALIGN_FIT     :  ALIGN_FIT,  \r\n\t\t\r\n\t\tTRACK_BREADTH_AUTO        : TRACK_BREADTH_AUTO,\r\n\t\tTRACK_BREADTH_LENGTH      : TRACK_BREADTH_LENGTH,\r\n\t\tTRACK_BREADTH_FRACTION    : TRACK_BREADTH_FRACTION,\r\n\t\tTRACK_BREADTH_PERCENTAGE  : TRACK_BREADTH_PERCENTAGE,\r\n\t\tTRACK_BREADTH_MIN_CONTENT : TRACK_BREADTH_MIN_CONTENT,\r\n\t\tTRACK_BREADTH_MAX_CONTENT : TRACK_BREADTH_MAX_CONTENT,\r\n\r\n\t\tGridLayout: GridLayout, \r\n\t\tGridItem: GridItem, \r\n\t\tGridItemPosition: GridItemPosition,\r\n\t\tGridTrackBreadth: GridTrackBreadth,\r\n\t\t\r\n\t};\r\n\treturn cssGrid;\r\n\t\r\n})(window, document)\nrequire.define('src/css-grid/lib/grid-layout.js');","// TODO: document the \"no_auto_css_grid\" flag?\r\n// TOOD: document the \"no_ms_grid_implementation\" flag?\r\n\r\n!(function(window, document) { \"use strict\";\r\n\r\n\trequire('src/core/polyfill-dom-console.js');\r\n\tvar cssCascade = require('src/core/css-cascade.js');\r\n\tvar cssGrid = require('src/css-grid/lib/grid-layout.js');\r\n\t\r\n\tvar enabled = false;\r\n\tvar enablePolyfill = function() { if(enabled) { return; } else { enabled = true; }\r\n\r\n\t\t//\r\n\t\t// [0] define css properties\r\n\t\t// those properties can now be set using Element.myStyle.xyz if they weren't already\r\n\t\t//\r\n\t\t\r\n\t\tvar gridProperties = ['grid','grid-template','grid-template-rows','grid-template-columns','grid-template-areas','grid-areas','grid-auto-flow'];\r\n\t\tvar gridItemProperties = ['grid-area','grid-row','grid-column','grid-row-start','grid-row-end','grid-column-start','grid-column-end'];\r\n\t\tfor(var i=gridProperties.length; i--;)     { cssCascade.polyfillStyleInterface(gridProperties[i]); }\r\n\t\tfor(var i=gridItemProperties.length; i--;) { cssCascade.polyfillStyleInterface(gridItemProperties[i]); }\r\n\t\t\r\n\t\t// \r\n\t\t// [1] when any update happens:\r\n\t\t// construct new content and region flow pairs\r\n\t\t// restart the region layout algorithm for the modified pairs\r\n\t\t// \r\n\t\t\r\n\t\tcssCascade.startMonitoringProperties(\r\n\t\t\tgridProperties, \r\n\t\t\t{\r\n\t\t\t\tonupdate: function onupdate(element, rule) {\r\n\r\n\t\t\t\t\t// log some message in the console for debug\r\n\t\t\t\t\tcssConsole.dir({message:\"onupdate\",element:element,selector:rule.selector.toCSSString(),rule:rule});\r\n\t\t\t\t\t\r\n\t\t\t\t\t// check if the element already has a grid or grid-item layout\r\n\t\t\t\t\tif(element.gridModel) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// the layout must be recomputed\r\n\t\t\t\t\t\telement.gridModel.scheduleRelayout();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// setup a new grid model, and schedule a relayout\r\n\t\t\t\t\t\telement.gridLayout = new cssGrid.GridLayout(element);\r\n\t\t\t\t\t\telement.gridLayout.scheduleRelayout();\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// TODO: watch DOM for updates in the element?\r\n\t\t\t\t\t\tif(\"MutationObserver\" in window) {\r\n\t\t\t\t\t\t\tvar observer = new MutationObserver(function(e) {\r\n\t\t\t\t\t\t\t\telement.gridLayout.scheduleRelayout();\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\tvar target = document.documentElement;\r\n\t\t\t\t\t\t\tvar config = { \r\n\t\t\t\t\t\t\t\tsubtree: true, \r\n\t\t\t\t\t\t\t\tattributes: false, \r\n\t\t\t\t\t\t\t\tchildList: true, \r\n\t\t\t\t\t\t\t\tcharacterData: true\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\tobserver.observe(target, config);\r\n\t\t\t\t\t\t} else if(\"MutationEvent\" in window) {\r\n\t\t\t\t\t\t\telement.addEventListener('DOMSubtreeModified', function() {\r\n\t\t\t\t\t\t\t\tif(!element.gridLayout.isLayoutScheduled) { element.gridLayout.scheduleRelayout(); }\r\n\t\t\t\t\t\t\t}, true);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// TODO: watch resize events for relayout?\r\n\t\t\t\t\t\tvar lastWidth = element.offsetWidth;\r\n\t\t\t\t\t\tvar lastHeight = element.offsetHeight;\r\n\t\t\t\t\t\tvar updateOnResize = function() {\r\n\t\t\t\t\t\t\tif(lastWidth != element.offsetWidth || lastHeight != element.offsetHeight) {\r\n\t\t\t\t\t\t\t\t// update last known size\r\n\t\t\t\t\t\t\t\tlastWidth = element.offsetWidth;\r\n\t\t\t\t\t\t\t\tlastHeight = element.offsetHeight;\r\n\t\t\t\t\t\t\t\t// relayout (and prevent double-dispatch)\r\n\t\t\t\t\t\t\t\tif(observer) { observer.takeRecords(); observer.disconnect(element); }\r\n\t\t\t\t\t\t\t\telement.gridLayout.scheduleRelayout();\r\n\t\t\t\t\t\t\t\tif(observer) { observer.takeRecords(); observer.observe(element, config); }\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\trequestAnimationFrame(updateOnResize);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trequestAnimationFrame(updateOnResize);\r\n\t\t\t\t\t\t// TODO: watch the load event for relayout?\r\n\t\t\t\t\t\twindow.addEventListener('load', updateOnResize);\r\n\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\tcssCascade.startMonitoringProperties(\r\n\t\t\tgridItemProperties, \r\n\t\t\t{\r\n\t\t\t\tonupdate: function onupdate(element, rule) {\r\n\r\n\t\t\t\t\t// log some message in the console for debug\r\n\t\t\t\t\tcssConsole.dir({message:\"onupdate\",element:element,selector:rule.selector.toCSSString(),rule:rule});\r\n\t\t\t\t\t\r\n\t\t\t\t\t// check if the element already has a grid or grid-item layout\r\n\t\t\t\t\tif(element.parentGridLayout) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// the parent layout must be recomputed\r\n\t\t\t\t\t\telement.parentGridLayout.scheduleRelayout();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t}\r\n\r\n\t// expose the enabler\r\n\tcssGrid.enablePolyfill = enablePolyfill;\r\n\t\r\n\t// enable the polyfill automatically\r\n\ttry {\r\n\t\tif(!(\"no_auto_css_grid\" in window)) { enablePolyfill(); }\r\n\t} catch (ex) {\r\n\t\tsetImmediate(function() { throw ex; });\r\n\t}\r\n\t\r\n\t// return the module\r\n\treturn cssGrid;\r\n\t\r\n})(window, document);\nrequire.define('src/css-grid/polyfill.js');","//require('core:dom-matchMedia-polyfill');\r\n//require('core:dom-classList-polyfill');\r\nrequire('src/css-grid/polyfill.js');\nrequire.define('src/requirements.js');"]}