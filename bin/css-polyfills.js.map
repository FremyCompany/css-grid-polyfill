{"version":3,"sources":["..\\src\\core\\polyfill-dom-console.js","..\\src\\core\\css-syntax.js","..\\src\\core\\dom-events.js","..\\src\\core\\dom-experimental-event-streams.js","..\\src\\core\\dom-query-selector-live.js","..\\src\\core\\css-cascade.js","..\\src\\core\\css-style.js","..\\src\\core\\polyfill-dom-uniqueID.js","..\\src\\core\\polyfill-dom-requestAnimationFrame.js","..\\src\\core\\css-sizing.js","..\\src\\core\\css-box.js","..\\src\\core\\css-units.js","..\\src\\css-grid\\lib\\grid-layout.js","..\\src\\css-grid\\polyfill.js","..\\src\\requirements.js"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mD;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;AC9pCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6D;;;;ACnXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sD;;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;ACv0BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oD;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iE;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kD;;;;ACluFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;AC/HA;AACA;AACA;AACA,sC","file":"css-polyfills.js","sourcesContent":["!(function(window, document) { \"use strict\";\r\n\r\n\t//\r\n\t// some code for console polyfilling\r\n\t//\r\n\tif(!window.console) {\r\n\t\t\t\r\n\t\twindow.console = {\r\n\t\t\tbacklog: '',\r\n\t\t\t\r\n\t\t\tlog: function(x) { this.backlog+=x+'\\n'; if(window.debug) alert(x); },\r\n\t\t\t\r\n\t\t\tdir: function(x) { try { \r\n\t\t\t\t\r\n\t\t\t\tvar elm = function(e) {\r\n\t\t\t\t\tif(e.innerHTML) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\ttagName: e.tagName,\r\n\t\t\t\t\t\t\tclassName: e.className,\r\n\t\t\t\t\t\t\tid: e.id,\r\n\t\t\t\t\t\t\tinnerHTML: e.innerHTML.substr(0,100)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tnodeName: e.nodeName,\r\n\t\t\t\t\t\t\tnodeValue: e.nodeValue\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\t\r\n\t\t\t\tvar jsonify = function(o) {\r\n\t\t\t\t\tvar seen=[];\r\n\t\t\t\t\tvar jso=JSON.stringify(o, function(k,v){\r\n\t\t\t\t\t\tif (typeof v =='object') {\r\n\t\t\t\t\t\t\tif ( !seen.indexOf(v) ) { return '__cycle__'; }\r\n\t\t\t\t\t\t\tif ( v instanceof window.Node) { return elm(v); }\r\n\t\t\t\t\t\t\tseen.push(v);\r\n\t\t\t\t\t\t} return v;\r\n\t\t\t\t\t});\r\n\t\t\t\t\treturn jso;\r\n\t\t\t\t};\r\n\t\t\t\t\r\n\t\t\t\tthis.log(jsonify(x)); \r\n\t\t\t\t\r\n\t\t\t} catch(ex) { this.log(x) } },\r\n\t\t\t\r\n\t\t\twarn: function(x) { this.log(x) },\r\n\t\t\t\r\n\t\t\terror: function(x) { this.log(\"ERROR:\"); this.log(x); }\r\n\t\t\t\r\n\t\t};\r\n\t\t\r\n\t\tif(!window.onerror) {\r\n\t\t\twindow.onerror = function() {\r\n\t\t\t\tconsole.log([].slice.call(arguments,0).join(\"\\n\"))\r\n\t\t\t};\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n\t//\r\n\t// this special console is used as a proxy emulating the CSS console of browsers\r\n\t//\r\n\twindow.cssConsole = {\r\n\t\tenabled: (!!window.debug), warnEnabled: (true),\r\n\t\tlog: function(x) { if(this.enabled) console.log(x) },\r\n\t\tdir: function(x) { if(this.enabled) console.dir(x) },\r\n\t\twarn: function(x) { if(this.warnEnabled) console.warn(x) },\r\n\t\terror: function(x) { console.error(x); }\r\n\t}\r\n\r\n})(window, document);\nrequire.define('src/core/polyfill-dom-console.js');","//\r\n// note: this file is based on Tab Atkins's CSS Parser\r\n// please include him (@tabatkins) if you open any issue for this file\r\n// \r\nmodule.exports = (function(window, document) { \"use strict\";\r\n\r\n\t// \r\n\t// exports\r\n\t//\r\n\tvar cssSyntax = { \r\n\t\ttokenize: function(string) {/*filled later*/}, \r\n\t\tparse: function(tokens) {/*filled later*/},\r\n\t\tparseCSSValue: function(bestValue, stringOnly) {\r\n\t\t\tif(stringOnly) {\r\n\t\t\t\tvar result = /*bestValue ? cssSyntax.parse(\"*{a:\"+bestValue+\"}\").value[0].value[0].value : */new cssSyntax.TokenList();\r\n\t\t\t\tresult.asCSSString = bestValue; // optimize conversion\r\n\t\t\t\treturn result;\r\n\t\t\t} else {\r\n\t\t\t\tvar result = bestValue ? cssSyntax.parse(\"*{a:\"+bestValue+\"}\").value[0].value[0].value : new cssSyntax.TokenList();\r\n\t\t\t\tresult.asCSSString = bestValue; // optimize conversion\r\n\t\t\t\treturn result;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t//\r\n\t// css tokenizer\r\n\t//\r\n    \r\n    var between = function (num, first, last) { return num >= first && num <= last; }\r\n    function digit(code) { return between(code, 0x30,0x39); }\r\n    function hexdigit(code) { return digit(code) || between(code, 0x41,0x46) || between(code, 0x61,0x66); }\r\n    function uppercaseletter(code) { return between(code, 0x41,0x5a); }\r\n    function lowercaseletter(code) { return between(code, 0x61,0x7a); }\r\n    function letter(code) { return uppercaseletter(code) || lowercaseletter(code); }\r\n    function nonascii(code) { return code >= 0xa0; }\r\n    function namestartchar(code) { return letter(code) || nonascii(code) || code == 0x5f; }\r\n    function namechar(code) { return namestartchar(code) || digit(code) || code == 0x2d; }\r\n    function nonprintable(code) { return between(code, 0,8) || between(code, 0xe,0x1f) || between(code, 0x7f,0x9f); }\r\n    function newline(code) { return code == 0xa || code == 0xc || code == 0xd; }\r\n    function whitespace(code) { return newline(code) || code == 9 || code == 0x20; }\r\n    function badescape(code) { return newline(code) || isNaN(code); }\r\n    \r\n    // Note: I'm not yet acting smart enough to actually handle astral characters.\r\n    var maximumallowedcodepoint = 0x10ffff;\r\n    \r\n    // Add support for token lists (superclass of array)\r\n    var TokenList = cssSyntax.TokenList = function TokenList() {\r\n        var array = []; \r\n        array.toCSSString=cssSyntax.TokenListToCSSString;\r\n        return array;\r\n    }\r\n    var TokenListToCSSString = cssSyntax.TokenListToCSSString = function TokenListToCSSString(sep) {\r\n        if(sep) {\r\n            return this.map(function(o) { return o.toCSSString(); }).join(sep);\r\n        } else {\r\n            return this.asCSSString || (this.asCSSString = (\r\n                this.map(function(o) { return o.toCSSString(); }).join(\"/**/\")\r\n                    .replace(/( +\\/\\*\\*\\/ *| * | *\\/\\*\\*\\/ +)/g,\" \")\r\n                    .replace(/( +\\/\\*\\*\\/ *| * | *\\/\\*\\*\\/ +)/g,\" \")\r\n                    .replace(/(\\!|\\:|\\;|\\@|\\.|\\,|\\*|\\=|\\&|\\\\|\\/|\\<|\\>|\\[|\\{|\\(|\\]|\\}|\\)|\\|)\\/\\*\\*\\//g,\"$1\")\r\n                    .replace(/\\/\\*\\*\\/(\\!|\\:|\\;|\\@|\\.|\\,|\\*|\\=|\\&|\\\\|\\/|\\<|\\>|\\[|\\{|\\(|\\]|\\}|\\)|\\|)/g,\"$1\")\r\n            ));\r\n        }\r\n    }\r\n    \r\n    function tokenize(str, options) {\r\n        if(options == undefined) options = {transformFunctionWhitespace:false, scientificNotation:false};\r\n        var i = -1;\r\n        var tokens = new TokenList();\r\n        var state = \"data\";\r\n        var code;\r\n        var currtoken;\r\n    \r\n        // Line number information.\r\n        var line = 0;\r\n        var column = 0;\r\n        // The only use of lastLineLength is in reconsume().\r\n        var lastLineLength = 0;\r\n        var incrLineno = function() {\r\n            line += 1;\r\n            lastLineLength = column;\r\n            column = 0;\r\n        };\r\n        var locStart = {line:line, column:column};\r\n    \r\n        var next = function(num) { if(num === undefined) num = 1; return str.charCodeAt(i+num); };\r\n        var consume = function(num) {\r\n            if(num === undefined)\r\n                num = 1;\r\n            i += num;\r\n            code = str.charCodeAt(i);\r\n            if (newline(code)) incrLineno();\r\n            else column += num;\r\n            //console.log('Consume '+i+' '+String.fromCharCode(code) + ' 0x' + code.toString(16));\r\n            return true;\r\n        };\r\n        var reconsume = function() {\r\n            i -= 1;\r\n            if (newline(code)) {\r\n                line -= 1;\r\n                column = lastLineLength;\r\n            } else {\r\n                column -= 1;\r\n            }\r\n            locStart.line = line;\r\n            locStart.column = column;\r\n            return true;\r\n        };\r\n        var eof = function() { return i >= str.length; };\r\n        var donothing = function() {};\r\n        var emit = function(token) {\r\n            if(token) {\r\n                token.finish();\r\n            } else {\r\n                token = currtoken.finish();\r\n            }\r\n            if (options.loc === true) {\r\n                token.loc = {};\r\n                token.loc.start = {line:locStart.line, column:locStart.column};\r\n                locStart = {line: line, column: column};\r\n                token.loc.end = locStart;\r\n            }\r\n            tokens.push(token);\r\n            //console.log('Emitting ' + token);\r\n            currtoken = undefined;\r\n            return true;\r\n        };\r\n        var create = function(token) { currtoken = token; return true; };\r\n        var parseerror = function() { console.log(\"Parse error at index \" + i + \", processing codepoint 0x\" + code.toString(16) + \" in state \" + state + \".\");return true; };\r\n        var catchfire = function(msg) { console.log(\"MAJOR SPEC ERROR: \" + msg); return true;}\r\n        var switchto = function(newstate) {\r\n            state = newstate;\r\n            //console.log('Switching to ' + state);\r\n            return true;\r\n        };\r\n        var consumeEscape = function() {\r\n            // Assume the the current character is the \\\r\n            consume();\r\n            if(hexdigit(code)) {\r\n                // Consume 1-6 hex digits\r\n                var digits = [];\r\n                for(var total = 0; total < 6; total++) {\r\n                    if(hexdigit(code)) {\r\n                        digits.push(code);\r\n                        consume();\r\n                    } else { break; }\r\n                }\r\n                var value = parseInt(digits.map(String.fromCharCode).join(''), 16);\r\n                if( value > maximumallowedcodepoint ) value = 0xfffd;\r\n                // If the current char is whitespace, cool, we'll just eat it.\r\n                // Otherwise, put it back.\r\n                if(!whitespace(code)) reconsume();\r\n                return value;\r\n            } else {\r\n                return code;\r\n            }\r\n        };\r\n    \r\n        for(;;) {\r\n            if(i > str.length*2) return \"I'm infinite-looping!\";\r\n            consume();\r\n            switch(state) {\r\n            case \"data\":\r\n                if(whitespace(code)) {\r\n                    emit(new WhitespaceToken);\r\n                    while(whitespace(next())) consume();\r\n                }\r\n                else if(code == 0x22) switchto(\"double-quote-string\");\r\n                else if(code == 0x23) switchto(\"hash\");\r\n                else if(code == 0x27) switchto(\"single-quote-string\");\r\n                else if(code == 0x28) emit(new OpenParenToken);\r\n                else if(code == 0x29) emit(new CloseParenToken);\r\n                else if(code == 0x2b) {\r\n                    if(digit(next()) || (next() == 0x2e && digit(next(2)))) switchto(\"number\") && reconsume();\r\n                    else emit(new DelimToken(code));\r\n                }\r\n                else if(code == 0x2d) {\r\n                    if(next(1) == 0x2d && next(2) == 0x3e) consume(2) && emit(new CDCToken);\r\n                    else if(digit(next()) || (next(1) == 0x2e && digit(next(2)))) switchto(\"number\") && reconsume();\r\n                    else switchto('ident') && reconsume();\r\n                }\r\n                else if(code == 0x2e) {\r\n                    if(digit(next())) switchto(\"number\") && reconsume();\r\n                    else emit(new DelimToken(code));\r\n                }\r\n                else if(code == 0x2f) {\r\n                    if(next() == 0x2a) consume() && switchto(\"comment\");\r\n                    else emit(new DelimToken(code));\r\n                }\r\n                else if(code == 0x3a) emit(new ColonToken);\r\n                else if(code == 0x3b) emit(new SemicolonToken);\r\n                else if(code == 0x3c) {\r\n                    if(next(1) == 0x21 && next(2) == 0x2d && next(3) == 0x2d) consume(3) && emit(new CDOToken);\r\n                    else emit(new DelimToken(code));\r\n                }\r\n                else if(code == 0x40) switchto(\"at-keyword\");\r\n                else if(code == 0x5b) emit(new OpenSquareToken);\r\n                else if(code == 0x5c) {\r\n                    if(badescape(next())) parseerror() && emit(new DelimToken(code));\r\n                    else switchto('ident') && reconsume();\r\n                }\r\n                else if(code == 0x5d) emit(new CloseSquareToken);\r\n                else if(code == 0x7b) emit(new OpenCurlyToken);\r\n                else if(code == 0x7d) emit(new CloseCurlyToken);\r\n                else if(digit(code)) switchto(\"number\") && reconsume();\r\n                else if(code == 0x55 || code == 0x75) {\r\n                    if(next(1) == 0x2b && hexdigit(next(2))) consume() && switchto(\"unicode-range\");\r\n                    else switchto('ident') && reconsume();\r\n                }\r\n                else if(namestartchar(code)) switchto('ident') && reconsume();\r\n                else if(eof()) { emit(new EOFToken); return tokens; }\r\n                else emit(new DelimToken(code));\r\n                break;\r\n    \r\n            case \"double-quote-string\":\r\n                if(currtoken == undefined) create(new StringToken);\r\n    \r\n                if(code == 0x22) emit() && switchto(\"data\");\r\n                else if(eof()) parseerror() && emit() && switchto(\"data\") && reconsume();\r\n                else if(newline(code)) parseerror() && emit(new BadStringToken) && switchto(\"data\") && reconsume();\r\n                else if(code == 0x5c) {\r\n                    if(badescape(next())) parseerror() && emit(new BadStringToken) && switchto(\"data\");\r\n                    else if(newline(next())) consume();\r\n                    else currtoken.append(consumeEscape());\r\n                }\r\n                else currtoken.append(code);\r\n                break;\r\n    \r\n            case \"single-quote-string\":\r\n                if(currtoken == undefined) create(new StringToken);\r\n    \r\n                if(code == 0x27) emit() && switchto(\"data\");\r\n                else if(eof()) parseerror() && emit() && switchto(\"data\");\r\n                else if(newline(code)) parseerror() && emit(new BadStringToken) && switchto(\"data\") && reconsume();\r\n                else if(code == 0x5c) {\r\n                    if(badescape(next())) parseerror() && emit(new BadStringToken) && switchto(\"data\");\r\n                    else if(newline(next())) consume();\r\n                    else currtoken.append(consumeEscape());\r\n                }\r\n                else currtoken.append(code);\r\n                break;\r\n    \r\n            case \"hash\":\r\n                if(namechar(code)) create(new HashToken(code)) && switchto(\"hash-rest\");\r\n                else if(code == 0x5c) {\r\n                    if(badescape(next())) parseerror() && emit(new DelimToken(0x23)) && switchto(\"data\") && reconsume();\r\n                    else create(new HashToken(consumeEscape())) && switchto('hash-rest');\r\n                }\r\n                else emit(new DelimToken(0x23)) && switchto('data') && reconsume();\r\n                break;\r\n    \r\n            case \"hash-rest\":\r\n                if(namechar(code)) currtoken.append(code);\r\n                else if(code == 0x5c) {\r\n                    if(badescape(next())) parseerror() && emit() && switchto(\"data\") && reconsume();\r\n                    else currtoken.append(consumeEscape());\r\n                }\r\n                else emit() && switchto('data') && reconsume();\r\n                break;\r\n    \r\n            case \"comment\":\r\n                if(code == 0x2a) {\r\n                    if(next() == 0x2f) consume() && switchto('data');\r\n                    else donothing();\r\n                }\r\n                else if(eof()) parseerror() && switchto('data') && reconsume();\r\n                else donothing();\r\n                break;\r\n    \r\n            case \"at-keyword\":\r\n                if(code == 0x2d) {\r\n                    if(namestartchar(next()) || next()==0x2d) create(new AtKeywordToken(0x2d)) && switchto('at-keyword-rest');\r\n                    else if(next(1) == 0x5c && !badescape(next(2))) create(new AtKeywordtoken(0x2d)) && switchto('at-keyword-rest');\r\n                    else parseerror() && emit(new DelimToken(0x40)) && switchto('data') && reconsume();\r\n                }\r\n                else if(namestartchar(code)) create(new AtKeywordToken(code)) && switchto('at-keyword-rest');\r\n                else if(code == 0x5c) {\r\n                    if(badescape(next())) parseerror() && emit(new DelimToken(0x23)) && switchto(\"data\") && reconsume();\r\n                    else create(new AtKeywordToken(consumeEscape())) && switchto('at-keyword-rest');\r\n                }\r\n                else emit(new DelimToken(0x40)) && switchto('data') && reconsume();\r\n                break;\r\n    \r\n            case \"at-keyword-rest\":\r\n                if(namechar(code)) currtoken.append(code);\r\n                else if(code == 0x5c) {\r\n                    if(badescape(next())) parseerror() && emit() && switchto(\"data\") && reconsume();\r\n                    else currtoken.append(consumeEscape());\r\n                }\r\n                else emit() && switchto('data') && reconsume();\r\n                break;\r\n    \r\n            case \"ident\":\r\n                if(code == 0x2d) {\r\n                    if(namestartchar(next()) || next()==0x2d) create(new IdentifierToken(code)) && switchto('ident-rest');\r\n                    else if(next(1) == 0x5c && !badescape(next(2))) create(new IdentifierToken(code)) && switchto('ident-rest');\r\n                    else emit(new DelimToken(0x2d)) && switchto('data');\r\n                }\r\n                else if(namestartchar(code)) create(new IdentifierToken(code)) && switchto('ident-rest');\r\n                else if(code == 0x5c) {\r\n                    if(badescape(next())) parseerror() && switchto(\"data\") && reconsume();\r\n                    else create(new IdentifierToken(consumeEscape())) && switchto('ident-rest');\r\n                }\r\n                else catchfire(\"Hit the generic 'else' clause in ident state.\") && switchto('data') && reconsume();\r\n                break;\r\n    \r\n            case \"ident-rest\":\r\n                if(namechar(code)) currtoken.append(code);\r\n                else if(code == 0x5c) {\r\n                    if(badescape(next())) parseerror() && emit() && switchto(\"data\") && reconsume();\r\n                    else currtoken.append(consumeEscape());\r\n                }\r\n                else if(code == 0x28) {\r\n                    if(currtoken.ASCIImatch('url')) switchto('url');\r\n                    else emit(new FunctionToken(currtoken)) && switchto('data');\r\n                } \r\n                else if(whitespace(code) && options.transformFunctionWhitespace) switchto('transform-function-whitespace') && reconsume();\r\n                else emit() && switchto('data') && reconsume();\r\n                break;\r\n    \r\n            case \"transform-function-whitespace\":\r\n                if(whitespace(next())) donothing();\r\n                else if(code == 0x28) emit(new FunctionToken(currtoken)) && switchto('data');\r\n                else emit() && switchto('data') && reconsume();\r\n                break;\r\n    \r\n            case \"number\":\r\n                create(new NumberToken());\r\n    \r\n                if(code == 0x2d) {\r\n                    if(digit(next())) consume() && currtoken.append([0x2d,code]) && switchto('number-rest');\r\n                    else if(next(1) == 0x2e && digit(next(2))) consume(2) && currtoken.append([0x2d,0x2e,code]) && switchto('number-fraction');\r\n                    else switchto('data') && reconsume();\r\n                }\r\n                else if(code == 0x2b) {\r\n                    if(digit(next())) consume() && currtoken.append([0x2b,code]) && switchto('number-rest');\r\n                    else if(next(1) == 0x2e && digit(next(2))) consume(2) && currtoken.append([0x2b,0x2e,code]) && switchto('number-fraction');\r\n                    else switchto('data') && reconsume();\r\n                }\r\n                else if(digit(code)) currtoken.append(code) && switchto('number-rest');\r\n                else if(code == 0x2e) {\r\n                    if(digit(next())) consume() && currtoken.append([0x2e,code]) && switchto('number-fraction');\r\n                    else switchto('data') && reconsume();\r\n                }\r\n                else switchto('data') && reconsume();\r\n                break;\r\n    \r\n            case \"number-rest\":\r\n                if(digit(code)) currtoken.append(code);\r\n                else if(code == 0x2e) {\r\n                    if(digit(next())) consume() && currtoken.append([0x2e,code]) && switchto('number-fraction');\r\n                    else emit() && switchto('data') && reconsume();\r\n                }\r\n                else if(code == 0x25) emit(new PercentageToken(currtoken)) && switchto('data');\r\n                else if(code == 0x45 || code == 0x65) {\r\n                    if(digit(next())) consume() && currtoken.append([0x25,code]) && switchto('sci-notation');\r\n                    else if((next(1) == 0x2b || next(1) == 0x2d) && digit(next(2))) currtoken.append([0x25,next(1),next(2)]) && consume(2) && switchto('sci-notation');\r\n                    else create(new DimensionToken(currtoken,code)) && switchto('dimension');\r\n                }\r\n                else if(code == 0x2d) {\r\n                    if(namestartchar(next())) consume() && create(new DimensionToken(currtoken,[0x2d,code])) && switchto('dimension');\r\n                    else if(next(1) == 0x5c && badescape(next(2))) parseerror() && emit() && switchto('data') && reconsume();\r\n                    else if(next(1) == 0x5c) consume() && create(new DimensionToken(currtoken, [0x2d,consumeEscape()])) && switchto('dimension');\r\n                    else emit() && switchto('data') && reconsume();\r\n                }\r\n                else if(namestartchar(code)) create(new DimensionToken(currtoken, code)) && switchto('dimension');\r\n                else if(code == 0x5c) {\r\n                    if(badescape(next)) parseerror() && emit() && switchto('data') && reconsume();\r\n                    else create(new DimensionToken(currtoken,consumeEscape)) && switchto('dimension');\r\n                }\r\n                else emit() && switchto('data') && reconsume();\r\n                break;\r\n    \r\n            case \"number-fraction\":\r\n                currtoken.type = \"number\";\r\n    \r\n                if(digit(code)) currtoken.append(code);\r\n                else if(code == 0x25) emit(new PercentageToken(currtoken)) && switchto('data');\r\n                else if(code == 0x45 || code == 0x65) {\r\n                    if(digit(next())) consume() && currtoken.append([0x65,code]) && switchto('sci-notation');\r\n                    else if((next(1) == 0x2b || next(1) == 0x2d) && digit(next(2))) currtoken.append([0x65,next(1),next(2)]) && consume(2) && switchto('sci-notation');\r\n                    else create(new DimensionToken(currtoken,code)) && switchto('dimension');\r\n                }\r\n                else if(code == 0x2d) {\r\n                    if(namestartchar(next())) consume() && create(new DimensionToken(currtoken,[0x2d,code])) && switchto('dimension');\r\n                    else if(next(1) == 0x5c && badescape(next(2))) parseerror() && emit() && switchto('data') && reconsume();\r\n                    else if(next(1) == 0x5c) consume() && create(new DimensionToken(currtoken, [0x2d,consumeEscape()])) && switchto('dimension');\r\n                    else emit() && switchto('data') && reconsume();\r\n                }\r\n                else if(namestartchar(code)) create(new DimensionToken(currtoken, code)) && switchto('dimension');\r\n                else if(code == 0x5c) {\r\n                    if(badescape(next)) parseerror() && emit() && switchto('data') && reconsume();\r\n                    else create(new DimensionToken(currtoken,consumeEscape())) && switchto('dimension');\r\n                }\r\n                else emit() && switchto('data') && reconsume();\r\n                break;\r\n    \r\n            case \"dimension\":\r\n                if(namechar(code)) currtoken.append(code);\r\n                else if(code == 0x5c) {\r\n                    if(badescape(next())) parseerror() && emit() && switchto('data') && reconsume();\r\n                    else currtoken.append(consumeEscape());\r\n                }\r\n                else emit() && switchto('data') && reconsume();\r\n                break;\r\n    \r\n            case \"sci-notation\":\r\n                currtoken.type = \"number\";\r\n    \r\n                if(digit(code)) currtoken.append(code);\r\n                else emit() && switchto('data') && reconsume();\r\n                break;\r\n    \r\n            case \"url\":\r\n                if(eof()) parseerror() && emit(new BadURLToken) && switchto('data');\r\n                else if(code == 0x22) switchto('url-double-quote');\r\n                else if(code == 0x27) switchto('url-single-quote');\r\n                else if(code == 0x29) emit(new URLToken) && switchto('data');\r\n                else if(whitespace(code)) donothing();\r\n                else switchto('url-unquoted') && reconsume();\r\n                break;\r\n    \r\n            case \"url-double-quote\":\r\n                if(! (currtoken instanceof URLToken)) create(new URLToken);\r\n    \r\n                if(eof()) parseerror() && emit(new BadURLToken) && switchto('data');\r\n                else if(code == 0x22) switchto('url-end');\r\n                else if(newline(code)) parseerror() && switchto('bad-url');\r\n                else if(code == 0x5c) {\r\n                    if(newline(next())) consume();\r\n                    else if(badescape(next())) parseerror() && emit(new BadURLToken) && switchto('data') && reconsume();\r\n                    else currtoken.append(consumeEscape());\r\n                }\r\n                else currtoken.append(code);\r\n                break;\r\n    \r\n            case \"url-single-quote\":\r\n                if(! (currtoken instanceof URLToken)) create(new URLToken);\r\n    \r\n                if(eof()) parseerror() && emit(new BadURLToken) && switchto('data');\r\n                else if(code == 0x27) switchto('url-end');\r\n                else if(newline(code)) parseerror() && switchto('bad-url');\r\n                else if(code == 0x5c) {\r\n                    if(newline(next())) consume();\r\n                    else if(badescape(next())) parseerror() && emit(new BadURLToken) && switchto('data') && reconsume();\r\n                    else currtoken.append(consumeEscape());\r\n                }\r\n                else currtoken.append(code);\r\n                break;\r\n    \r\n            case \"url-end\":\r\n                if(eof()) parseerror() && emit(new BadURLToken) && switchto('data');\r\n                else if(whitespace(code)) donothing();\r\n                else if(code == 0x29) emit() && switchto('data');\r\n                else parseerror() && switchto('bad-url') && reconsume();\r\n                break;\r\n    \r\n            case \"url-unquoted\":\r\n                if(! (currtoken instanceof URLToken)) create(new URLToken);\r\n    \r\n                if(eof()) parseerror() && emit(new BadURLToken) && switchto('data');\r\n                else if(whitespace(code)) switchto('url-end');\r\n                else if(code == 0x29) emit() && switchto('data');\r\n                else if(code == 0x22 || code == 0x27 || code == 0x28 || nonprintable(code)) parseerror() && switchto('bad-url');\r\n                else if(code == 0x5c) {\r\n                    if(badescape(next())) parseerror() && switchto('bad-url');\r\n                    else currtoken.append(consumeEscape());\r\n                }\r\n                else currtoken.append(code);\r\n                break;\r\n    \r\n            case \"bad-url\":\r\n                if(eof()) parseerror() && emit(new BadURLToken) && switchto('data');\r\n                else if(code == 0x29) emit(new BadURLToken) && switchto('data');\r\n                else if(code == 0x5c) {\r\n                    if(badescape(next())) donothing();\r\n                    else consumeEscape();\r\n                }\r\n                else donothing();\r\n                break;\r\n    \r\n            case \"unicode-range\":\r\n                // We already know that the current code is a hexdigit.\r\n    \r\n                var start = [code], end = [code];\r\n    \r\n                for(var total = 1; total < 6; total++) {\r\n                    if(hexdigit(next())) {\r\n                        consume();\r\n                        start.push(code);\r\n                        end.push(code);\r\n                    }\r\n                    else break;\r\n                }\r\n    \r\n                if(next() == 0x3f) {\r\n                    for(;total < 6; total++) {\r\n                        if(next() == 0x3f) {\r\n                            consume();\r\n                            start.push(\"0\".charCodeAt(0));\r\n                            end.push(\"f\".charCodeAt(0));\r\n                        }\r\n                        else break;\r\n                    }\r\n                    emit(new UnicodeRangeToken(start,end)) && switchto('data');\r\n                }\r\n                else if(next(1) == 0x2d && hexdigit(next(2))) {\r\n                    consume();\r\n                    consume();\r\n                    end = [code];\r\n                    for(var total = 1; total < 6; total++) {\r\n                        if(hexdigit(next())) {\r\n                            consume();\r\n                            end.push(code);\r\n                        }\r\n                        else break;\r\n                    }\r\n                    emit(new UnicodeRangeToken(start,end)) && switchto('data');\r\n                }\r\n                else emit(new UnicodeRangeToken(start)) && switchto('data');\r\n                break;\r\n    \r\n            default:\r\n                catchfire(\"Unknown state '\" + state + \"'\");\r\n            }\r\n        }\r\n    }\r\n    \r\n    function stringFromCodeArray(arr) {\r\n        return String.fromCharCode.apply(null,arr.filter(function(e){return e;}));\r\n    }\r\n    \r\n    var CSSParserToken = cssSyntax.CSSParserToken = function CSSParserToken(options) { return this; }\r\n    CSSParserToken.prototype.tokenType = \"UNKNOWN\";\r\n    CSSParserToken.prototype.finish = function() { return this; }\r\n    CSSParserToken.prototype.toString = function() { return this.tokenType; }\r\n    CSSParserToken.prototype.toJSON = function() { return this.toString(); }\r\n    CSSParserToken.prototype.toCSSString = function() { return this.toString(); }\r\n    \r\n    var BadStringToken = cssSyntax.BadStringToken = function BadStringToken() { return this; }\r\n    BadStringToken.prototype = new CSSParserToken;\r\n    BadStringToken.prototype.tokenType = \"BADSTRING\";\r\n    BadStringToken.prototype.toCSSString = function() { return \"'\"; }\r\n    \r\n    var BadURLToken = cssSyntax.BadURLToken = function BadURLToken() { return this; }\r\n    BadURLToken.prototype = new CSSParserToken;\r\n    BadURLToken.prototype.tokenType = \"BADURL\";\r\n    BadURLToken.prototype.toCSSString = function() { return \"url(\"; }\r\n    \r\n    var WhitespaceToken = cssSyntax.WhitespaceToken = function WhitespaceToken() { return this; }\r\n    WhitespaceToken.prototype = new CSSParserToken;\r\n    WhitespaceToken.prototype.tokenType = \"WHITESPACE\";\r\n    WhitespaceToken.prototype.toString = function() { return \"WS\"; }\r\n    WhitespaceToken.prototype.toCSSString = function() { return \" \"; }\r\n    \r\n    var CDOToken = cssSyntax.CDOToken = function CDOToken() { return this; }\r\n    CDOToken.prototype = new CSSParserToken;\r\n    CDOToken.prototype.tokenType = \"CDO\";\r\n    CDOToken.prototype.toCSSString = function() { return \"<!--\"; }\r\n    \r\n    var CDCToken = cssSyntax.CDCToken = function CDCToken() { return this; }\r\n    CDCToken.prototype = new CSSParserToken;\r\n    CDCToken.prototype.tokenType = \"CDC\";\r\n    CDOToken.prototype.toCSSString = function() { return \"-->\"; }\r\n    \r\n    var ColonToken = cssSyntax.ColonToken = function ColonToken() { return this; }\r\n    ColonToken.prototype = new CSSParserToken;\r\n    ColonToken.prototype.tokenType = \":\";\r\n    \r\n    var SemicolonToken = cssSyntax.SemicolonToken = function SemicolonToken() { return this; }\r\n    SemicolonToken.prototype = new CSSParserToken;\r\n    SemicolonToken.prototype.tokenType = \";\";\r\n    \r\n    var OpenCurlyToken = cssSyntax.OpenCurlyToken = function OpenCurlyToken() { return this; }\r\n    OpenCurlyToken.prototype = new CSSParserToken;\r\n    OpenCurlyToken.prototype.tokenType = \"{\";\r\n    \r\n    var CloseCurlyToken = cssSyntax.CloseCurlyToken = function CloseCurlyToken() { return this; }\r\n    CloseCurlyToken.prototype = new CSSParserToken;\r\n    CloseCurlyToken.prototype.tokenType = \"}\";\r\n    \r\n    var OpenSquareToken = cssSyntax.OpenSquareToken = function OpenSquareToken() { return this; }\r\n    OpenSquareToken.prototype = new CSSParserToken;\r\n    OpenSquareToken.prototype.tokenType = \"[\";\r\n    \r\n    var CloseSquareToken = cssSyntax.CloseSquareToken = function CloseSquareToken() { return this; }\r\n    CloseSquareToken.prototype = new CSSParserToken;\r\n    CloseSquareToken.prototype.tokenType = \"]\";\r\n    \r\n    var OpenParenToken = cssSyntax.OpenParenToken = function OpenParenToken() { return this; }\r\n    OpenParenToken.prototype = new CSSParserToken;\r\n    OpenParenToken.prototype.tokenType = \"(\";\r\n    \r\n    var CloseParenToken = cssSyntax.CloseParenToken = function CloseParenToken() { return this; }\r\n    CloseParenToken.prototype = new CSSParserToken;\r\n    CloseParenToken.prototype.tokenType = \")\";\r\n    \r\n    var EOFToken = cssSyntax.EOFToken = function EOFToken() { return this; }\r\n    EOFToken.prototype = new CSSParserToken;\r\n    EOFToken.prototype.tokenType = \"EOF\";\r\n    EOFToken.prototype.toCSSString = function() { return \"\"; }\r\n    \r\n    var DelimToken = cssSyntax.DelimToken = function DelimToken(code) {\r\n        this.value = String.fromCharCode(code);\r\n        return this;\r\n    }\r\n    DelimToken.prototype = new CSSParserToken;\r\n    DelimToken.prototype.tokenType = \"DELIM\";\r\n    DelimToken.prototype.toString = function() { return \"DELIM(\"+this.value+\")\"; }\r\n    DelimToken.prototype.toCSSString = function() { return this.value; }\r\n    \r\n    var StringValuedToken = cssSyntax.StringValuedToken = function StringValuedToken() { return this; }\r\n    StringValuedToken.prototype = new CSSParserToken;\r\n    StringValuedToken.prototype.append = function(val) {\r\n        if(val instanceof Array) {\r\n            for(var i = 0; i < val.length; i++) {\r\n                this.value.push(val[i]);\r\n            }\r\n        } else {\r\n            this.value.push(val);\r\n        }\r\n        return true;\r\n    }\r\n    StringValuedToken.prototype.finish = function() {\r\n        this.value = this.valueAsString();\r\n        return this;\r\n    }\r\n    StringValuedToken.prototype.ASCIImatch = function(str) {\r\n        return this.valueAsString().toLowerCase() == str.toLowerCase();\r\n    }\r\n    StringValuedToken.prototype.valueAsString = function() {\r\n        if(typeof this.value == 'string') return this.value;\r\n        return stringFromCodeArray(this.value);\r\n    }\r\n    StringValuedToken.prototype.valueAsCodes = function() {\r\n        if(typeof this.value == 'string') {\r\n            var ret = [];\r\n            for(var i = 0; i < this.value.length; i++)\r\n                ret.push(this.value.charCodeAt(i));\r\n            return ret;\r\n        }\r\n        return this.value.filter(function(e){return e;});\r\n    }\r\n    \r\n    var IdentifierToken = cssSyntax.IdentifierToken = function IdentifierToken(val) {\r\n        this.value = new TokenList();\r\n        this.append(val);\r\n    }\r\n    IdentifierToken.prototype = new StringValuedToken;\r\n    IdentifierToken.prototype.tokenType = \"IDENT\";\r\n    IdentifierToken.prototype.toString = function() { return \"IDENT(\"+this.value+\")\"; }\r\n    IdentifierToken.prototype.toCSSString = function() { return this.value; }\r\n    \r\n    var FunctionToken = cssSyntax.FunctionToken = function FunctionToken(val) {\r\n        // These are always constructed by passing an IdentifierToken\r\n        this.value = val.finish().value;\r\n    }\r\n    FunctionToken.prototype = new StringValuedToken;\r\n    FunctionToken.prototype.tokenType = \"FUNCTION\";\r\n    FunctionToken.prototype.toString = function() { return \"FUNCTION(\"+this.value+\")\"; }\r\n    FunctionToken.prototype.toCSSString = function() { return this.value+\"(\"; }\r\n    \r\n    var AtKeywordToken = cssSyntax.AtKeywordToken = function AtKeywordToken(val) {\r\n        this.value = new TokenList();\r\n        this.append(val);\r\n    }\r\n    AtKeywordToken.prototype = new StringValuedToken;\r\n    AtKeywordToken.prototype.tokenType = \"AT-KEYWORD\";\r\n    AtKeywordToken.prototype.toString = function() { return \"AT(\"+this.value+\")\"; }\r\n    AtKeywordToken.prototype.toCSSString = function() { return \"@\"+this.value; }\r\n    \r\n    var HashToken = cssSyntax.HashToken = function HashToken(val) {\r\n        this.value = new TokenList();\r\n        this.append(val);\r\n    }\r\n    HashToken.prototype = new StringValuedToken;\r\n    HashToken.prototype.tokenType = \"HASH\";\r\n    HashToken.prototype.toString = function() { return \"HASH(\"+this.value+\")\"; }\r\n    HashToken.prototype.toCSSString = function() { return \"#\"+this.value; }\r\n    \r\n    var StringToken = cssSyntax.StringToken = function StringToken(val) {\r\n        this.value = new TokenList();\r\n        this.append(val);\r\n    }\r\n    StringToken.prototype = new StringValuedToken;\r\n    StringToken.prototype.tokenType = \"STRING\";\r\n    StringToken.prototype.toString = function() { return '\"'+this.value+'\"'; }\r\n    StringToken.prototype.toCSSString = function() { return '\"'+this.value.replace(/\"/g,'\\\\\"')+'\"'; } // TODO: improve string serialization?\r\n    \r\n    var URLToken = cssSyntax.URLToken = function URLToken(val) {\r\n        this.value = new TokenList();\r\n        this.append(val);\r\n    }\r\n    URLToken.prototype = new StringValuedToken;\r\n    URLToken.prototype.tokenType = \"URL\";\r\n    URLToken.prototype.toString = function() { return \"URL(\"+this.value+\")\"; }\r\n    URLToken.prototype.toCSSString = function() { return 'url(\"'+this.value.replace(/\"/g,'\\\\\"')+'\")'; } // TODO: improve string serialization?; }\r\n    \r\n    var NumberToken = cssSyntax.NumberToken = function NumberToken(val) {\r\n        this.value = new TokenList();\r\n        this.append(val);\r\n        this.type = \"integer\";\r\n    }\r\n    NumberToken.prototype = new StringValuedToken;\r\n    NumberToken.prototype.tokenType = \"NUMBER\";\r\n    NumberToken.prototype.toString = function() {\r\n        if(this.type == \"integer\")\r\n            return \"INT(\"+this.value+\")\";\r\n        return \"NUMBER(\"+this.value+\")\";\r\n    }\r\n    NumberToken.prototype.finish = function() {\r\n        this.repr = this.valueAsString();\r\n        this.value = this.repr * 1;\r\n        if(Math.abs(this.value) % 1 != 0) this.type = \"number\";\r\n        return this;\r\n    }\r\n    NumberToken.prototype.toCSSString = function() { return \"\"+this.value; }\r\n    \r\n    \r\n    var PercentageToken = cssSyntax.PercentageToken = function PercentageToken(val) {\r\n        // These are always created by passing a NumberToken as val\r\n        val.finish();\r\n        this.value = val.value;\r\n        this.repr = val.repr;\r\n    }\r\n    PercentageToken.prototype = new CSSParserToken;\r\n    PercentageToken.prototype.tokenType = \"PERCENTAGE\";\r\n    PercentageToken.prototype.toString = function() { return \"PERCENTAGE(\"+this.value+\")\"; }\r\n    PercentageToken.prototype.toCSSString = function() { return this.value+\"%\"; }\r\n    \r\n    var DimensionToken = cssSyntax.DimensionToken = function DimensionToken(val,unit) {\r\n        // These are always created by passing a NumberToken as the val\r\n        val.finish();\r\n        this.num = val.value;\r\n        this.unit = [];\r\n        this.repr = val.repr;\r\n        this.append(unit);\r\n    }\r\n    DimensionToken.prototype = new CSSParserToken;\r\n    DimensionToken.prototype.tokenType = \"DIMENSION\";\r\n    DimensionToken.prototype.toString = function() { return \"DIM(\"+this.num+\",\"+this.unit+\")\"; }\r\n    DimensionToken.prototype.toCSSString = function() { return this.num+this.unit; }\r\n    DimensionToken.prototype.append = function(val) {\r\n        if(val instanceof Array) {\r\n            for(var i = 0; i < val.length; i++) {\r\n                this.unit.push(val[i]);\r\n            }\r\n        } else {\r\n            this.unit.push(val);\r\n        }\r\n        return true;\r\n    }\r\n    DimensionToken.prototype.finish = function() {\r\n        this.unit = stringFromCodeArray(this.unit);\r\n        this.repr += this.unit;\r\n        return this;\r\n    }\r\n    \r\n    var UnicodeRangeToken = cssSyntax.UnicodeRangeToken = function UnicodeRangeToken(start,end) {\r\n        // start and end are array of char codes, completely finished\r\n        start = parseInt(stringFromCodeArray(start),16);\r\n        if(end === undefined) end = start + 1;\r\n        else end = parseInt(stringFromCodeArray(end),16);\r\n    \r\n        if(start > maximumallowedcodepoint) end = start;\r\n        if(end < start) end = start;\r\n        if(end > maximumallowedcodepoint) end = maximumallowedcodepoint;\r\n    \r\n        this.start = start;\r\n        this.end = end;\r\n        return this;\r\n    }\r\n    UnicodeRangeToken.prototype = new CSSParserToken;\r\n    UnicodeRangeToken.prototype.tokenType = \"UNICODE-RANGE\";\r\n    UnicodeRangeToken.prototype.toCSSString = function() { return \"¿\"; }\r\n    UnicodeRangeToken.prototype.toString = function() {\r\n        if(this.start+1 == this.end)\r\n            return \"UNICODE-RANGE(\"+this.start.toString(16).toUpperCase()+\")\";\r\n        if(this.start < this.end)\r\n            return \"UNICODE-RANGE(\"+this.start.toString(16).toUpperCase()+\"-\"+this.end.toString(16).toUpperCase()+\")\";\r\n        return \"UNICODE-RANGE()\";\r\n    }\r\n    UnicodeRangeToken.prototype.contains = function(code) {\r\n        return code >= this.start && code < this.end;\r\n    }\r\n    \r\n    \r\n    // Exportation.\r\n    cssSyntax.tokenize = tokenize;\r\n\t\r\n\t//\r\n\t// css parser\r\n\t//\r\n    \r\n    var TokenList = cssSyntax.TokenList;\r\n    function parse(tokens) {\r\n        // FREMY's ADDITION:\r\n        // You can give a string to parse, it will tokenize it for you\r\n        // { this break module boundaries, but who cares? }\r\n        if(typeof(tokens)==\"string\") {\r\n            tokens = cssSyntax.tokenize(tokens);\r\n        }\r\n        \r\n        var mode = 'top-level';\r\n        var i = -1;\r\n        var token;\r\n    \r\n        var stylesheet = new Stylesheet;\r\n        var stack = [stylesheet];\r\n        var rule = stack[0];\r\n    \r\n        var consume = function(advance) {\r\n            if(advance === undefined) advance = 1;\r\n            i += advance;\r\n            if(i < tokens.length)\r\n                token = tokens[i];\r\n            else\r\n                token = new EOFToken;\r\n            return true;\r\n        };\r\n        var reprocess = function() {\r\n            i--;\r\n            return true;\r\n        }\r\n        var next = function() {\r\n            return tokens[i+1];\r\n        };\r\n        var switchto = function(newmode) {\r\n            if(newmode === undefined) {\r\n                if(rule.fillType !== '')\r\n                    mode = rule.fillType;\r\n                else if(rule.type == 'STYLESHEET')\r\n                    mode = 'top-level'\r\n                else { console.log(\"Unknown rule-type while switching to current rule's content mode: \",rule); mode = ''; }\r\n            } else {\r\n                mode = newmode;\r\n            }\r\n            return true;\r\n        }\r\n        var push = function(newRule) {\r\n            rule = newRule;\r\n            stack.push(rule);\r\n            return true;\r\n        }\r\n        var parseerror = function(msg) {\r\n            console.log(\"Parse error at token \" + i + \": \" + token + \".\\n\" + msg);\r\n            return true;\r\n        }\r\n        var pop = function() {\r\n            var oldrule = stack.pop();\r\n            rule = stack[stack.length - 1];\r\n            rule.append(oldrule);\r\n            return true;\r\n        }\r\n        var discard = function() {\r\n            stack.pop();\r\n            rule = stack[stack.length - 1];\r\n            return true;\r\n        }\r\n        var finish = function() {\r\n            while(stack.length > 1) {\r\n                pop();\r\n            }\r\n        }\r\n    \r\n        for(;;) {\r\n            consume();\r\n    \r\n            switch(mode) {\r\n            case \"top-level\":\r\n                switch(token.tokenType) {\r\n                case \"CDO\":\r\n                case \"CDC\":\r\n                case \"WHITESPACE\": break;\r\n                case \"AT-KEYWORD\": push(new AtRule(token.value)) && switchto('at-rule'); break;\r\n                case \"{\": parseerror(\"Attempt to open a curly-block at top-level.\") && consumeAPrimitive(); break;\r\n                case \"EOF\": finish(); return stylesheet;\r\n                default: push(new StyleRule) && switchto('selector') && reprocess();\r\n                }\r\n                break;\r\n    \r\n            case \"at-rule\":\r\n                switch(token.tokenType) {\r\n                case \";\": pop() && switchto(); break;\r\n                case \"{\":\r\n                    if(rule.fillType !== '') switchto(rule.fillType);\r\n                    else parseerror(\"Attempt to open a curly-block in a statement-type at-rule.\") && discard() && switchto('next-block') && reprocess();\r\n                    break;\r\n                case \"EOF\": finish(); return stylesheet;\r\n                default: rule.appendPrelude(consumeAPrimitive());\r\n                }\r\n                break;\r\n    \r\n            case \"rule\":\r\n                switch(token.tokenType) {\r\n                case \"WHITESPACE\": break;\r\n                case \"}\": pop() && switchto(); break;\r\n                case \"AT-KEYWORD\": push(new AtRule(token.value)) && switchto('at-rule'); break;\r\n                case \"EOF\": finish(); return stylesheet;\r\n                default: push(new StyleRule) && switchto('selector') && reprocess();\r\n                }\r\n                break;\r\n    \r\n            case \"selector\":\r\n                switch(token.tokenType) {\r\n                case \"{\": switchto('declaration'); break;\r\n                case \"EOF\": discard() && finish(); return stylesheet;\r\n                default: rule.appendSelector(consumeAPrimitive()); \r\n                }\r\n                break;\r\n    \r\n            case \"declaration\":\r\n                switch(token.tokenType) {\r\n                case \"WHITESPACE\":\r\n                case \";\": break;\r\n                case \"}\": pop() && switchto(); break;\r\n                case \"AT-RULE\": push(new AtRule(token.value)) && switchto('at-rule'); break;\r\n                case \"IDENT\": push(new Declaration(token.value)) && switchto('after-declaration-name'); break;\r\n                case \"EOF\": finish(); return stylesheet;\r\n                default: parseerror() && discard() && switchto('next-declaration');\r\n                }\r\n                break;\r\n    \r\n            case \"after-declaration-name\":\r\n                switch(token.tokenType) {\r\n                case \"WHITESPACE\": break;\r\n                case \":\": switchto('declaration-value'); break;\r\n                case \";\": parseerror(\"Incomplete declaration - semicolon after property name.\") && discard() && switchto(); break;\r\n                case \"EOF\": discard() && finish(); return stylesheet;\r\n                default: parseerror(\"Invalid declaration - additional token after property name\") && discard() && switchto('next-declaration');\r\n                }\r\n                break;\r\n    \r\n            case \"declaration-value\":\r\n                switch(token.tokenType) {\r\n                case \"DELIM\":\r\n                    if(token.value == \"!\" && next().tokenType == 'IDENT' && next().value.toLowerCase() == \"important\") {\r\n                        consume();\r\n                        rule.important = true;\r\n                        switchto('declaration-end');\r\n                    } else {\r\n                        rule.append(token);\r\n                    }\r\n                    break;\r\n                case \";\": pop() && switchto(); break;\r\n                case \"}\": pop() && pop() && switchto(); break;\r\n                case \"EOF\": finish(); return stylesheet;\r\n                default: rule.append(consumeAPrimitive());\r\n                }\r\n                break;\r\n    \r\n            case \"declaration-end\":\r\n                switch(token.tokenType) {\r\n                case \"WHITESPACE\": break;\r\n                case \";\": pop() && switchto(); break;\r\n                case \"}\": pop() && pop() && switchto(); break;\r\n                case \"EOF\": finish(); return stylesheet;\r\n                default: parseerror(\"Invalid declaration - additional token after !important.\") && discard() && switchto('next-declaration');\r\n                }\r\n                break;\r\n    \r\n            case \"next-block\":\r\n                switch(token.tokenType) {\r\n                case \"{\": consumeAPrimitive() && switchto(); break;\r\n                case \"EOF\": finish(); return stylesheet;\r\n                default: consumeAPrimitive(); break;\r\n                }\r\n                break;\r\n    \r\n            case \"next-declaration\":\r\n                switch(token.tokenType) {\r\n                case \";\": switchto('declaration'); break;\r\n                case \"}\": switchto('declaration') && reprocess(); break;\r\n                case \"EOF\": finish(); return stylesheet;\r\n                default: consumeAPrimitive(); break;\r\n                }\r\n                break;\r\n    \r\n            default:\r\n                // If you hit this, it's because one of the switchto() calls is typo'd.\r\n                console.log('Unknown parsing mode: ' + mode);\r\n                return;\r\n            }\r\n        }\r\n    \r\n        function consumeAPrimitive() {\r\n            switch(token.tokenType) {\r\n            case \"(\":\r\n            case \"[\":\r\n            case \"{\": return consumeASimpleBlock();\r\n            case \"FUNCTION\": return consumeAFunc();\r\n            default: return token;\r\n            }\r\n        }\r\n    \r\n        function consumeASimpleBlock() {\r\n            var endingTokenType = {\"(\":\")\", \"[\":\"]\", \"{\":\"}\"}[token.tokenType];\r\n            var block = new SimpleBlock(token.tokenType);\r\n    \r\n            for(;;) {\r\n                consume();\r\n                switch(token.tokenType) {\r\n                case \"EOF\":\r\n                case endingTokenType: return block;\r\n                default: block.append(consumeAPrimitive());\r\n                }\r\n            }\r\n        }\r\n    \r\n        function consumeAFunc() {\r\n            var func = new Func(token.value);\r\n            var arg = new FuncArg();\r\n    \r\n            for(;;) {\r\n                consume();\r\n                switch(token.tokenType) {\r\n                case \"EOF\":\r\n                case \")\": func.append(arg); return func;\r\n                case \"DELIM\":\r\n                    if(token.value == \",\") {\r\n                        func.append(arg);\r\n                        arg = new FuncArg();\r\n                    } else {\r\n                        arg.append(token);\r\n                    }\r\n                    break;\r\n                default: arg.append(consumeAPrimitive());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    var CSSParserRule = cssSyntax.CSSParserRule = function CSSParserRule() { return this; }\r\n\tCSSParserRule.prototype.fillType = '';\r\n    CSSParserRule.prototype.tokenType = 'NOT_A_TOKEN';\r\n    CSSParserRule.prototype.toString = function(indent) {\r\n        return JSON.stringify(this.toJSON(),null,indent);\r\n    }\r\n    CSSParserRule.prototype.append = function(val) {\r\n        this.value.push(val);\r\n        return this;\r\n    }\r\n    \r\n    var Stylesheet = cssSyntax.Stylesheet = function Stylesheet() {\r\n        this.value = new TokenList();\r\n        return this;\r\n    }\r\n    Stylesheet.prototype = new CSSParserRule;\r\n    Stylesheet.prototype.type = \"STYLESHEET\";\r\n    Stylesheet.prototype.toJSON = function() {\r\n        return {type:'stylesheet', value: this.value.map(function(e){return e.toJSON();})};\r\n    }\r\n    Stylesheet.prototype.toCSSString = function() { return this.value.toCSSString(\"\\n\"); }\r\n    \r\n    var AtRule = cssSyntax.AtRule = function AtRule(name) {\r\n        this.name = name;\r\n        this.prelude = new TokenList();\r\n        this.value = new TokenList();\r\n        if(name in AtRule.registry)\r\n            this.fillType = AtRule.registry[name];\r\n        return this;\r\n    }\r\n    AtRule.prototype = new CSSParserRule;\r\n    AtRule.prototype.type = \"AT-RULE\";\r\n    AtRule.prototype.appendPrelude = function(val) {\r\n        this.prelude.push(val);\r\n        return this;\r\n    }\r\n    AtRule.prototype.toJSON = function() {\r\n        return {type:'at', name:this.name, prelude:this.prelude.map(function(e){return e.toJSON();}), value:this.value.map(function(e){return e.toJSON();})};\r\n    }\r\n    AtRule.prototype.toCSSString = function() { \r\n        if(this.fillType != '') {\r\n            return \"@\" + this.name + \" \" + this.prelude.toCSSString() + '{' + this.value.toCSSString() + '} '; \r\n        } else {\r\n            return \"@\" + this.name + \" \" + this.prelude.toCSSString() + '; '; \r\n        }\r\n    }\r\n    AtRule.registry = {\r\n        'import': '',\r\n        'media': 'rule',\r\n        'font-face': 'declaration',\r\n        'page': 'declaration',\r\n        'keyframes': 'rule',\r\n        'namespace': '',\r\n        'counter-style': 'declaration',\r\n        'supports': 'rule',\r\n        'document': 'rule',\r\n        'font-feature-values': 'declaration',\r\n        'viewport': '',\r\n        'region-style': 'rule'\r\n    };\r\n    \r\n    var StyleRule = cssSyntax.StyleRule = function StyleRule() {\r\n        this.selector = new TokenList();\r\n        this.value = new TokenList();\r\n        return this;\r\n    }\r\n    StyleRule.prototype = new CSSParserRule;\r\n    StyleRule.prototype.type = \"STYLE-RULE\";\r\n    StyleRule.prototype.fillType = 'declaration';\r\n    StyleRule.prototype.appendSelector = function(val) {\r\n        this.selector.push(val);\r\n        return this;\r\n    }\r\n    StyleRule.prototype.toJSON = function() {\r\n        return {type:'selector', selector:this.selector.map(function(e){return e.toJSON();}), value:this.value.map(function(e){return e.toJSON();})};\r\n    }\r\n    StyleRule.prototype.toCSSString = function() { return this.selector.toCSSString() + '{' + this.value.toCSSString() + '} '; }\r\n\r\n    \r\n    var Declaration = cssSyntax.Declaration = function Declaration(name) {\r\n        this.name = name;\r\n        this.value = new TokenList();\r\n        return this;\r\n    }\r\n    Declaration.prototype = new CSSParserRule;\r\n    Declaration.prototype.type = \"DECLARATION\";\r\n    Declaration.prototype.toJSON = function() {\r\n        return {type:'declaration', name:this.name, value:this.value.map(function(e){return e.toJSON();})};\r\n    }\r\n    Declaration.prototype.toCSSString = function() { return this.name + ':' + this.value.toCSSString() + '; '; }\r\n    \r\n    var SimpleBlock = cssSyntax.SimpleBlock = function SimpleBlock(type) {\r\n        this.name = type;\r\n        this.value = new TokenList();\r\n        return this;\r\n    }\r\n    SimpleBlock.prototype = new CSSParserRule;\r\n    SimpleBlock.prototype.type = \"BLOCK\";\r\n    SimpleBlock.prototype.toJSON = function() {\r\n        return {type:'block', name:this.name, value:this.value.map(function(e){return e.toJSON();})};\r\n    }\r\n    SimpleBlock.prototype.toCSSString = function() {\r\n        switch(this.name) {\r\n            case \"(\":\r\n                return \"(\" + this.value.toCSSString() + \")\";\r\n                \r\n            case \"[\":\r\n                return \"[\" + this.value.toCSSString() + \"]\";\r\n                \r\n            case \"{\":\r\n                return \"{\" + this.value.toCSSString() + \"}\";\r\n            \r\n            default: //best guess\r\n                return this.name + this.value.toCSSString() + this.name;\r\n        }\r\n    }\r\n    \r\n    var Func = cssSyntax.Func = function Func(name) {\r\n        this.name = name;\r\n        this.value = new TokenList();\r\n        return this;\r\n    }\r\n    Func.prototype = new CSSParserRule;\r\n    Func.prototype.type = \"FUNCTION\";\r\n    Func.prototype.toJSON = function() {\r\n        return {type:'func', name:this.name, value:this.value.map(function(e){return e.toJSON();})};\r\n    }\r\n    Func.prototype.toCSSString = function() {\r\n        return this.name+'('+this.value.toCSSString().slice(0,-2)+')';\r\n    }\r\n    \r\n    var FuncArg = cssSyntax.FuncArg = function FuncArg() {\r\n        this.value = new TokenList();\r\n        return this;\r\n    }\r\n    FuncArg.prototype = new CSSParserRule;\r\n    FuncArg.prototype.type = \"FUNCTION-ARG\";\r\n    FuncArg.prototype.toJSON = function() {\r\n        return this.value.map(function(e){return e.toJSON();});\r\n    }\r\n    FuncArg.prototype.toCSSString = function() {\r\n        return this.value.toCSSString()+', ';\r\n    }\r\n    \r\n    // Exportation.\r\n    cssSyntax.parse = parse;\r\n\treturn cssSyntax;\r\n\r\n}());\nrequire.define('src/core/css-syntax.js');","module.exports = (function(window, document) { \"use strict\";\r\n\r\n\trequire('src/core/polyfill-dom-console.js');\r\n\r\n\t//\r\n\t// some other basic om code\r\n\t//\r\n\tvar domEvents = {\r\n\t\t\r\n\t\t//\r\n\t\t// the following functions are about event cloning\r\n\t\t//\r\n\t\tcloneMouseEvent: function cloneMouseEvent(e) {\r\n\t\t\tvar evt = document.createEvent(\"MouseEvent\");\r\n\t\t\tevt.initMouseEvent( \r\n\t\t\t\te.type, \r\n\t\t\t\te.canBubble||e.bubbles, \r\n\t\t\t\te.cancelable, \r\n\t\t\t\te.view, \r\n\t\t\t\te.detail, \r\n\t\t\t\te.screenX, \r\n\t\t\t\te.screenY, \r\n\t\t\t\te.clientX, \r\n\t\t\t\te.clientY, \r\n\t\t\t\te.ctrlKey, \r\n\t\t\t\te.altKey, \r\n\t\t\t\te.shiftKey, \r\n\t\t\t\te.metaKey, \r\n\t\t\t\te.button, \r\n\t\t\t\te.relatedTarget\r\n\t\t\t);\r\n\t\t\treturn evt;\r\n\t\t},\r\n\t\t\r\n\t\tcloneKeyboardEvent: function cloneKeyboardEvent(e) {\r\n\t\t\t// TODO: this doesn't work cross-browser...\r\n\t\t\t// see https://gist.github.com/termi/4654819/ for the huge code\r\n\t\t\treturn domEvents.cloneCustomEvent(e);\r\n\t\t},\r\n\t\t\r\n\t\tcloneCustomEvent: function cloneCustomEvent(e) {\r\n\t\t\tvar ne = document.createEvent(\"CustomEvent\");\r\n\t\t\tne.initCustomEvent(e.type, e.canBubble||e.bubbles, e.cancelable, \"detail\" in e ? e.detail : e);\r\n\t\t\tfor(var prop in e) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif(e[prop] != ne[prop] && e[prop] != e.target) {\r\n\t\t\t\t\t\ttry { ne[prop] = e[prop]; }\r\n\t\t\t\t\t\tcatch (ex) { Object.defineProperty(ne,prop,{get:function() { return e[prop]} }) }\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch(ex) {}\r\n\t\t\t}\r\n\t\t\treturn ne;\r\n\t\t},\r\n\t\t\r\n\t\tcloneEvent: function cloneEvent(e) {\r\n\t\t\t\r\n\t\t\tif(e instanceof MouseEvent) {\r\n\t\t\t\treturn domEvents.cloneMouseEvent(e);\r\n\t\t\t} else if(e instanceof KeyboardEvent) {\r\n\t\t\t\treturn domEvents.cloneKeyboardEvent(e);\r\n\t\t\t} else {\r\n\t\t\t\treturn domEvents.cloneCustomEvent(e);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// allows you to drop event support to any class easily\r\n\t\t//\r\n\t\tEventTarget: {\r\n\t\t\timplementsIn: function(eventClass, static_class) {\r\n\t\t\t\t\r\n\t\t\t\tif(!static_class && typeof(eventClass)==\"function\") eventClass=eventClass.prototype;\r\n\t\t\t\t\r\n\t\t\t\teventClass.dispatchEvent = domEvents.EventTarget.prototype.dispatchEvent;\r\n\t\t\t\teventClass.addEventListener = domEvents.EventTarget.prototype.addEventListener;\r\n\t\t\t\teventClass.removeEventListener = domEvents.EventTarget.prototype.removeEventListener;\r\n\t\t\t\t\r\n\t\t\t},\r\n\t\t\tprototype: {}\r\n\t\t}\r\n\t\t\r\n\t};\r\n\r\n\tdomEvents.EventTarget.prototype.addEventListener = function(eventType,f) {\r\n\t\tif(!this.eventListeners) this.eventListeners=[];\r\n\t\t\r\n\t\tvar ls = (this.eventListeners[eventType] || (this.eventListeners[eventType]=[]));\r\n\t\tif(ls.indexOf(f)==-1) {\r\n\t\t\tls.push(f);\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n\tdomEvents.EventTarget.prototype.removeEventListener = function(eventType,f) {\r\n\t\tif(!this.eventListeners) this.eventListeners=[];\r\n\r\n\t\tvar ls = (this.eventListeners[eventType] || (this.eventListeners[eventType]=[])), i;\r\n\t\tif((i=ls.indexOf(f))!==-1) {\r\n\t\t\tls.splice(i,1);\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n\tdomEvents.EventTarget.prototype.dispatchEvent = function(event_or_type) {\r\n\t\tif(!this.eventListeners) this.eventListeners=[];\r\n\t\t\r\n\t\t// abort quickly when no listener has been set up\r\n\t\tif(typeof(event_or_type) == \"string\") {\r\n\t\t\tif(!this.eventListeners[event_or_type] || this.eventListeners[event_or_type].length==0) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif(!this.eventListeners[event_or_type.type] || this.eventListeners[event_or_type.type].length==0) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// convert the event\r\n\t\tvar event = event_or_type;\r\n\t\tfunction setUpPropertyForwarding(e,ee,key) {\r\n\t\t\tObject.defineProperty(ee,key,{\r\n\t\t\t\tget:function() {\r\n\t\t\t\t\tvar v = e[key]; \r\n\t\t\t\t\tif(typeof(v)==\"function\") {\r\n\t\t\t\t\t\treturn v.bind(e);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn v;\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tset:function(v) {\r\n\t\t\t\t\te[key] = v;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\tfunction setUpTarget(e,v) {\r\n\t\t\ttry { Object.defineProperty(e,\"target\",{get:function() {return v}}); }\r\n\t\t\tcatch(ex) {}\r\n\t\t\tfinally {\r\n\t\t\t\t\r\n\t\t\t\tif(e.target !== v) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar ee = Object.create(Object.getPrototypeOf(e));\r\n\t\t\t\t\tee = setUpTarget(ee,v);\r\n\t\t\t\t\tfor(key in e) {\r\n\t\t\t\t\t\tif(key != \"target\") setUpPropertyForwarding(e,ee,key);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn ee;\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn e;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// try to set the target\r\n\t\tif(typeof(event)==\"object\") {\r\n\t\t\ttry { event=setUpTarget(event,this); } catch(ex) {}\r\n\t\t\t\r\n\t\t} else if(typeof(event)==\"string\") {\r\n\t\t\tevent = document.createEvent(\"CustomEvent\");\r\n\t\t\tevent.initCustomEvent(event_or_type, /*canBubble:*/ true, /*cancelable:*/ false, /*detail:*/this);\r\n\t\t\ttry { event=setUpTarget(event,this); } catch(ex) {}\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"dispatchEvent expect an Event object or a string containing the event type\");\r\n\t\t}\r\n\t\t\r\n\t\t// call all listeners\r\n\t\tvar ls = (this.eventListeners[event.type] || (this.eventListeners[event.type]=[]));\r\n\t\tfor(var i=ls.length; i--;) {\r\n\t\t\ttry { \r\n\t\t\t\tls[i](event);\r\n\t\t\t} catch(ex) {\r\n\t\t\t\tsetImmediate(function() { throw ex; });\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn event.isDefaultPrevented;\r\n\t}\r\n\t\r\n\treturn domEvents;\r\n\t\r\n})(window, document);\nrequire.define('src/core/dom-events.js');","/////////////////////////////////////////////////////////////////\r\n////                                                         ////\r\n////                 prerequirements of qSL                  ////\r\n////                                                         ////\r\n/////////////////////////////////////////////////////////////////\r\n////                                                         ////\r\n////   Please note that I require querySelectorAll to work   ////\r\n////                                                         ////\r\n////   See http://github.com/termi/CSS_selector_engine/      ////\r\n////   for a polyfill for older browsers                     ////\r\n////                                                         ////\r\n/////////////////////////////////////////////////////////////////\r\n\r\n// TODO: improve event streams\r\n// - look for a few optimizations ideas in gecko/webkit\r\n// - use arrays in CompositeEventStream to avoid nested debouncings\r\nmodule.exports = (function(window, document) { \"use strict\";\r\n\r\n\t///\r\n\t/// event stream implementation\r\n\t/// please note this is required to 'live update' the qSA requests\r\n\t///\r\n\tfunction EventStream(connect, disconnect, reconnect) {\r\n\t\tvar self=this;\r\n\t\t\r\n\t\t// validate arguments\r\n\t\tif(!disconnect) disconnect=function(){};\r\n\t\tif(!reconnect) reconnect=connect;\r\n\t\t\r\n\t\t// high-level states\r\n\t\tvar isConnected=false;\r\n\t\tvar isDisconnected=false;\r\n\t\tvar shouldDisconnect=false;\r\n\t\t\r\n\t\t// global variables\r\n\t\tvar callback=null;\r\n\t\tvar yieldEvent = function() {\r\n\t\t\t\r\n\t\t\t// call the callback function, and pend disposal\r\n\t\t\tshouldDisconnect=true;\r\n\t\t\ttry { callback && callback(self); } catch(ex) { setImmediate(function() { throw ex; }); }\r\n\t\t\t\r\n\t\t\t// if no action was taken, dispose\r\n\t\t\tif(shouldDisconnect) { dispose(); }\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t// export the interface\r\n\t\tvar schedule = this.schedule = function(newCallback) {\r\n\t\t\r\n\t\t\t// do not allow to schedule on disconnected event streams\r\n\t\t\tif(isDisconnected) { throw new Error(\"Cannot schedule on a disconnected event stream\"); }\r\n\t\t\t\r\n\t\t\t// do not allow to schedule on already scheduled event streams\r\n\t\t\tif(isConnected && !shouldDisconnect) { throw new Error(\"Cannot schedule on an already-scheduled event stream\"); }\r\n\t\t\t\r\n\t\t\t// schedule the new callback\r\n\t\t\tcallback=newCallback; shouldDisconnect=false;\r\n\t\t\t\r\n\t\t\t// reconnect to the stream\r\n\t\t\tif(isConnected) {\r\n\t\t\t\treconnect(yieldEvent);\r\n\t\t\t} else {\r\n\t\t\t\tconnect(yieldEvent);\r\n\t\t\t\tisConnected=true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tvar dispose = this.dispose = function() {\r\n\t\t\r\n\t\t\t// do not allow to dispose non-connected streams\r\n\t\t\tif(isConnected) {\r\n\t\t\t\r\n\t\t\t\t// disconnect & save resources\r\n\t\t\t\tdisconnect(); \r\n\t\t\t\tself=null; yieldEvent=null; callback=null; \r\n\t\t\t\tisConnected=false; isDisconnected=true; shouldDisconnect=false;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t///\r\n\t/// call a function every frame\r\n\t///\r\n\tfunction AnimationFrameEventStream(options) {\r\n\t\t\r\n\t\t// flag that says whether the observer is still needed or not\r\n\t\tvar rid = 0;\r\n\t\t\t\r\n\t\t// start the event stream\r\n\t\tEventStream.call(\r\n\t\t\tthis, \r\n\t\t\tfunction connect(yieldEvent) { rid = requestAnimationFrame(yieldEvent); },\r\n\t\t\tfunction disconnect() { cancelAnimationFrame(rid); }\r\n\t\t);\r\n\t\t\r\n\t}\r\n\r\n\t///\r\n\t/// call a function every timeout\r\n\t///\r\n\tfunction TimeoutEventStream(options) {\r\n\t\t\r\n\t\t// flag that says whether the observer is still needed or not\r\n\t\tvar rid = 0; var timeout=(typeof(options)==\"number\") ? (+options) : (\"timeout\" in options ? +options.timeout : 333);\r\n\t\t\t\r\n\t\t// start the event stream\r\n\t\tEventStream.call(\r\n\t\t\tthis, \r\n\t\t\tfunction connect(yieldEvent) { rid = setTimeout(yieldEvent, timeout); },\r\n\t\t\tfunction disconnect() { clearTimeout(rid); }\r\n\t\t);\r\n\t\t\r\n\t}\r\n\r\n\t///\r\n\t/// call a function every time the mouse moves\r\n\t///\r\n\tfunction MouseEventStream() {\r\n\t\tvar self=this; var pointermove = ((\"PointerEvent\" in window) ? \"pointermove\" : ((\"MSPointerEvent\" in window) ? \"MSPointerMove\" : \"mousemove\"));\r\n\r\n\t\t// flag that says whether the event is still observed or not\r\n\t\tvar scheduled = false; var interval=0;\r\n\t\t\r\n\t\t// handle the synchronous nature of mutation events\r\n\t\tvar yieldEvent=null;\r\n\t\tvar yieldEventDelayed = function() {\r\n\t\t\tif(scheduled) return;\r\n\t\t\twindow.removeEventListener(pointermove, yieldEventDelayed, true);\r\n\t\t\tscheduled = requestAnimationFrame(yieldEvent);\r\n\t\t}\r\n\t\t\r\n\t\t// start the event stream\r\n\t\tEventStream.call(\r\n\t\t\tthis, \r\n\t\t\tfunction connect(newYieldEvent) {\r\n\t\t\t\tyieldEvent=newYieldEvent;\r\n\t\t\t\twindow.addEventListener(pointermove, yieldEventDelayed, true);\r\n\t\t\t},\r\n\t\t\tfunction disconnect() { \r\n\t\t\t\twindow.removeEventListener(pointermove, yieldEventDelayed, true);\r\n\t\t\t\tcancelAnimationFrame(scheduled); yieldEventDelayed=null; yieldEvent=null; scheduled=false;\r\n\t\t\t},\r\n\t\t\tfunction reconnect(newYieldEvent) { \r\n\t\t\t\tyieldEvent=newYieldEvent; scheduled=false;\r\n\t\t\t\twindow.addEventListener(pointermove, yieldEventDelayed, true);\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t}\r\n\r\n\t///\r\n\t/// call a function every time the mouse is clicked/unclicked\r\n\t///\r\n\tfunction MouseButtonEventStream() {\r\n\t\tvar self=this; \r\n\t\tvar pointerup = ((\"PointerEvent\" in window) ? \"pointerup\" : ((\"MSPointerEvent\" in window) ? \"MSPointerUp\" : \"mouseup\"));\r\n\t\tvar pointerdown = ((\"PointerEvent\" in window) ? \"pointerdown\" : ((\"MSPointerEvent\" in window) ? \"MSPointerDown\" : \"mousedown\"));\r\n\r\n\t\t// flag that says whether the event is still observed or not\r\n\t\tvar scheduled = false; var interval=0;\r\n\t\t\r\n\t\t// handle the synchronous nature of mutation events\r\n\t\tvar yieldEvent=null;\r\n\t\tvar yieldEventDelayed = function() {\r\n\t\t\tif(scheduled) return;\r\n\t\t\twindow.removeEventListener(pointerup, yieldEventDelayed, true);\r\n\t\t\twindow.removeEventListener(pointerdown, yieldEventDelayed, true);\r\n\t\t\tscheduled = requestAnimationFrame(yieldEvent);\r\n\t\t}\r\n\t\t\r\n\t\t// start the event stream\r\n\t\tEventStream.call(\r\n\t\t\tthis, \r\n\t\t\tfunction connect(newYieldEvent) {\r\n\t\t\t\tyieldEvent=newYieldEvent;\r\n\t\t\t\twindow.addEventListener(pointerup, yieldEventDelayed, true);\r\n\t\t\t\twindow.addEventListener(pointerdown, yieldEventDelayed, true);\r\n\t\t\t},\r\n\t\t\tfunction disconnect() { \r\n\t\t\t\twindow.removeEventListener(pointerup, yieldEventDelayed, true);\r\n\t\t\t\twindow.removeEventListener(pointerdown, yieldEventDelayed, true);\r\n\t\t\t\tcancelAnimationFrame(scheduled); yieldEventDelayed=null; yieldEvent=null; scheduled=false;\r\n\t\t\t},\r\n\t\t\tfunction reconnect(newYieldEvent) { \r\n\t\t\t\tyieldEvent=newYieldEvent; scheduled=false;\r\n\t\t\t\twindow.addEventListener(pointerup, yieldEventDelayed, true);\r\n\t\t\t\twindow.addEventListener(pointerdown, yieldEventDelayed, true);\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t}\r\n\r\n\t///\r\n\t/// call a function whenever the DOM is modified\r\n\t///\r\n\tvar DOMUpdateEventStream;\r\n\tif(\"MutationObserver\" in window) {\r\n\t\tDOMUpdateEventStream = function DOMUpdateEventStream(options) {\r\n\t\t\t \r\n\t\t\t// configuration of the observer\r\n\t\t\tif(options) {\r\n\t\t\t\tvar target = \"target\" in options ? options.target : document.documentElement;\r\n\t\t\t\tvar config = { \r\n\t\t\t\t\tsubtree: \"subtree\" in options ? !!options.subtree : true, \r\n\t\t\t\t\tattributes: \"attributes\" in options ? !!options.attributes : true, \r\n\t\t\t\t\tchildList: \"childList\" in options ? !!options.childList : true, \r\n\t\t\t\t\tcharacterData: \"characterData\" in options ? !!options.characterData : false\r\n\t\t\t\t};\r\n\t\t\t} else {\r\n\t\t\t\tvar target = document.documentElement;\r\n\t\t\t\tvar config = { \r\n\t\t\t\t\tsubtree: true, \r\n\t\t\t\t\tattributes: true, \r\n\t\t\t\t\tchildList: true, \r\n\t\t\t\t\tcharacterData: false\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t// start the event stream\r\n\t\t\tvar observer = null;\r\n\t\t\tEventStream.call(\r\n\t\t\t\tthis, \r\n\t\t\t\tfunction connect(yieldEvent) { if(config) { observer=new MutationObserver(yieldEvent); observer.observe(target,config); target=null; config=null; } },\r\n\t\t\t\tfunction disconnect() { observer && observer.disconnect(); observer=null; },\r\n\t\t\t\tfunction reconnect() { observer.takeRecords(); }\r\n\t\t\t);\r\n\r\n\t\t}\r\n\t} else if(\"MutationEvent\" in window) {\r\n\t\tDOMUpdateEventStream = function DOMUpdateEventStream(options) {\r\n\t\t\tvar self=this;\r\n\r\n\t\t\t// flag that says whether the event is still observed or not\r\n\t\t\tvar scheduled = false;\r\n\t\t\t\r\n\t\t\t// configuration of the observer\r\n\t\t\tif(options) {\r\n\t\t\t\tvar target = \"target\" in options ? options.target : document.documentElement;\r\n\t\t\t} else {\r\n\t\t\t\tvar target = document.documentElement;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// handle the synchronous nature of mutation events\r\n\t\t\tvar yieldEvent=null;\r\n\t\t\tvar yieldEventDelayed = function() {\r\n\t\t\t\tif(scheduled || !yieldEventDelayed) return;\r\n\t\t\t\tdocument.removeEventListener(\"DOMContentLoaded\", yieldEventDelayed, false);\r\n\t\t\t\tdocument.removeEventListener(\"DOMContentLoaded\", yieldEventDelayed, false);\r\n\t\t\t\ttarget.removeEventListener(\"DOMSubtreeModified\", yieldEventDelayed, false);\r\n\t\t\t\tscheduled = requestAnimationFrame(yieldEvent);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// start the event stream\r\n\t\t\tEventStream.call(\r\n\t\t\t\tthis, \r\n\t\t\t\tfunction connect(newYieldEvent) {\r\n\t\t\t\t\tyieldEvent=newYieldEvent;\r\n\t\t\t\t\tdocument.addEventListener(\"DOMContentLoaded\", yieldEventDelayed, false);\r\n\t\t\t\t\ttarget.addEventListener(\"DOMSubtreeModified\", yieldEventDelayed, false);\r\n\t\t\t\t},\r\n\t\t\t\tfunction disconnect() { \r\n\t\t\t\t\tdocument.removeEventListener(\"DOMContentLoaded\", yieldEventDelayed, false);\r\n\t\t\t\t\ttarget.removeEventListener(\"DOMSubtreeModified\", yieldEventDelayed, false);\r\n\t\t\t\t\tcancelAnimationFrame(scheduled); yieldEventDelayed=null; yieldEvent=null; scheduled=false;\r\n\t\t\t\t},\r\n\t\t\t\tfunction reconnect(newYieldEvent) { \r\n\t\t\t\t\tyieldEvent=newYieldEvent; scheduled=false;\r\n\t\t\t\t\ttarget.addEventListener(\"DOMSubtreeModified\", yieldEventDelayed, false);\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t\t\r\n\t\t}\r\n\t} else {\r\n\t\tDOMUpdateEventStream = AnimationFrameEventStream;\r\n\t}\r\n\r\n\t///\r\n\t/// call a function every time the focus shifts\r\n\t///\r\n\tfunction FocusEventStream() {\r\n\t\tvar self=this;\r\n\t\t\r\n\t\t// handle the filtering nature of focus events\r\n\t\tvar yieldEvent=null; var previousActiveElement=null; var previousHasFocus=false; var rid=0;\r\n\t\tvar yieldEventDelayed = function() {\r\n\t\t\t\r\n\t\t\t// if the focus didn't change\r\n\t\t\tif(previousActiveElement==document.activeElement && previousHasFocus==document.hasFocus()) {\r\n\t\t\t\t\r\n\t\t\t\t// then do not generate an event\r\n\t\t\t\tsetTimeout(yieldEventDelayed, 333); // focus that didn't move is expected to stay\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// else, generate one & save config\r\n\t\t\t\tpreviousActiveElement=document.activeElement;\r\n\t\t\t\tpreviousHasFocus=document.hasFocus();\r\n\t\t\t\tyieldEvent();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// start the event stream\r\n\t\tEventStream.call(\r\n\t\t\tthis, \r\n\t\t\tfunction connect(newYieldEvent) {\r\n\t\t\t\tyieldEvent=newYieldEvent;\r\n\t\t\t\trid=setTimeout(yieldEventDelayed, 500); // let the document load\r\n\t\t\t},\r\n\t\t\tfunction disconnect() { \r\n\t\t\t\tclearTimeout(rid); yieldEventDelayed=null; yieldEvent=null; rid=0;\r\n\t\t\t},\r\n\t\t\tfunction reconnect(newYieldEvent) { \r\n\t\t\t\tyieldEvent=newYieldEvent;\r\n\t\t\t\trid=setTimeout(yieldEventDelayed, 100); // focus by tab navigation moves fast\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t}\r\n\r\n\t///\r\n\t/// composite event stream\r\n\t/// because sometimes you need more than one event source\r\n\t///\r\n\tfunction CompositeEventStream(stream1, stream2) {\r\n\t\tvar self=this;\r\n\t\t\r\n\t\t// fields\r\n\t\tvar yieldEvent=null; var s1=false, s2=false;\r\n\t\tvar yieldEventWrapper=function(s) { \r\n\t\t\tif(s==stream1) s1=true;\r\n\t\t\tif(s==stream2) s2=true;\r\n\t\t\tif(s1&&s2) return;\r\n\t\t\tyieldEvent(self);\r\n\t\t}\r\n\t\t\r\n\t\t// start the event stream\r\n\t\tEventStream.call(\r\n\t\t\tthis, \r\n\t\t\tfunction connect(newYieldEvent) {\r\n\t\t\t\tyieldEvent=newYieldEvent;\r\n\t\t\t\tstream1.schedule(yieldEventWrapper);\r\n\t\t\t\tstream2.schedule(yieldEventWrapper);\r\n\t\t\t},\r\n\t\t\tfunction disconnect() { \r\n\t\t\t\tstream1.dispose();\r\n\t\t\t\tstream2.dispose();\r\n\t\t\t},\r\n\t\t\tfunction reconnect(newYieldEvent) { \r\n\t\t\t\tyieldEvent=newYieldEvent;\r\n\t\t\t\ts1 && stream1.schedule(yieldEventWrapper);\r\n\t\t\t\ts2 && stream2.schedule(yieldEventWrapper);\r\n\t\t\t\ts1 = s2 = false;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\t\r\n\treturn {\r\n\t\tEventStream:                EventStream,\r\n\t\tAnimationFrameEventStream:  AnimationFrameEventStream,\r\n\t\tTimeoutEventStream:         TimeoutEventStream,\r\n\t\tMouseEventStream:           MouseEventStream,\r\n\t\tMouseButtonEventStream:     MouseButtonEventStream,\r\n\t\tDOMUpdateEventStream:       DOMUpdateEventStream,\r\n\t\tFocusEventStream:           FocusEventStream,\r\n\t\tCompositeEventStream:       CompositeEventStream\r\n\t};\r\n\r\n})(window, document);\nrequire.define('src/core/dom-experimental-event-streams.js');","/////////////////////////////////////////////////////////////////\r\n////                                                         ////\r\n////                  Implementation of qSL                  ////\r\n////                                                         ////\r\n/////////////////////////////////////////////////////////////////\r\n////                                                         ////\r\n////   Please note that I require querySelectorAll to work   ////\r\n////                                                         ////\r\n////   See http://github.com/termi/CSS_selector_engine/      ////\r\n////   for a polyfill for older browsers                     ////\r\n////                                                         ////\r\n/////////////////////////////////////////////////////////////////\r\n\r\nmodule.exports = (function(window, document) { \"use strict\";\r\n\r\n\t// import dependencies\r\n\tvar eventStreams = require('src/core/dom-experimental-event-streams.js'),\r\n\t    DOMUpdateEventStream = eventStreams.DOMUpdateEventStream,\r\n\t\tAnimationFrameEventStream = eventStreams.AnimationFrameEventStream,\r\n\t\tCompositeEventStream = eventStreams.CompositeEventStream,\r\n\t\tFocusEventStream = eventStreams.FocusEventStream,\r\n\t\tMouseButtonEventStream = eventStreams.MouseButtonEventStream,\r\n\t\tTimeoutEventStream = eventStreams.TimeoutEventStream,\r\n\t\tMouseEventStream = eventStreams.MouseEventStream;\r\n\r\n\t///\r\n\t/// the live querySelectorAll implementation\r\n\t///\r\n\tfunction querySelectorLive(selector, handler, root) {\r\n\t\t\r\n\t\t// restrict the selector coverage to some part of the DOM only\r\n\t\tvar root = root || document;\r\n\t\t\r\n\t\t// TODO: make use of \"mutatedAncestorElement\" to update only elements inside the mutated zone\r\n\t\t\r\n\t\tvar currentElms = [];\r\n\t\tvar loop = function loop(eventStream) {\r\n\t\t\t\r\n\t\t\t// schedule next run\r\n\t\t\teventStream.schedule(loop);\r\n\t\t\t\r\n\t\t\t// update elements matching the selector\r\n\t\t\tvar newElms = [];\r\n\t\t\tvar oldElms = currentElms.slice(0);\r\n\t\t\tvar temps = root.querySelectorAll(selector);\r\n\t\t\tfor(var i=newElms.length=temps.length; i;) { newElms.push(temps[--i]); }\r\n\t\t\tcurrentElms = newElms.slice(0); temps=null;\r\n\t\t\t\r\n\t\t\t// first let's clear all elements that have been removed from the document\r\n\t\t\toldElms = oldElms.filter(function(e) {\r\n\t\t\t\t\r\n\t\t\t\t// check whether the current element is still there\r\n\t\t\t\tvar isStillInDocument = (\r\n\t\t\t\t\te===document.documentElement \r\n\t\t\t\t\t|| document.documentElement.contains(e)\r\n\t\t\t\t);\r\n\t\t\t\t\r\n\t\t\t\tif(isStillInDocument) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// NEED_COMPARE: we will compare this element to the new list\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// DELETE: raise onremoved, pop old elements\r\n\t\t\t\t\ttry { handler.onremoved && handler.onremoved(e); } catch(ex) { setImmediate(function() {throw ex})}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\t// now pop and match until both lists are exhausted\r\n\t\t\t// (we use the fact the returned elements are in document order)\r\n\t\t\tvar el1 = oldElms.pop();\r\n\t\t\tvar el2 = newElms.pop();\r\n\t\t\twhile(el1 || el2) {\r\n\t\t\t\tif(el1===el2) {\r\n\t\t\t\t\r\n\t\t\t\t\t// MATCH: pop both elements\r\n\t\t\t\t\tel1 = oldElms.pop();\r\n\t\t\t\t\tel2 = newElms.pop();\r\n\t\t\t\t\t\r\n\t\t\t\t} else if (el2 && /*el1 is after el2*/(!el1||(el2.compareDocumentPosition(el1) & (1|2|8|32))===0)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// INSERT: raise onadded, pop new elements\r\n\t\t\t\t\ttry { handler.onadded && handler.onadded(el2); } catch(ex) { setImmediate(function() {throw ex})}\r\n\t\t\t\t\tel2 = newElms.pop();\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t\t// DELETE: raise onremoved, pop old elements\r\n\t\t\t\t\ttry { handler.onremoved && handler.onremoved(el1); } catch(ex) { setImmediate(function() {throw ex})}\r\n\t\t\t\t\tel1 = oldElms.pop();\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t};\r\n\t\t\r\n\t\t// use the event stream that best matches our needs\r\n\t\tvar simpleSelector = selector.replace(/:(dir|lang|root|empty|blank|nth-child|nth-last-child|first-child|last-child|only-child|nth-of-type|nth-last-of-child|fist-of-type|last-of-type|only-of-type|not|matches|default)\\b/gi,'')\r\n\t\tvar eventStream; if(simpleSelector.indexOf(':') == -1) {\r\n\t\t\t\r\n\t\t\t// static stuff only\r\n\t\t\teventStream = new DOMUpdateEventStream(root); \r\n\t\t\t\r\n\t\t} else {\r\n\t\t\t\r\n\t\t\t// dynamic stuff too\r\n\t\t\teventStream = new DOMUpdateEventStream(root); \r\n\t\t\tif(DOMUpdateEventStream != AnimationFrameEventStream) {\r\n\t\t\t\r\n\t\t\t\t// detect the presence of focus-related pseudo-classes\r\n\t\t\t\tvar reg = /:(focus|active)\\b/gi;\r\n\t\t\t\tif(reg.test(simpleSelector)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// mouse events should be listened\r\n\t\t\t\t\teventStream = new CompositeEventStream(\r\n\t\t\t\t\t\tnew FocusEventStream(),\r\n\t\t\t\t\t\teventStream\r\n\t\t\t\t\t);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// simplify simpleSelector\r\n\t\t\t\t\tvar reg = /:(focus)\\b/gi;\r\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, ''); // :active has other hooks\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// detect the presence of mouse-button-related pseudo-classes\r\n\t\t\t\tvar reg = /:(active)\\b/gi;\r\n\t\t\t\tif(reg.test(simpleSelector)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// mouse events should be listened\r\n\t\t\t\t\teventStream = new CompositeEventStream(\r\n\t\t\t\t\t\tnew MouseButtonEventStream(),\r\n\t\t\t\t\t\teventStream\r\n\t\t\t\t\t);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// simplify simpleSelector\r\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// detect the presence of user input pseudo-classes\r\n\t\t\t\tvar reg = /:(target|checked|indeterminate|valid|invalid|in-range|out-of-range|user-error)\\b/gi;\r\n\t\t\t\tif(reg.test(simpleSelector)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// slowly dynamic stuff do happen\r\n\t\t\t\t\teventStream = new CompositeEventStream(\r\n\t\t\t\t\t\tnew TimeoutEventStream(250),\r\n\t\t\t\t\t\teventStream\r\n\t\t\t\t\t);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// simplify simpleSelector\r\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\r\n\r\n\t\t\t\t\tvar reg = /:(any-link|link|visited|local-link|enabled|disabled|read-only|read-write|required|optional)\\b/gi;\r\n\t\t\t\t\t// simplify simpleSelector\r\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// detect the presence of nearly-static pseudo-classes\r\n\t\t\t\tvar reg = /:(any-link|link|visited|local-link|enabled|disabled|read-only|read-write|required|optional)\\b/gi;\r\n\t\t\t\tif(reg.test(simpleSelector)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// nearly static stuff do happen\r\n\t\t\t\t\teventStream = new CompositeEventStream(\r\n\t\t\t\t\t\tnew TimeoutEventStream(333),\r\n\t\t\t\t\t\teventStream\r\n\t\t\t\t\t);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// simplify simpleSelector\r\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// detect the presence of mouse-related pseudo-classes\r\n\t\t\t\tvar reg = /:(hover)\\b/gi;\r\n\t\t\t\tif(reg.test(simpleSelector)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// mouse events should be listened\r\n\t\t\t\t\teventStream = new CompositeEventStream(\r\n\t\t\t\t\t\tnew MouseEventStream(),\r\n\t\t\t\t\t\teventStream\r\n\t\t\t\t\t);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// simplify simpleSelector\r\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// detect the presence of unknown pseudo-classes\r\n\t\t\t\tif(simpleSelector.indexOf(':') !== -1) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// other stuff do happen, too (let's give up on events)\r\n\t\t\t\t\teventStream = new AnimationFrameEventStream(); \r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t// start handling changes\r\n\t\tloop(eventStream);\r\n\t\t\r\n\t}\r\n\t\r\n\treturn querySelectorLive;\r\n\t\r\n})(window, document);\nrequire.define('src/core/dom-query-selector-live.js');","// TODO: comment about the 'no_auto_stylesheet_detection' flag?\r\n\r\nmodule.exports = (function(window, document) { \"use strict\";\r\n\t\r\n\t// import dependencies\r\n\trequire('src/core/polyfill-dom-console.js');\r\n\tvar cssSyntax = require('src/core/css-syntax.js');\r\n\tvar domEvents = require('src/core/dom-events.js');\r\n\tvar querySelectorLive = require('src/core/dom-query-selector-live.js');\r\n\t\r\n\t// define the module\r\n\tvar cssCascade = {\r\n\t\t\r\n\t\t//\r\n\t\t// returns the priority of a unique selector (NO COMMA!)\r\n\t\t// { the return value is an integer, with the same formula as webkit }\r\n\t\t//\r\n\t\tcomputeSelectorPriorityOf: function computeSelectorPriorityOf(selector) {\r\n\t\t\tif(typeof selector == \"string\") selector = cssSyntax.parse(selector+\"{}\").value[0].selector;\r\n\t\t\t\r\n\t\t\tvar numberOfIDs = 0;\r\n\t\t\tvar numberOfClasses = 0;\r\n\t\t\tvar numberOfTags = 0;\r\n\t\t\t\r\n\t\t\t// TODO: improve this parser, or find one on the web\r\n\t\t\tfor(var i = 0; i < selector.length; i++) {\r\n\t\t\t\t\r\n\t\t\t\tif(selector[i] instanceof cssSyntax.IdentifierToken) {\r\n\t\t\t\t\tnumberOfTags++;\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(selector[i] instanceof cssSyntax.DelimToken) {\r\n\t\t\t\t\tif(selector[i].value==\".\") {\r\n\t\t\t\t\t\tnumberOfClasses++; i++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(selector[i] instanceof cssSyntax.ColonToken) {\r\n\t\t\t\t\tif(selector[++i] instanceof cssSyntax.ColonToken) {\r\n\t\t\t\t\t\tnumberOfTags++; i++;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else if((selector[i] instanceof cssSyntax.Func) && (/^(not|matches)$/i).test(selector[i].name)) {\r\n\t\t\t\t\t\tvar nestedPriority = this.computeSelectorPriorityOf(selector[i].value[0].value);\r\n\t\t\t\t\t\tnumberOfTags += nestedPriority % 256; nestedPriority /= 256;\r\n\t\t\t\t\t\tnumberOfClasses += nestedPriority % 256; nestedPriority /= 256;\r\n\t\t\t\t\t\tnumberOfIDs += nestedPriority;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tnumberOfClasses++;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(selector[i] instanceof cssSyntax.SimpleBlock) {\r\n\t\t\t\t\tif(selector[i].name==\"[\") {\r\n\t\t\t\t\t\tnumberOfClasses++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(selector[i] instanceof cssSyntax.HashToken) {\r\n\t\t\t\t\tnumberOfIDs++;\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// TODO: stop ignoring unknown symbols?\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(numberOfIDs>255) numberOfIds=255;\r\n\t\t\tif(numberOfClasses>255) numberOfClasses=255;\r\n\t\t\tif(numberOfTags>255) numberOfTags=255;\r\n\t\t\t\r\n\t\t\treturn ((numberOfIDs*256)+numberOfClasses)*256+numberOfTags;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// returns an array of the css rules matching an element\r\n\t\t//\r\n\t\tfindAllMatchingRules: function findAllMatchingRules(element) {\r\n\t\t\t\r\n\t\t\t// let's look for new results if needed...\r\n\t\t\tvar results = [];\r\n\t\t\t\r\n\t\t\t// walk the whole stylesheet...\r\n\t\t\tvar visit = function(rules) {\r\n\t\t\t\tfor(var r = rules.length; r--; ) {\r\n\t\t\t\t\tvar rule = rules[r]; \r\n\t\t\t\t\t\r\n\t\t\t\t\t// media queries hook\r\n\t\t\t\t\tif(rule.disabled) continue;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(rule instanceof cssSyntax.StyleRule) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// consider each selector independently\r\n\t\t\t\t\t\tvar subrules = rule.subRules || cssCascade.splitRule(rule);\r\n\t\t\t\t\t\tfor(var sr = subrules.length; sr--; ) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tvar isMatching = false;\r\n\t\t\t\t\t\t\tvar selector = subrules[sr].selector.toCSSString();\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tif(element.matches) isMatching=element.matches(selector)\r\n\t\t\t\t\t\t\t\telse if(element.matchesSelector) isMatching=element.matchesSelector(selector)\r\n\t\t\t\t\t\t\t\telse if(element.oMatchesSelector) isMatching=element.oMatchesSelector(selector)\r\n\t\t\t\t\t\t\t\telse if(element.msMatchesSelector) isMatching=element.msMatchesSelector(selector)\r\n\t\t\t\t\t\t\t\telse if(element.mozMatchesSelector) isMatching=element.mozMatchesSelector(selector)\r\n\t\t\t\t\t\t\t\telse if(element.webkitMatchesSelector) isMatching=element.webkitMatchesSelector(selector)\r\n\t\t\t\t\t\t\t\telse { throw new Error(\"Your browser does not support element.matchesSelector, which is required for a script.\") }\r\n\t\t\t\t\t\t\t} catch(ex) { cssConsole.warn(\"Invalid selector \" + selector); }\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif(isMatching) { results.push(subrules[sr]); }\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else if(rule instanceof cssSyntax.AtRule && rule.name==\"media\") {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvisit(rule.value);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor(var s=cssCascade.stylesheets.length; s--; ) {\r\n\t\t\t\tvar rules = cssCascade.stylesheets[s];\r\n\t\t\t\tvisit(rules);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn results;\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// returns an array of the css rules matching a pseudo-element\r\n\t\t//\r\n\t\tfindAllMatchingRulesWithPseudo: function findAllMatchingRules(element,pseudo) {\r\n\t\t\t\r\n\t\t\t// let's look for new results if needed...\r\n\t\t\tvar results = [];\r\n\t\t\t\r\n\t\t\t// walk the whole stylesheet...\r\n\t\t\tvar visit = function(rules) {\r\n\t\t\t\tfor(var r = rules.length; r--; ) {\r\n\t\t\t\t\tvar rule = rules[r]; \r\n\t\t\t\t\t\r\n\t\t\t\t\t// media queries hook\r\n\t\t\t\t\tif(rule.disabled) continue;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(rule instanceof cssSyntax.StyleRule) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// consider each selector independently\r\n\t\t\t\t\t\tvar subrules = rule.subRules || cssCascade.splitRule(rule);\r\n\t\t\t\t\t\tfor(var sr = subrules.length; sr--; ) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// WE ONLY ACCEPT SELECTORS ENDING WITH THE PSEUDO\r\n\t\t\t\t\t\t\tvar selector = subrules[sr].selector.toCSSString().trim().replace(/\\/\\*\\*\\//,'');\r\n\t\t\t\t\t\t\tvar newLength = selector.length-pseudo.length-1;\r\n\t\t\t\t\t\t\tif(newLength<=0) continue;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif(selector.lastIndexOf('::'+pseudo)==newLength-1) {\r\n\t\t\t\t\t\t\t\tselector = selector.substr(0,newLength-1);\r\n\t\t\t\t\t\t\t} else if(selector.lastIndexOf(':'+pseudo)==newLength) {\r\n\t\t\t\t\t\t\t\tselector = selector.substr(0,newLength);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// look if the selector matches\r\n\t\t\t\t\t\t\tvar isMatching = false;\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tif(element.matches) isMatching=element.matches(selector)\r\n\t\t\t\t\t\t\t\telse if(element.matchesSelector) isMatching=element.matchesSelector(selector)\r\n\t\t\t\t\t\t\t\telse if(element.oMatchesSelector) isMatching=element.oMatchesSelector(selector)\r\n\t\t\t\t\t\t\t\telse if(element.msMatchesSelector) isMatching=element.msMatchesSelector(selector)\r\n\t\t\t\t\t\t\t\telse if(element.mozMatchesSelector) isMatching=element.mozMatchesSelector(selector)\r\n\t\t\t\t\t\t\t\telse if(element.webkitMatchesSelector) isMatching=element.webkitMatchesSelector(selector)\r\n\t\t\t\t\t\t\t\telse { throw new Error(\"wft u no element.matchesSelector?\") }\r\n\t\t\t\t\t\t\t} catch(ex) { debugger; setImmediate(function() { throw ex; }) }\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif(isMatching) { results.push(subrules[sr]); }\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else if(rule instanceof cssSyntax.AtRule && rule.name==\"media\") {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvisit(rule.value);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor(var s=cssCascade.stylesheets.length; s--; ) {\r\n\t\t\t\tvar rules = cssCascade.stylesheets[s];\r\n\t\t\t\tvisit(rules);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn results;\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// a list of all properties supported by the current browser\r\n\t\t//\r\n\t\tallCSSProperties: null,\r\n\t\tgetAllCSSProperties: function getAllCSSProperties() {\r\n\t\t\t\r\n\t\t\tif(this.allCSSProperties) return this.allCSSProperties;\r\n\t\t\t\r\n\t\t\t// get all claimed properties\r\n\t\t\tvar s = getComputedStyle(document.documentElement); var ps = new Array(s.length);\r\n\t\t\tfor(var i=s.length; i--; ) {\r\n\t\t\t\tps[i] = s[i];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// FIX A BUG WHERE WEBKIT DOESN'T REPORT ALL PROPERTIES\r\n\t\t\tif(ps.indexOf('content')==-1) {ps.push('content');}\r\n\t\t\tif(ps.indexOf('counter-reset')==-1) {\r\n\t\t\t\t\r\n\t\t\t\tps.push('counter-reset');\r\n\t\t\t\tps.push('counter-increment');\r\n\t\t\t\t\r\n\t\t\t\t// FIX A BUG WHERE WEBKIT RETURNS SHIT FOR THE COMPUTED VALUE OF COUNTER-RESET\r\n\t\t\t\tcssCascade.computationUnsafeProperties['counter-reset']=true;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// save in a cache for faster access the next times\r\n\t\t\treturn this.allCSSProperties = ps;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t// \r\n\t\t// those properties are not safe for computation->specified round-tripping\r\n\t\t// \r\n\t\tcomputationUnsafeProperties: {\r\n\t\t\t\"bottom\"          : true,\r\n\t\t\t\"direction\"       : true,\r\n\t\t\t\"display\"         : true,\r\n\t\t\t\"font-size\"       : true,\r\n\t\t\t\"height\"          : true,\r\n\t\t\t\"left\"            : true,\r\n\t\t\t\"line-height\"     : true,\r\n\t\t\t\"margin-left\"     : true,\r\n\t\t\t\"margin-right\"    : true,\r\n\t\t\t\"margin-bottom\"   : true,\r\n\t\t\t\"margin-top\"      : true,\r\n\t\t\t\"max-height\"      : true,\r\n\t\t\t\"max-width\"       : true,\r\n\t\t\t\"min-height\"      : true,\r\n\t\t\t\"min-width\"       : true,\r\n\t\t\t\"padding-left\"    : true,\r\n\t\t\t\"padding-right\"   : true,\r\n\t\t\t\"padding-bottom\"  : true,\r\n\t\t\t\"padding-top\"     : true,\r\n\t\t\t\"right\"           : true,\r\n\t\t\t\"text-align\"      : true,\r\n\t\t\t\"text-align-last\" : true,\r\n\t\t\t\"top\"             : true,\r\n\t\t\t\"width\"           : true,\r\n\t\t\t__proto__         : null,\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// a list of property we should inherit...\r\n\t\t//\r\n\t\tinheritingProperties: {\r\n\t\t\t\"border-collapse\"       : true,\r\n\t\t\t\"border-spacing\"        : true,\r\n\t\t\t\"caption-side\"          : true,\r\n\t\t\t\"color\"                 : true,\r\n\t\t\t\"cursor\"                : true,\r\n\t\t\t\"direction\"             : true,\r\n\t\t\t\"empty-cells\"           : true,\r\n\t\t\t\"font-family\"           : true,\r\n\t\t\t\"font-size\"             : true,\r\n\t\t\t\"font-style\"            : true,\r\n\t\t\t\"font-variant\"          : true,\r\n\t\t\t\"font-weight\"           : true,\r\n\t\t\t\"font\"                  : true,\r\n\t\t\t\"letter-spacing\"        : true,\r\n\t\t\t\"line-height\"           : true,\r\n\t\t\t\"list-style-image\"      : true,\r\n\t\t\t\"list-style-position\"   : true,\r\n\t\t\t\"list-style-type\"       : true,\r\n\t\t\t\"list-style\"            : true,\r\n\t\t\t\"orphans\"               : true,\r\n\t\t\t\"quotes\"                : true,\r\n\t\t\t\"text-align\"            : true,\r\n\t\t\t\"text-indent\"           : true,\r\n\t\t\t\"text-transform\"        : true,\r\n\t\t\t\"visibility\"            : true,\r\n\t\t\t\"white-space\"           : true,\r\n\t\t\t\"widows\"                : true,\r\n\t\t\t\"word-break\"            : true,\r\n\t\t\t\"word-spacing\"          : true,\r\n\t\t\t\"word-wrap\"             : true,\r\n\t\t\t__proto__               : null,\r\n\t\t},\r\n\t\t//\r\n\t\t// returns the default style for a tag\r\n\t\t//\r\n\t\tdefaultStylesForTag: Object.create ? Object.create(null) : {},\r\n\t\tgetDefaultStyleForTag: function getDefaultStyleForTag(tagName) {\r\n\t\t\t\r\n\t\t\t// get result from cache\r\n\t\t\tvar result = cssRegionsHelpers[tagName];\r\n\t\t\tif(result) return result;\r\n\t\t\t\r\n\t\t\t// create dummy virtual element\r\n\t\t\tvar element = document.createElement(tagName);\r\n\t\t\tvar style = cssRegionsHelpers[tagName] = getComputedStyle(element);\r\n\t\t\tif(style.display) return style;\r\n\t\t\t\r\n\t\t\t// webkit fix: insert the dummy element anywhere (head -> display:none)\r\n\t\t\tdocument.head.insertBefore(element, document.head.firstChild);\r\n\t\t\treturn style;\r\n\t\t},\r\n\t\t\r\n\t\t// \r\n\t\t// returns the specified style of an element. \r\n\t\t// REMARK: may or may not unwrap \"inherit\" and \"initial\" depending on implementation\r\n\t\t// REMARK: giving \"matchedRules\" as a parameter allow you to mutualize the \"findAllMatching\" rules calls\r\n\t\t// REMARK: giving \"stringOnly\" as a \"true\" parameter allows to return a fake token list which returns the good string value\r\n\t\t// \r\n\t\tgetSpecifiedStyle: function getSpecifiedStyle(element, cssPropertyName, matchedRules, stringOnly) {\r\n\t\t\t\r\n\t\t\t// hook for css regions\r\n\t\t\tvar fragmentSource;\r\n\t\t\tif(fragmentSource=element.getAttribute('data-css-regions-fragment-of')) {\r\n\t\t\t\tfragmentSource = document.querySelector('[data-css-regions-fragment-source=\"'+fragmentSource+'\"]');\r\n\t\t\t\tif(fragmentSource) return cssCascade.getSpecifiedStyle(fragmentSource, cssPropertyName);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// give IE a thumbs up for this!\r\n\t\t\tif(element.currentStyle && !window.opera) {\r\n\t\t\t\t\r\n\t\t\t\t// ask IE to manage the style himself...\r\n\t\t\t\tvar bestValue = element.myStyle[cssPropertyName] || element.currentStyle[cssPropertyName];\r\n\t\t\t\t\r\n\t\t\t\t// return a parsed representation of the value\r\n\t\t\t\treturn cssSyntax.parseCSSValue(bestValue, stringOnly);\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// TODO: support the \"initial\" and \"inherit\" things?\r\n\t\t\t\t\r\n\t\t\t\t// first, let's try inline style as it's fast and generally accurate\r\n\t\t\t\t// TODO: what if important rules override that?\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif(bestValue = element.style.getPropertyValue(cssPropertyName) || element.myStyle[cssPropertyName]) {\r\n\t\t\t\t\t\treturn cssSyntax.parseCSSValue(bestValue, stringOnly);\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch(ex) {}\r\n\t\t\t\t\r\n\t\t\t\t// find all relevant style rules\r\n\t\t\t\tvar isBestImportant=false; var bestPriority = 0; var bestValue = new cssSyntax.TokenList();\r\n\t\t\t\tvar rules = matchedRules || (\r\n\t\t\t\t\tcssPropertyName in cssCascade.monitoredProperties\r\n\t\t\t\t\t? element.myMatchedRules || []\r\n\t\t\t\t\t: cssCascade.findAllMatchingRules(element)\r\n\t\t\t\t);\r\n\t\t\t\t\r\n\t\t\t\tvar visit = function(rules) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tfor(var i=rules.length; i--; ) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// media queries hook\r\n\t\t\t\t\t\tif(rules[i].disabled) continue;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find a relevant declaration\r\n\t\t\t\t\t\tif(rules[i] instanceof cssSyntax.StyleRule) {\r\n\t\t\t\t\t\t\tvar decls = rules[i].value;\r\n\t\t\t\t\t\t\tfor(var j=decls.length-1; j>=0; j--) {\r\n\t\t\t\t\t\t\t\tif(decls[j].type==\"DECLARATION\") {\r\n\t\t\t\t\t\t\t\t\tif(decls[j].name==cssPropertyName) {\r\n\t\t\t\t\t\t\t\t\t\t// only works if selectors containing a \",\" are deduplicated\r\n\t\t\t\t\t\t\t\t\t\tvar currentPriority = cssCascade.computeSelectorPriorityOf(rules[i].selector);\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\tif(isBestImportant) {\r\n\t\t\t\t\t\t\t\t\t\t\t// only an important declaration can beat another important declaration\r\n\t\t\t\t\t\t\t\t\t\t\tif(decls[j].important) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tif(currentPriority >= bestPriority) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tbestPriority = currentPriority;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tbestValue = decls[j].value;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t// an important declaration beat any non-important declaration\r\n\t\t\t\t\t\t\t\t\t\t\tif(decls[j].important) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tisBestImportant = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\tbestPriority = currentPriority;\r\n\t\t\t\t\t\t\t\t\t\t\t\tbestValue = decls[j].value;\r\n\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\t// the selector priority has to be higher otherwise\r\n\t\t\t\t\t\t\t\t\t\t\t\tif(currentPriority >= bestPriority) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tbestPriority = currentPriority;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tbestValue = decls[j].value;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if((rules[i] instanceof cssSyntax.AtRule) && (rules[i].name==\"media\")) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tvisit(rules[i].value);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tvisit(rules);\r\n\t\t\t\t\r\n\t\t\t\t// return our best guess...\r\n\t\t\t\treturn bestValue;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t\r\n\t\t//\r\n\t\t// start monitoring a new stylesheet\r\n\t\t// (should usually not be used because stylesheets load automatically)\r\n\t\t//\r\n\t\tstylesheets: [],\r\n\t\tloadStyleSheet: function loadStyleSheet(cssText,i) {\r\n\t\t\t\r\n\t\t\t// load in order\r\n\t\t\t\r\n\t\t\t// parse the stylesheet content\r\n\t\t\tvar rules = cssSyntax.parse(cssText).value;\r\n\t\t\t\r\n\t\t\t// add the stylesheet into the object model\r\n\t\t\tif(typeof(i)!==\"undefined\") { cssCascade.stylesheets[i]=rules; } \r\n\t\t\telse { i=cssCascade.stylesheets.push(rules);}\r\n\t\t\t\r\n\t\t\t// make sure to monitor the required rules\r\n\t\t\tcssCascade.startMonitoringStylesheet(rules)\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// start monitoring a new stylesheet\r\n\t\t// (should usually not be used because stylesheets load automatically)\r\n\t\t//\r\n\t\tloadStyleSheetTag: function loadStyleSheetTag(stylesheet,i) {\r\n\t\t\t\r\n\t\t\tif(stylesheet.hasAttribute('data-css-polyfilled')) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(stylesheet.tagName=='LINK') {\r\n\t\t\t\t\r\n\t\t\t\t// oh, no, we have to download it...\r\n\t\t\t\ttry {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// dummy value in-between\r\n\t\t\t\t\tcssCascade.stylesheets[i] = new cssSyntax.TokenList();\r\n\t\t\t\t\t\r\n\t\t\t\t\t//\r\n\t\t\t\t\tvar xhr = new XMLHttpRequest(); xhr.href = stylesheet.href;\r\n\t\t\t\t\txhr.open('GET',stylesheet.href,true); xhr.ruleIndex = i; \r\n\t\t\t\t\txhr.onreadystatechange = function() {\r\n\t\t\t\t\t\tif(this.readyState==4) { \r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// status 0 is a webkit bug for local files\r\n\t\t\t\t\t\t\tif(this.status==200||this.status==0) {\r\n\t\t\t\t\t\t\t\tcssCascade.loadStyleSheet(this.responseText,this.ruleIndex)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcssConsole.log(\"css-cascade polyfill failled to load: \" + this.href);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t\txhr.send();\r\n\t\t\t\t\t\r\n\t\t\t\t} catch(ex) {\r\n\t\t\t\t\tcssConsole.log(\"css-cascade polyfill failled to load: \" + stylesheet.href);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// oh, cool, we just have to parse the content!\r\n\t\t\t\tcssCascade.loadStyleSheet(stylesheet.textContent,i);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// mark the stylesheet as ok\r\n\t\t\tstylesheet.setAttribute('data-css-polyfilled',true);\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// calling this function will load all currently existing stylesheets in the document\r\n\t\t// (should usually not be used because stylesheets load automatically)\r\n\t\t//\r\n\t\tselectorForStylesheets: \"style:not([data-no-css-polyfill]):not([data-css-polyfilled]), link[rel=stylesheet]:not([data-no-css-polyfill]):not([data-css-polyfilled])\",\r\n\t\tloadAllStyleSheets: function loadAllStyleSheets() {\r\n\t\t\t\r\n\t\t\t// for all stylesheets in the <head> tag...\r\n\t\t\tvar head = document.head || document.documentElement;\r\n\t\t\tvar stylesheets = head.querySelectorAll(cssCascade.selectorForStylesheets);\r\n\t\t\t\r\n\t\t\tvar intialLength = this.stylesheets.length;\r\n\t\t\tthis.stylesheets.length += stylesheets.length\r\n\t\t\t\r\n\t\t\t// for all of them...\r\n\t\t\tfor(var i = stylesheets.length; i--;) {\r\n\t\t\t\t\r\n\t\t\t\t// \r\n\t\t\t\t// load the stylesheet\r\n\t\t\t\t// \r\n\t\t\t\tvar stylesheet = stylesheets[i]; \r\n\t\t\t\tcssCascade.loadStyleSheetTag(stylesheet,intialLength+i)\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// this is where we store event handlers for monitored properties\r\n\t\t//\r\n\t\tmonitoredProperties: Object.create ? Object.create(null) : {},\r\n\t\tmonitoredPropertiesHandler: {\r\n\t\t\tonupdate: function(element, rule) {\r\n\t\t\t\t\r\n\t\t\t\t// we need to find all regexps that matches\r\n\t\t\t\tvar mps = cssCascade.monitoredProperties;\r\n\t\t\t\tvar decls = rule.value;\r\n\t\t\t\tfor(var j=decls.length-1; j>=0; j--) {\r\n\t\t\t\t\tif(decls[j].type==\"DECLARATION\") {\r\n\t\t\t\t\t\tif(decls[j].name in mps) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// call all handlers waiting for this\r\n\t\t\t\t\t\t\tvar hs = mps[decls[j].name];\r\n\t\t\t\t\t\t\tfor(var hi=hs.length; hi--;) {\r\n\t\t\t\t\t\t\t\ths[hi].onupdate(element,rule);\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// don't call twice\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// add an handler to some properties (aka fire when their value *MAY* be affected)\r\n\t\t// REMARK: because this event does not promise the value changed, you may want to figure it out before relayouting\r\n\t\t//\r\n\t\tstartMonitoringProperties: function startMonitoringProperties(properties, handler) {\r\n\t\t\t\r\n\t\t\tfor(var i=properties.length; i--; ) {\r\n\t\t\t\tvar property = properties[i];\r\n\t\t\t\tvar handlers = (\r\n\t\t\t\t\tcssCascade.monitoredProperties[property]\r\n\t\t\t\t\t|| (cssCascade.monitoredProperties[property] = [])\r\n\t\t\t\t);\r\n\t\t\t\thandlers.push(handler)\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor(var s=0; s<cssCascade.stylesheets.length; s++) {\r\n\t\t\t\tvar currentStylesheet = cssCascade.stylesheets[s];\r\n\t\t\t\tcssCascade.startMonitoringStylesheet(currentStylesheet);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// calling this function will detect monitored rules in the stylesheet\r\n\t\t// (should usually not be used because stylesheets load automatically)\r\n\t\t//\r\n\t\tstartMonitoringStylesheet: function startMonitoringStylesheet(rules) {\r\n\t\t\tfor(var i=0; i<rules.length; i++) {\r\n\t\t\t\t\r\n\t\t\t\t// only consider style rules\r\n\t\t\t\tif(rules[i] instanceof cssSyntax.StyleRule) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// try to see if the current rule is worth monitoring\r\n\t\t\t\t\tif(rules[i].isMonitored) continue;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// for that, let's see if we can find a declaration we should watch\r\n\t\t\t\t\tvar decls = rules[i].value;\r\n\t\t\t\t\tfor(var j=decls.length-1; j>=0; j--) {\r\n\t\t\t\t\t\tif(decls[j].type==\"DECLARATION\") {\r\n\t\t\t\t\t\t\tif(decls[j].name in cssCascade.monitoredProperties) {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// if we found some, start monitoring\r\n\t\t\t\t\t\t\t\tcssCascade.startMonitoringRule(rules[i]);\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(rules[i] instanceof cssSyntax.AtRule) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// handle @media\r\n\t\t\t\t\tif(rules[i].name == \"media\" && window.matchMedia) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcssCascade.startMonitoringMedia(rules[i]);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// calling this function will detect media query updates and fire events accordingly\r\n\t\t// (should usually not be used because stylesheets load automatically)\r\n\t\t//\r\n\t\tstartMonitoringMedia: function startMonitoringMedia(atrule) {\r\n\t\t\ttry {\r\n\t\t\t\t\r\n\t\t\t\tvar media = window.matchMedia(atrule.prelude.toCSSString());\r\n\t\t\t\t\r\n\t\t\t\t// update all the rules when needed\r\n\t\t\t\tcssCascade.updateMedia(atrule.value, !media.matches, false);\r\n\t\t\t\tmedia.addListener(\r\n\t\t\t\t\tfunction(newMedia) { cssCascade.updateMedia(atrule.value, !newMedia.matches, true); }\r\n\t\t\t\t);\r\n\t\t\t\t\r\n\t\t\t\t// it seems I like taking risks...\r\n\t\t\t\tcssCascade.startMonitoringStylesheet(atrule.value);\r\n\t\t\t\t\r\n\t\t\t} catch(ex) {\r\n\t\t\t\tsetImmediate(function() { throw ex; })\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// define what happens when a media query status changes\r\n\t\t//\r\n\t\tupdateMedia: function(rules,disabled,update) {\r\n\t\t\tfor(var i=rules.length; i--; ) {\r\n\t\t\t\trules[i].disabled = disabled;\r\n\t\t\t\t// TODO: should probably get handled by a setter on the rule...\r\n\t\t\t\tvar sr = rules[i].subRules;\r\n\t\t\t\tif(sr) {\r\n\t\t\t\t\tfor(var j=sr.length; j--; ) {\r\n\t\t\t\t\t\tsr[j].disabled = disabled;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// in case of update, all elements matching the selector went potentially updated...\r\n\t\t\tif(update) {\r\n\t\t\t\tfor(var i=rules.length; i--; ) {\r\n\t\t\t\t\tvar els = document.querySelectorAll(rules[i].selector.toCSSString());\r\n\t\t\t\t\tfor(var j=els.length; j--; ) {\r\n\t\t\t\t\t\tcssCascade.monitoredPropertiesHandler.onupdate(els[j],rules[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t// \r\n\t\t// splits a rule if it has multiple selectors\r\n\t\t// \r\n\t\tsplitRule: function splitRule(rule) {\r\n\t\t\t\r\n\t\t\t// create an array for all the subrules\r\n\t\t\tvar rules = [];\r\n\t\t\t\r\n\t\t\t// fill the array\r\n\t\t\tvar currentRule = new cssSyntax.StyleRule(); currentRule.disabled=rule.disabled;\r\n\t\t\tfor(var i=0; i<rule.selector.length; i++) {\r\n\t\t\t\tif(rule.selector[i] instanceof cssSyntax.DelimToken && rule.selector[i].value==\",\") {\r\n\t\t\t\t\tcurrentRule.value = rule.value; rules.push(currentRule);\r\n\t\t\t\t\tcurrentRule = new cssSyntax.StyleRule(); currentRule.disabled=rule.disabled;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurrentRule.selector.push(rule.selector[i])\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcurrentRule.value = rule.value; rules.push(currentRule);\r\n\t\t\t\r\n\t\t\t// save the result of the split as subrules\r\n\t\t\treturn rule.subRules = rules;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t// \r\n\t\t// ask the css-selector implementation to notify changes for the rules\r\n\t\t// \r\n\t\tstartMonitoringRule: function startMonitoringRule(rule) {\r\n\t\t\t\r\n\t\t\t// avoid monitoring rules twice\r\n\t\t\tif(!rule.isMonitored) { rule.isMonitored=true } else { return; }\r\n\t\t\t\r\n\t\t\t// split the rule if it has multiple selectors\r\n\t\t\tvar rules = rule.subRules || cssCascade.splitRule(rule);\r\n\t\t\t\r\n\t\t\t// monitor the rules\r\n\t\t\tfor(var i=0; i<rules.length; i++) {\r\n\t\t\t\trule = rules[i];\r\n\t\t\t\tquerySelectorLive(rule.selector.toCSSString(), {\r\n\t\t\t\t\tonadded: function(e) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// add the rule to the matching list of this element\r\n\t\t\t\t\t\t(e.myMatchedRules = e.myMatchedRules || []).push(rule); // TODO: does not respect priority order\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// generate an update event\r\n\t\t\t\t\t\tcssCascade.monitoredPropertiesHandler.onupdate(e, rule);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t},\r\n\t\t\t\t\tonremoved: function(e) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// remove the rule from the matching list of this element\r\n\t\t\t\t\t\tif(e.myMatchedRules) e.myMatchedRules.splice(e.myMatchedRules.indexOf(rule), 1);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// generate an update event\r\n\t\t\t\t\t\tcssCascade.monitoredPropertiesHandler.onupdate(e, rule);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// converts a css property name to a javascript name\r\n\t\t//\r\n\t\ttoCamelCase: function toCamelCase(variable) { \r\n\t\t\treturn variable.replace(\r\n\t\t\t\t/-([a-z])/g, \r\n\t\t\t\tfunction(str,letter) { \r\n\t\t\t\t\treturn letter.toUpperCase();\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// add some magic code to support properties on the style interface\r\n\t\t//\r\n\t\tpolyfillStyleInterface: function(cssPropertyName) {\r\n\t\t\t\r\n\t\t\tvar prop = {\r\n\t\t\t\t\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// check we know which element we work on\r\n\t\t\t\t\ttry { if(!this.parentElement) throw new Error(\"Please use the anHTMLElement.myStyle property to get polyfilled properties\") }\r\n\t\t\t\t\tcatch(ex) { setImmediate(function() { throw ex; }); return ''; }\r\n\t\t\t\t\t\r\n\t\t\t\t\ttry { \r\n\t\t\t\t\t\t// non-computed style: return the local style of the element\r\n\t\t\t\t\t\tthis.clip = (this.clip===undefined?'':this.clip);\r\n\t\t\t\t\t\treturn this.parentElement.getAttribute('data-style-'+cssPropertyName);\r\n\t\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t\t// computed style: return the specified style of the element\r\n\t\t\t\t\t\tvar value = cssCascade.getSpecifiedStyle(this.parentElement, cssPropertyName, undefined, true);\r\n\t\t\t\t\t\treturn value && value.length>0 ? value.toCSSString() : '';\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t},\r\n\t\t\t\t\r\n\t\t\t\tset: function(v) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// check that the style is writable\r\n\t\t\t\t\tthis.clip = (this.clip===undefined?'':this.clip);\r\n\r\n\t\t\t\t\t// check we know which element we work on\r\n\t\t\t\t\ttry { if(!this.parentElement) throw new Error(\"Please use the anHTMLElement.myStyle property to set polyfilled properties\") }\r\n\t\t\t\t\tcatch(ex) { setImmediate(function() { throw ex; }); return; }\r\n\t\t\t\t\t\r\n\t\t\t\t\t// modify the local style of the element\r\n\t\t\t\t\tif(this.parentElement.getAttribute('data-style-'+cssPropertyName) != v) {\r\n\t\t\t\t\t\tthis.parentElement.setAttribute('data-style-'+cssPropertyName,v);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tvar styleProtos = [];\r\n\t\t\ttry { styleProtos.push(Object.getPrototypeOf(document.documentElement.style) || CSSStyleDeclaration); } catch (ex) {}\r\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(getComputedStyle(document.documentElement))); } catch (ex) {}\r\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.currentStyle)); } catch (ex) {}\r\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.runtimeStyle)); } catch (ex) {}\r\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.specifiedStyle)); } catch (ex) {}\r\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.cascadedStyle)); } catch (ex) {}\r\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.usedStyle)); } catch (ex) {}\r\n\t\t\t\r\n\t\t\tfor(var i = styleProtos.length; i--;) {\r\n\t\t\t\tvar styleProto = styleProtos[i];\r\n\t\t\t\tObject.defineProperty(styleProto,cssPropertyName,prop);\r\n\t\t\t\tObject.defineProperty(styleProto,cssCascade.toCamelCase(cssPropertyName),prop);\r\n\t\t\t}\r\n\t\t\tcssCascade.startMonitoringRule(cssSyntax.parse('[data-style-'+cssPropertyName+']{'+cssPropertyName+':attr(style)}').value[0]);\r\n\t\t\t\r\n\t\t\t// add to the list of polyfilled properties...\r\n\t\t\tcssCascade.getAllCSSProperties().push(cssPropertyName);\r\n\t\t\tcssCascade.computationUnsafeProperties[cssPropertyName] = true;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t};\r\n\r\n\t//\r\n\t// polyfill for browsers not support CSSStyleDeclaration.parentElement (all of them right now)\r\n\t//\r\n\tdomEvents.EventTarget.implementsIn(cssCascade);\r\n\tObject.defineProperty(Element.prototype,'myStyle',{\r\n\t\tget: function() {\r\n\t\t\tvar style = this.style; \r\n\t\t\tif(!style.parentElement) style.parentElement = this;\r\n\t\t\treturn style;\r\n\t\t}\r\n\t});\r\n\r\n\t//\r\n\t// load all stylesheets at the time the script is loaded\r\n\t// then do it again when all stylesheets are downloaded\r\n\t// and again if some style tag is added to the DOM\r\n\t//\r\n\tif(!(\"no_auto_stylesheet_detection\" in window)) {\r\n\t\t\r\n\t\tcssCascade.loadAllStyleSheets();\r\n\t\tdocument.addEventListener(\"DOMContentLoaded\", function() {\r\n\t\t\tcssCascade.loadAllStyleSheets();\r\n\t\t\tif(window.querySelectorLive) {\r\n\t\t\t\twindow.querySelectorLive(\r\n\t\t\t\t\tcssCascade.selectorForStylesheets,\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tonadded: function(e) {\r\n\t\t\t\t\t\t\t// TODO: respect DOM order?\r\n\t\t\t\t\t\t\tcssCascade.loadStyleSheetTag(e);\r\n\t\t\t\t\t\t\tcssCascade.dispatchEvent('stylesheetadded');\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\t\r\n\treturn cssCascade;\r\n\r\n})(window, document);\nrequire.define('src/core/css-cascade.js');","//\r\n// The CSS Style module attempts to provide helpers to deal with Style Declarations and elements\r\n// [0] http://lists.w3.org/Archives/Public/www-style/2013Sep/0283.html\r\n//\r\nmodule.exports = (function(window, document) { \"use strict\";\r\n\r\n\tfunction usedStyleOf(element) {\r\n\t\tvar style = element.usedStyle || getComputedStyle(element);\r\n\t\tif(!style.parentElement) { style.parentElement = element; }\r\n\t\treturn style;\r\n\t}\r\n\t\r\n\tfunction currentStyleOf(element) {\r\n\t\tvar style = element.cascadedStyle || element.specifiedStyle || element.currentStyle || getComputedStyle(element); // TODO: check CSSOM spec for real name\r\n\t\tif(!style.parentElement) { style.parentElement = element; }\r\n\t\treturn style;\r\n\t}\r\n\t\r\n\tfunction styleOf(element) {\r\n\t\tvar style = element.style;\r\n\t\tif(!style.parentElement) { style.parentElement = element; }\r\n\t\treturn style;\r\n\t}\r\n\t\r\n\tfunction runtimeStyleOf(element) {\r\n\t\tvar style = /*element.runtimeStyle || */element.style;\r\n\t\tif(!style.parentElement) { style.parentElement = element; }\r\n\t\treturn style;\r\n\t}\r\n\t\r\n\tfunction enforceStyle(element, property, value) {\r\n\t\t\r\n\t\tvar propertyBackup = null;\r\n\t\tvar usedValue = usedStyleOf(element).getPropertyValue(property);\r\n\t\tif(value instanceof Array) {\r\n\t\t\tif(value.indexOf(usedValue) >= 0) return null;\r\n\t\t\tvalue = ''+value[0];\r\n\t\t} else {\r\n\t\t\tvalue = ''+value;\r\n\t\t}\r\n\t\t\r\n\t\tif(usedValue != value) {\r\n\t\t\tvar style = runtimeStyleOf(element);\r\n\t\t\tpropertyBackup = { \r\n\t\t\t\tvalue:     style.getPropertyValue(property),\r\n\t\t\t\tpriority:  style.getPropertyPriority(property),\r\n\t\t\t\tproperty:  property\r\n\t\t\t};\r\n\t\t\tstyle.setProperty(property, \"\", \"\"); // reset [0]\r\n\t\t\tstyle.setProperty(property, \"\" + value, \"important\");\r\n\t\t}\r\n\t\t\r\n\t\treturn propertyBackup;\r\n\t\t\r\n\t}\r\n\t\r\n\tfunction enforceStyles(element, propertyValues, backups) {\r\n\t\tvar backups = backups || [];\r\n\t\tfor(var property in propertyValues) { if(propertyValues.hasOwnProperty(key)) {\r\n\t\t\tvar currentBackup = enforceStyle(element, property, propertyValues[property]);\r\n\t\t\tif(currentBackup) { backups.push(currentBackup) }\r\n\t\t}}\r\n\t\treturn backups;\r\n\t}\r\n\r\n\tfunction restoreStyle(element, backup) {\r\n\r\n\t\tif(backup) {\r\n\t\t\r\n\t\t\t// get the element runtime style\r\n\t\t\tvar style = runtimeStyleOf(element);\r\n\t\t\t\r\n\t\t\t// reset [0]\r\n\t\t\tstyle.setProperty(backup.property, \"\", \"\");\r\n\t\t\t\r\n\t\t\t// restore\r\n\t\t\tif(backup.value) {\r\n\t\t\t\tstyle.setProperty(backup.property, backup.value, \"\");\r\n\t\t\t\tstyle.setProperty(backup.property, backup.value, backup.priority);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n\tfunction restoreStyles(element, backups) {\r\n\t\tif(!backups || !(backups.length > 0)) { return; }\r\n\t\tfor(var i=backups.length; i--;) {\r\n\t\t\trestoreStyle(element, backups[i]);\r\n\t\t}\r\n\t}\r\n\t\r\n\tvar cssStyle = {\r\n\t\tstyleOf: styleOf,\r\n\t\tusedStyleOf: usedStyleOf,\r\n\t\tcurrentStyleOf: currentStyleOf,\r\n\t\truntimeStyleOf: runtimeStyleOf,\r\n\t\tenforceStyle: enforceStyle,\r\n\t\tenforceStyles: enforceStyles,\r\n\t\trestoreStyle: restoreStyle,\r\n\t\trestoreStyles: restoreStyles,\r\n\t};\r\n\t\r\n\treturn cssStyle;\r\n\r\n})(window);\nrequire.define('src/core/css-style.js');","void function() {\r\n\tif(!('uniqueID' in document.documentElement)) {\r\n\t\tvar uniqueID_counter = 0;\r\n\t\tObject.defineProperty(Element.prototype, 'uniqueID', {get: function() {\r\n\t\t\tif(this.id) {\r\n\t\t\t\treturn(this.id);\r\n\t\t\t} else {\r\n\t\t\t\treturn(this.id = (\"EL__\"+(++uniqueID_counter)+\"__\"));\r\n\t\t\t}\r\n\t\t}});\r\n\t}\r\n}();\nrequire.define('src/core/polyfill-dom-uniqueID.js');","void function() {\r\n\t\r\n\t// request animation frame\r\n    var vendors = ['webkit', 'moz', 'ms', 'o'];\r\n    for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {\r\n        var vp = vendors[i];\r\n        window.requestAnimationFrame = window[vp+'RequestAnimationFrame'];\r\n        window.cancelAnimationFrame = (window[vp+'CancelAnimationFrame'] || window[vp+'CancelRequestAnimationFrame']);\r\n    }\r\n    if (!window.requestAnimationFrame || !window.cancelAnimationFrame) {\r\n\t\t\r\n\t\t// tick every 16ms\r\n        var listener_index = 0; var listeners = []; var tmp = []; var tick = function() {\r\n\t\t\tvar now = +(new Date()); var callbacks = listeners; listeners = tmp;\r\n\t\t\tfor(var i = 0; i<callbacks.length; i++) { callbacks[i](now); }\r\n\t\t\tlistener_index += callbacks.length; callbacks.length = 0; tmp = callbacks;\r\n\t\t\tsetTimeout(tick, 16);\r\n\t\t}; tick();\r\n\t\t\r\n\t\t// add a listener\r\n        window.requestAnimationFrame = function(callback) {\r\n            return listener_index + listeners.push(callback);\r\n        };\r\n\t\t\r\n\t\t// remove a listener\r\n        window.cancelAnimationFrame = function(index) {\r\n\t\t\tindex -= listener_index; if(index >= 0 && index < listeners.length) {\r\n\t\t\t\tlisteners[index] = function() {};\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n    }\r\n\t\r\n\t// setImmediate\r\n\tif(!window.setImmediate) {\r\n\t\twindow.setImmediate = function(f) { return setTimeout(f, 0) };\r\n\t\twindow.cancelImmediate = clearTimeout;\r\n\t}\r\n\t\r\n}();\r\n\nrequire.define('src/core/polyfill-dom-requestAnimationFrame.js');","module.exports = (function(window, document) {\r\n\t\r\n\t// import dependencies\r\n\tvar cssStyle  = require('src/core/css-style.js'),\r\n\t    usedStyleOf     = cssStyle.usedStyleOf,\r\n\t    currentStyleOf  = cssStyle.currentStyleOf,\r\n\t    enforceStyle    = cssStyle.enforceStyle,\r\n\t    restoreStyle    = cssStyle.restoreStyle;\r\n\t\r\n\t// define the module\r\n\tvar cssSizing = {\r\n\t\t\r\n\t\tabsoluteMinWidthOf: function(element) {\r\n\r\n\t\t\t//\r\n\t\t\t// make the parent a relative container (if necessary)\r\n\t\t\t//\r\n\t\t\tvar parentPositionBackup = enforceStyle(element.parentNode, \"position\", \"relative\");\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// remove the element from the flow (if necessary)\r\n\t\t\t//\r\n\t\t\tvar positionBackup = enforceStyle(element, \"position\", \"absolute\");\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// put impossible sizing constraints to the element\r\n\t\t\t//\r\n\t\t\tvar widthBackup = enforceStyle(element, \"width\", \"0px\");\r\n\t\t\tvar minWidthBackup = enforceStyle(element, \"min-width\", \"0px\");\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// see what size is finally being used\r\n\t\t\t//\r\n\t\t\tvar result = element.offsetWidth;\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// restore styling where needed\r\n\t\t\t//\r\n\t\t\trestoreStyle(element, minWidthBackup);\r\n\t\t\trestoreStyle(element, widthBackup);\r\n\t\t\trestoreStyle(element, positionBackup);\r\n\t\t\trestoreStyle(element.parentNode, parentPositionBackup);\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// return the result\r\n\t\t\t//\r\n\t\t\treturn result;\r\n\t\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tminWidthOf: function(element) {\r\n\t\t\r\n\t\t\t//\r\n\t\t\t// make the parent an infinite relative container (if necessary)\r\n\t\t\t//\r\n\t\t\tvar parentPositionBackup = enforceStyle(element.parentNode, \"position\", \"relative\");\r\n\t\t\tvar parentWidthBackup = enforceStyle(element.parentNode, \"width\", \"0px\");\r\n\t\t\tvar parentMinWidthBackup = enforceStyle(element.parentNode, \"min-width\", \"0px\");\r\n\t\t\tvar parentMaxWidthBackup = enforceStyle(element.parentNode, \"max-width\", \"0px\");\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// remove the element from the flow (if necessary)\r\n\t\t\t//\r\n\t\t\tvar positionBackup = enforceStyle(element, \"position\", \"absolute\");\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// put impossible sizing constraints to the element\r\n\t\t\t//\r\n\t\t\tvar widthBackup = enforceStyle(element, \"width\", \"auto\");\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// see what size is finally being used\r\n\t\t\t//\r\n\t\t\tvar result = element.offsetWidth;\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// restore styling where needed\r\n\t\t\t//\r\n\t\t\trestoreStyle(element, widthBackup);\r\n\t\t\trestoreStyle(element, positionBackup);\r\n\t\t\trestoreStyle(element.parentNode, parentWidthBackup);\r\n\t\t\trestoreStyle(element.parentNode, parentMaxWidthBackup);\r\n\t\t\trestoreStyle(element.parentNode, parentMinWidthBackup);\r\n\t\t\trestoreStyle(element.parentNode, parentPositionBackup);\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// return the result\r\n\t\t\t//\r\n\t\t\treturn result;\r\n\t\t},\r\n\t\t\r\n\t\tmaxWidthOf: function(element) {\r\n\t\t\r\n\t\t\t//\r\n\t\t\t// make the parent a relative container (if necessary)\r\n\t\t\t//\r\n\t\t\tvar parentPositionBackup = enforceStyle(element.parentNode, \"position\", \"relative\");\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// remove the element from the flow (if necessary)\r\n\t\t\t//\r\n\t\t\tvar positionBackup = enforceStyle(element, \"position\", \"absolute\");\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// put impossible sizing constraints to the element\r\n\t\t\t//\r\n\t\t\tvar widthBackup = enforceStyle(element, \"width\", \"auto\");\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// see what size is finally being used\r\n\t\t\t//\r\n\t\t\tvar result = element.offsetWidth;\r\n\t\t\t\t\t\r\n\t\t\t//\r\n\t\t\t// restore styling where needed\r\n\t\t\t//\r\n\t\t\trestoreStyle(element, widthBackup);\r\n\t\t\trestoreStyle(element, positionBackup);\r\n\t\t\trestoreStyle(element.parentNode, parentPositionBackup);\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// return the result\r\n\t\t\t//\r\n\t\t\treturn result;\r\n\t\t},\r\n\t\t\r\n\t\tabsoluteMaxWidthOf: function(element) {\r\n\t\t\r\n\t\t\t//\r\n\t\t\t// make the parent an infinite relative container (if necessary)\r\n\t\t\t//\r\n\t\t\tvar parentPositionBackup = enforceStyle(element.parentNode, \"position\", \"relative\");\r\n\t\t\tvar parentWidthBackup = enforceStyle(element.parentNode, \"width\", \"9999px\");\r\n\t\t\tvar parentMinWidthBackup = enforceStyle(element.parentNode, \"min-width\", \"9999px\");\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// remove the element from the flow (if necessary)\r\n\t\t\t//\r\n\t\t\tvar positionBackup = enforceStyle(element, \"position\", \"absolute\");\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// put impossible sizing constraints to the element\r\n\t\t\t//\r\n\t\t\tvar widthBackup = enforceStyle(element, \"width\", \"auto\");\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// see what size is finally being used\r\n\t\t\t//\r\n\t\t\tvar result = element.offsetWidth;\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// restore styling where needed\r\n\t\t\t//\r\n\t\t\trestoreStyle(element, widthBackup);\r\n\t\t\trestoreStyle(element, positionBackup);\r\n\t\t\trestoreStyle(element.parentNode, parentWidthBackup);\r\n\t\t\trestoreStyle(element.parentNode, parentMinWidthBackup);\r\n\t\t\trestoreStyle(element.parentNode, parentPositionBackup);\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// return the result\r\n\t\t\t//\r\n\t\t\treturn result;\r\n\t\t},\r\n\t\t\r\n\t};\r\n\t\r\n\treturn cssSizing;\r\n\t\r\n})(window, document)\nrequire.define('src/core/css-sizing.js');","//\r\n// The Box module defines algorithms for dealing with css boxes\r\n//\r\nmodule.exports = (function(window, document) {\r\n\t\r\n\t// Original code licensed by Adobe Systems Incorporated under the Apache License 2.0. \r\n\t// https://github.com/adobe-webplatform/brackets-css-shapes-editor/blob/master/thirdparty/CSSShapesEditor.js#L442\r\n\r\n\tvar cssBox = cssBox || {};\r\n\tcssBox.getBox = \r\n\t\t\r\n\t\t// returns {top/left/bottom/right} for 'content/padding/border/margin-box' relative to the border box top-left corner.\r\n\t\tfunction getBox(element, boxType){\r\n\t\t\tvar width = element.offsetWidth,\r\n\t\t\t\theight = element.offsetHeight,\r\n\r\n\t\t\t\tstyle = getComputedStyle(element),\r\n\r\n\t\t\t\tleftBorder = parseFloat(style.borderLeftWidth),\r\n\t\t\t\trightBorder = parseFloat(style.borderRightWidth),\r\n\t\t\t\ttopBorder = parseFloat(style.borderTopWidth),\r\n\t\t\t\tbottomBorder = parseFloat(style.borderBottomWidth),\r\n\r\n\t\t\t\tleftPadding = parseFloat(style.paddingLeft),\r\n\t\t\t\trightPadding = parseFloat(style.paddingRight),\r\n\t\t\t\ttopPadding = parseFloat(style.paddingTop),\r\n\t\t\t\tbottomPadding = parseFloat(style.paddingBottom),\r\n\r\n\t\t\t\tleftMargin = parseFloat(style.marginLeft),\r\n\t\t\t\trightMargin = parseFloat(style.marginRight),\r\n\t\t\t\ttopMargin = parseFloat(style.marginTop),\r\n\t\t\t\tbottomMargin = parseFloat(style.marginBottom);\r\n\r\n\t\t\tvar box = {\r\n\t\t\t\ttop: 0,\r\n\t\t\t\tleft: 0,\r\n\t\t\t\twidth: 0,\r\n\t\t\t\theight: 0\r\n\t\t\t};\r\n\r\n\t\t\tswitch (boxType||'border-box'){\r\n\t\t\tcase 'content-box':\r\n\t\t\t\tbox.top = topBorder + topPadding;\r\n\t\t\t\tbox.left = leftBorder + leftPadding;\r\n\t\t\t\tbox.width = width - leftBorder - leftPadding - rightPadding - rightBorder;\r\n\t\t\t\tbox.height = height - topBorder - topPadding - bottomPadding - bottomBorder;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'padding-box':\r\n\t\t\t\tbox.top = topPadding;\r\n\t\t\t\tbox.left = leftPadding;\r\n\t\t\t\tbox.width = width - leftBorder - rightBorder;\r\n\t\t\t\tbox.height = height - topBorder - bottomBorder;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'border-box':\r\n\t\t\t\tbox.top = 0;\r\n\t\t\t\tbox.left = 0;\r\n\t\t\t\tbox.width = width;\r\n\t\t\t\tbox.height = height;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'margin-box':\r\n\t\t\t\tbox.top = 0 - topMargin;\r\n\t\t\t\tbox.left = 0 - leftMargin;\r\n\t\t\t\tbox.width = width + leftMargin + rightMargin;\r\n\t\t\t\tbox.height = height + topMargin + bottomMargin;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new TypeError('Invalid parameter, boxType: ' + boxType);\r\n\t\t\t}\r\n\r\n\t\t\treturn box;\r\n\t\t};\r\n\t\r\n\treturn cssBox;\r\n\t\r\n})(window, document);\nrequire.define('src/core/css-box.js');","//\r\n// The CSS Units module is handling conversions between units\r\n//\r\nmodule.exports = (function(window, document) {\r\n\t\r\n\t// import dependencies\r\n\tvar getBox = require('src/core/css-box.js').getBox;\r\n\t\r\n\t// define the module\r\n\tvar cssUnits = {\r\n\t\t\r\n\t\t// converts \"cssLength\" from its inherent unit to pixels, and returns the result as a float\r\n\t\tconvertToPixels: function convertToPixels(cssLength, element, opts) {\r\n\t\t\t\r\n\t\t\tif(typeof cssLength == \"string\") {\r\n\t\t\t\r\n\t\t\t\tvar match = cssLength.match(/^\\s*(-?\\d+(?:\\.\\d+)?)(\\S*)\\s*$/);\r\n\t\t\t\tvar currentLength = match ? parseFloat(match[1]) : 0.0;\r\n\t\t\t\tvar currentUnit = match ? match[2] : '';\r\n\t\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\tvar currentLength = cssLength.value;\r\n\t\t\t\tvar currentUnit = cssLength.unit;\r\n\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\t\tvar converter = convertToPixels.converters[currentUnit];\r\n\t\t\tif (!converter) throw new Error(\"No suitable conversion from unit '\"+currentUnit+\"' to unit 'px'\");\r\n\t\t\t\r\n\t\t\tvar convertedLength = converter.call(null, currentLength, element||document.documentElement, opts)\r\n\t\t\treturn Math.round(20*convertedLength)/20;\r\n\t\t\t\r\n\t\t},\r\n\r\n\t\t// converts \"pixelLength\" from pixels to \"destinUnit\", and returns the result as a float\r\n\t\tconvertFromPixels: function convertFromPixels(pixelLength, destinUnit, element, opts) {\r\n\r\n\t\t\tvar converter = convertFromPixels.converters[destinUnit];\r\n\t\t\tif (!converter) throw new Error(\"No suitable conversion to unit '\"+destinUnit+\"' from unit 'px'\");\r\n\r\n\t\t\tvar convertedLength = converter.call(null, pixelLength, element||document.documentElement, opts)\r\n\t\t\treturn Math.round(20*convertedLength)/20;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t}\r\n\t\r\n\tcssUnits.convertToPixels.converters = {\r\n\t\t'px' : function(x) { return x; },\r\n\t\t'in' : function(x) { return x * 96; },\r\n\t\t'cm' : function(x) { return x / 0.02645833333; },\r\n\t\t'mm' : function(x) { return x / 0.26458333333; },\r\n\t\t'pt' : function(x) { return x / 0.75; },\r\n\t\t'pc' : function(x) { return x / 0.0625; },\r\n\t\t'em' : function(x, e) { return x*parseFloat(e?getComputedStyle(e).fontSize:16); },\r\n\t\t'rem': function(x, e) { return x*parseFloat(e?getComputedStyle(e.ownerDocument.documentElement).fontSize:16); },\r\n\t\t'vw' : function(x, e) { return x/100*window.innerWidth; },\r\n\t\t'vh' : function(x, e) { return x/100*window.innerHeight; },\r\n\t\t'%'  : function(x, e, opts) {\r\n\t\t\topts = opts || {};\r\n\r\n\t\t\t// get the box from which to compute the percentages\r\n\t\t\tvar box = e ? cssUtils.getBox(e, opts.boxType) : {\r\n\t\t\t\ttop: 0,\r\n\t\t\t\tleft: 0,\r\n\t\t\t\twidth: 0,\r\n\t\t\t\theight: 0\r\n\t\t\t};\r\n\r\n\t\t\t// now apply the conversion algorithm\r\n\t\t\tswitch(true) {\r\n\t\t\t\tcase opts.isRadius:\r\n\t\t\t\t\tvar radius = Math.sqrt( box.height*box.height + box.width*box.width ) / Math.sqrt(2);\r\n\t\t\t\t\treturn Math.round(x/100*radius);\r\n\t\t\t\t\t\r\n\t\t\t\tcase opts.isHeightRelated:\r\n\t\t\t\t\treturn x/100*box.height;\r\n\t\t\t\t\t\r\n\t\t\t\tcase opts.isWidthRelated: default:\r\n\t\t\t\t\treturn x/100*box.width;\r\n\t\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tcssUnits.convertFromPixels.converters = {\r\n\t\t'px' : function(x) { return x; },\r\n\t\t'in' : function(x) { return x / 96; },\r\n\t\t'cm' : function(x) { return x * 0.02645833333; },\r\n\t\t'mm' : function(x) { return x * 0.26458333333; },\r\n\t\t'pt' : function(x) { return x * 0.75; },\r\n\t\t'pc' : function(x) { return x * 0.0625; },\r\n\t\t'em' : function(x, e) { return x/parseFloat(e?getComputedStyle(e).fontSize:16); },\r\n\t\t'rem': function(x, e) { return x/parseFloat(e?getComputedStyle(e.ownerDocument.documentElement).fontSize:16); },\r\n\t\t'vw' : function(x, e) { return x*100/window.innerWidth; },\r\n\t\t'vh' : function(x, e) { return x*100/window.innerHeight; },\r\n\t\t'%'  : function(x, e, opts) {\r\n\t\t\topts = opts || {};\r\n\r\n\t\t\t// get the box from which to compute the percentages\r\n\t\t\tvar box = e ? cssUtils.getBox(e, opts.boxType) : {\r\n\t\t\t\ttop: 0,\r\n\t\t\t\tleft: 0,\r\n\t\t\t\twidth: 0,\r\n\t\t\t\theight: 0\r\n\t\t\t};\r\n\r\n\t\t\t// now apply the conversion algorithm\r\n\t\t\tswitch(true) {\r\n\t\t\t\tcase opts.isRadius:\r\n\t\t\t\t\tvar radius = Math.sqrt( box.height*box.height + box.width*box.width ) / Math.sqrt(2);\r\n\t\t\t\t\treturn Math.round(x*100/radius);\r\n\t\t\t\t\t\r\n\t\t\t\tcase opts.isHeightRelated:\r\n\t\t\t\t\treturn x*100/box.height;\r\n\t\t\t\t\t\r\n\t\t\t\tcase opts.isWidthRelated: default:\r\n\t\t\t\t\treturn x*100/box.width;\r\n\t\t\t\t\t\r\n\t\t\t}\r\n\r\n\r\n\t\t}\r\n\t};\r\n\t\r\n\treturn cssUnits;\r\n\r\n})(window, document);\nrequire.define('src/core/css-units.js');","module.exports = (function(window, document) { \"use strict\";\r\n\t\r\n\t// import dependencies\r\n\t\r\n\tvar cssSyntax = require('src/core/css-syntax.js');\r\n\t\r\n\tvar cssStyle  = require('src/core/css-style.js'),\r\n\t    usedStyleOf     = cssStyle.usedStyleOf,\r\n\t    currentStyleOf  = cssStyle.currentStyleOf,\r\n\t    enforceStyle    = cssStyle.enforceStyle,\r\n\t    restoreStyle    = cssStyle.restoreStyle;\r\n\t\r\n\trequire('src/core/polyfill-dom-uniqueID.js');\r\n\trequire('src/core/polyfill-dom-requestAnimationFrame.js');\r\n\t\r\n\tvar createRuntimeStyle = function(reason, element) {\r\n\t\t\r\n\t\t// expand the reason\r\n\t\tif(element) {\r\n\t\t\treason = (element.id || element.uniqueID) + '-' + reason;\r\n\t\t}\r\n\t\t\r\n\t\t// create style element\r\n\t\tvar styleElement = document.getElementById(reason+'-polyfill-overrides');\r\n\t\tif(!styleElement) {\r\n\t\t\tstyleElement = document.createElement('style');\r\n\t\t\tstyleElement.id = reason+'-polyfill-overrides';\r\n\t\t\tstyleElement.setAttribute('data-css-polyfilled', true);\r\n\t\t\tstyleElement.appendChild(document.createTextNode(\"\")); // WebKit fix\r\n\t\t\tdocument.querySelector(':root > head').appendChild(styleElement);\r\n\t\t}\r\n\t\t\r\n\t\t// get the associated style sheet\r\n\t\tvar ss = styleElement.sheet;\r\n\t\t\r\n\t\t// return a wrapper\r\n\t\treturn {\r\n\t\t\tset: function(element, properties) {\r\n\t\t\t\t\r\n\t\t\t\t// give an id to the element\r\n\t\t\t\tif(!element.id) { element.id = element.uniqueID; }\r\n\t\t\t\r\n\t\t\t\t// compute the css rule to add\r\n\t\t\t\tvar rule = \"#\"+element.id+\" {\";\r\n\t\t\t\tfor(var property in properties) {\r\n\t\t\t\t\tif(properties.hasOwnProperty(property)) {\r\n\t\t\t\t\t\trule += property + \": \" + properties[property] + \" !important; \";\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\trule += \"}\";\r\n\t\t\t\t\r\n\t\t\t\t// and then add it\r\n\t\t\t\treturn ss.insertRule(rule, ss.length);\r\n\t\t\t\t\r\n\t\t\t},\r\n\t\t\trevoke: function() {\r\n\t\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t\t},\r\n\t\t\tenable: function() {\r\n\t\t\t\tss.disabled = false;\r\n\t\t\t},\r\n\t\t\tdisable: function() {\r\n\t\t\t\tss.disabled = true;\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tvar cssSizing = require('src/core/css-sizing.js');\r\n\t\r\n\tvar cssUnits = require('src/core/css-units.js');\r\n\t\r\n\t// define the module\r\n\tvar LOCATE_AUTO = 0;\r\n\tvar LOCATE_LINE = 1;\r\n\tvar LOCATE_SPAN = 2;\r\n\tvar LOCATE_AREA = 3;\r\n\t\r\n\tvar ALIGN_START  = 0;\r\n\tvar ALIGN_CENTER = 1;\r\n\tvar ALIGN_END    = 2;\r\n\tvar ALIGN_FIT    = 3;\r\n\t\r\n\tvar TRACK_BREADTH_AUTO        = 0;\r\n\tvar TRACK_BREADTH_LENGTH      = 1;\r\n\tvar TRACK_BREADTH_FRACTION    = 2;\r\n\tvar TRACK_BREADTH_PERCENTAGE  = 3;\r\n\tvar TRACK_BREADTH_MIN_CONTENT = 4;\r\n\tvar TRACK_BREADTH_MAX_CONTENT = 5;\r\n\t\r\n\tfunction GridTrackBreadth() {\r\n\t\tthis.minType = TRACK_BREADTH_AUTO;\r\n\t\tthis.minValue = \"auto\";\r\n\t\tthis.maxType = TRACK_BREADTH_AUTO;\r\n\t\tthis.maxValue = \"auto\";\r\n\t}\r\n\t\r\n\tGridTrackBreadth.prototype = {\r\n\t\ttoString: function() {\r\n\t\t\tif(this.minType==this.maxType && this.minValue==this.maxValue) {\r\n\t\t\t\tswitch(this.minType) {\r\n\t\t\t\t\tcase TRACK_BREADTH_AUTO: return \"auto\";\r\n\t\t\t\t\tcase TRACK_BREADTH_LENGTH: return this.minValue+\"px\";\r\n\t\t\t\t\tcase TRACK_BREADTH_FRACTION: return this.minValue+\"fr\";\r\n\t\t\t\t\tcase TRACK_BREADTH_PERCENTAGE: return this.minValue+\"%\";\r\n\t\t\t\t\tcase TRACK_BREADTH_MIN_CONTENT: return \"min-content\";\r\n\t\t\t\t\tcase TRACK_BREADTH_MAX_CONTENT: return \"max-content\";\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar min = \"auto\";\r\n\t\t\t\tvar max = \"auto\";\r\n\t\t\t\tswitch(this.minType) {\r\n\t\t\t\t\tcase TRACK_BREADTH_AUTO: min = \"auto\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_LENGTH: min = this.minValue+\"px\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_FRACTION: min = this.minValue+\"fr\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_PERCENTAGE: min = this.minValue+\"%\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_MIN_CONTENT: min = \"min-content\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_MAX_CONTENT: min = \"max-content\"; break;\r\n\t\t\t\t}\r\n\t\t\t\tswitch(this.maxType) {\r\n\t\t\t\t\tcase TRACK_BREADTH_AUTO: max = \"auto\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_LENGTH: max = this.maxValue+\"px\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_FRACTION: max = this.maxValue+\"fr\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_PERCENTAGE: max = this.maxValue+\"%\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_MIN_CONTENT: max = \"min-content\"; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_MAX_CONTENT: max = \"max-content\"; break;\r\n\t\t\t\t}\r\n\t\t\t\treturn \"minmax(\" + min + \", \" + max + \")\";\r\n\t\t\t}\r\n\t\t},\r\n\t\tsetValue: function(type, val) {\r\n\t\t\tthis.minType  = this.maxType  = type;\r\n\t\t\tthis.minValue = this.maxValue = val;\r\n\t\t},\r\n\t\tsetMaxValue: function(type, val) {\r\n\t\t\tthis.maxType  = type;\r\n\t\t\tthis.maxValue = val;\r\n\t\t},\r\n\t\tsetMinValue: function(type, val) {\r\n\t\t\tthis.minType  = type;\r\n\t\t\tthis.minValue = val;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction GridItemPosition(type, name, index) {\r\n\t\tthis.type = type|LOCATE_AUTO;\r\n\t\tthis.name = name;\r\n\t\tthis.index = index|0;\r\n\t}\r\n\t\r\n\tGridItemPosition.prototype = {\r\n\t\textractXLineIndex: function(grid, TODO_args) {\r\n\t\t\tthrow \"Not implemented\";\r\n\t\t},\r\n\t\textractYLineIndex: function(grid, TODO_args) {\r\n\t\t\tthrow \"Not implemented\";\r\n\t\t},\r\n\t\ttoString: function() {\r\n\t\t\t\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction GridItem(element, parentGrid) {\r\n\t\t\r\n\t\tthis.element = element;\r\n\t\tthis.parentGrid = element.parentGridLayout = parentGrid;\r\n\t\t\r\n\t\tthis.reset();\r\n\t\tthis.buggy = true;\r\n\t\t\r\n\t}\r\n\t\r\n\tGridItem.prototype = {\r\n\t\t\r\n\t\tdispose: function() {\r\n\t\t\tthis.element.parentGridLayout = undefined;\r\n\t\t},\r\n\t\t\r\n\t\treset: function() {\r\n\t\t\t\r\n\t\t\tthis.minWidth = 0;\r\n\t\t\tthis.maxWidth = 0;\r\n\t\t\t\r\n\t\t\tthis.hMargins = 0;\r\n\t\t\tthis.vMargins = 0;\r\n\t\t\tthis.hPaddings = 0;\r\n\t\t\tthis.vPaddings = 0;\r\n\t\t\tthis.hBorders = 0;\r\n\t\t\tthis.vBorders = 0;\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tthis.xStart = -1;\r\n\t\t\tthis.xEnd = -1;\r\n\t\t\t\r\n\t\t\tthis.specifiedXStart = this.specifiedXStart || new GridItemPosition();\r\n\t\t\tthis.specifiedXStart.type = LOCATE_AUTO;\r\n\t\t\tthis.specifiedXStart.name = undefined;\r\n\t\t\tthis.specifiedXStart.index = undefined;\r\n\t\t\t\r\n\t\t\tthis.specifiedXEnd = this.specifiedXEnd || new GridItemPosition();\r\n\t\t\tthis.specifiedXEnd.type = LOCATE_AUTO;\r\n\t\t\tthis.specifiedXEnd.name = undefined;\r\n\t\t\tthis.specifiedXEnd.index = undefined;\r\n\r\n\t\t\t\r\n\t\t\tthis.yStart = -1;\r\n\t\t\tthis.yEnd = -1;\r\n\t\t\t\r\n\t\t\tthis.specifiedYStart = this.specifiedYStart || new GridItemPosition();\r\n\t\t\tthis.specifiedYStart.type = LOCATE_AUTO;\r\n\t\t\tthis.specifiedYStart.name = undefined;\r\n\t\t\tthis.specifiedYStart.index = undefined;\r\n\t\t\t\r\n\t\t\tthis.specifiedYEnd = this.specifiedYEnd || new GridItemPosition();\r\n\t\t\tthis.specifiedYEnd.type = LOCATE_AUTO;\r\n\t\t\tthis.specifiedYEnd.name = undefined;\r\n\t\t\tthis.specifiedYEnd.index = undefined;\r\n\t\t\t\r\n\t\t\tthis.marginAlignX = ALIGN_CENTER;\r\n\t\t\tthis.marginAlignY = ALIGN_CENTER;\r\n\t\t\t\r\n\t\t\tthis.paddingAlignX = ALIGN_FIT;\r\n\t\t\tthis.paddingAlignY = ALIGN_FIT;\r\n\t\t\t\r\n\t\t\t\r\n\t\t},\r\n\t\r\n\t\tupdateFromElement: function() {\r\n\t\t\t\r\n\t\t\tvar element = this.element;\r\n\t\t\tvar usedStyle = usedStyleOf(element);\r\n\t\t\tvar style = currentStyleOf(element);\r\n\t\t\tvar getStyle = function(prop) {\r\n\t\t\t\tvar value = style[prop];\r\n\t\t\t\tif(typeof(value)==\"undefined\") { return \"\"; }\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis.reset(); \r\n\t\t\tthis.buggy = false;\r\n\t\t\t\r\n\t\t\t// compute size\r\n\t\t\tthis.minWidth = cssSizing.minWidthOf(element);\r\n\t\t\tthis.maxWidth = cssSizing.maxWidthOf(element);\r\n\t\t\t\r\n\t\t\tthis.hMargins = parseInt(usedStyle.getPropertyValue('margin-left')) + parseInt(usedStyle.getPropertyValue('margin-right'));\r\n\t\t\tthis.vMargins = parseInt(usedStyle.getPropertyValue('margin-top')) + parseInt(usedStyle.getPropertyValue('margin-bottom'));\r\n\t\t\tthis.hPaddings = parseInt(usedStyle.getPropertyValue('padding-left')) + parseInt(usedStyle.getPropertyValue('padding-right'));\r\n\t\t\tthis.vPaddings = parseInt(usedStyle.getPropertyValue('padding-top')) + parseInt(usedStyle.getPropertyValue('padding-bottom'));\r\n\t\t\tthis.hBorders = parseInt(usedStyle.getPropertyValue('border-left-width')) + parseInt(usedStyle.getPropertyValue('border-right-width'));\r\n\t\t\tthis.vBorders = parseInt(usedStyle.getPropertyValue('border-top-width')) + parseInt(usedStyle.getPropertyValue('border-bottom-width'));\r\n\t\t\t\r\n\t\t\t// locate x and y lines together\r\n\t\t\tif(style[\"grid-area\"]) {\r\n\t\t\t\tvar parts = getStyle(\"grid-area\").split('/');\r\n\t\t\t\tvar is_ident = /^\\s*([a-z][-_a-z0-9]*)\\s*$/i;\r\n\t\t\t\tvar row_start = parts[0] || 'auto';\r\n\t\t\t\tvar col_start = parts[1] || (is_ident.test(row_start) ? row_start : 'auto');\r\n\t\t\t\tvar row_end = parts[2] || (is_ident.test(row_start) ? row_start : 'auto');\r\n\t\t\t\tvar col_end = parts[3] || (is_ident.test(col_start) ? col_start : 'auto');\r\n\t\t\t\tthis.parseLocationInstructions(this.specifiedXStart, this.specifiedXEnd, col_start + \" / \" + col_end);\r\n\t\t\t\tthis.parseLocationInstructions(this.specifiedYStart, this.specifiedYEnd, row_start + \" / \" + row_end);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// locate x lines\r\n\t\t\tif(style[\"grid-column\"] || style[\"grid-column-start\"] || style[\"grid-column-end\"]) {\r\n\t\t\t\tvar parts = getStyle(\"grid-column\").split('/');\r\n\t\t\t\tvar start = getStyle(\"grid-column-start\") || parts[0] || 'auto';\r\n\t\t\t\tvar end   = getStyle(\"grid-column-end\") || parts[1] || parts[0] || start;\r\n\t\t\t\tthis.parseLocationInstructions(this.specifiedXStart, this.specifiedXEnd, start + \" / \" + end);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// locate y lines\r\n\t\t\tif(style[\"grid-row\"] || style[\"grid-row-start\"] || style[\"grid-row-end\"]) {\r\n\t\t\t\tvar parts = getStyle(\"grid-row\").split('/');\r\n\t\t\t\tvar start = getStyle(\"grid-row-start\") || parts[0];\r\n\t\t\t\tvar end   = getStyle(\"grid-row-end\") || parts[1] || parts[0];\r\n\t\t\t\tthis.parseLocationInstructions(this.specifiedYStart, this.specifiedYEnd, start + \" / \" + end);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// FIXME: is it possible to understand cascading here, and not use a fixed order?\r\n\t\t\t// TODO: other positioning methods\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tparseLocationInstructions: function(specifiedStart, specifiedEnd, cssText) {\r\n\t\t\t\r\n\t\t\tvar unfiltred_value = cssSyntax.parseCSSValue(cssText);\r\n\t\t\tvar value = unfiltred_value.filter(function(o) { return !(o instanceof cssSyntax.WhitespaceToken); });\r\n\t\t\tvalue.toCSSString = function() { return unfiltred_value.toCSSString(); }\r\n\t\t\tvar I = 0;\r\n\t\t\t\r\n\t\t\tvar updateNameOrIndex = function(data) {\r\n\t\t\t\tif(value[I] instanceof cssSyntax.IdentifierToken) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// grid-column: C;\r\n\t\t\t\t\tif(data.name) { \r\n\t\t\t\t\t\t// duplicate line-name value\r\n\t\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (duplicate line name)\");\r\n\t\t\t\t\t\tthis.buggy = true;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdata.name = value[I++].value;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(value[I] instanceof cssSyntax.NumberToken) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// grid-column: 3\r\n\t\t\t\t\tdata.index = value[I].value|0;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// only accept integer values\r\n\t\t\t\t\tif(value[I].value != data.index) {\r\n\t\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (non-integer number)\");\r\n\t\t\t\t\t\tthis.buggy = true;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// do not accept zero\r\n\t\t\t\t\tif(data.index == 0) {\r\n\t\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (line index can't be zero)\");\r\n\t\t\t\t\t\tthis.buggy = true;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// do not accept negative spans\r\n\t\t\t\t\tif(data.index <= 0 && data.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (negative spans not allowed)\");\r\n\t\t\t\t\t\tthis.buggy = true;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tI++;\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(value[I] instanceof cssSyntax.DelimToken && value[I].value == \"/\") {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// break grid-column-start detection\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// this is wrong\r\n\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (invalid token)\");\r\n\t\t\t\t\tthis.buggy = true;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tvar gatherNameIndexPair = function(data) {\r\n\r\n\t\t\t\t// first token to be analyzed (may be either kind)\r\n\t\t\t\tupdateNameOrIndex.call(this, data);\r\n\t\t\t\t\r\n\t\t\t\t// abort if no second token or buggy\r\n\t\t\t\tif(this.buggy || !value[I]) { return; }\r\n\t\t\t\r\n\t\t\t\t// second token to be analyzed (will have to be the other kind)\r\n\t\t\t\tupdateNameOrIndex.call(this, data);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(!value[I]) { console.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (empty declaration)\"); this.buggy = true; return; }\r\n\t\t\t\r\n\r\n\t\t\t// first part\r\n\t\t\tgridColumnStart: while(true) {\r\n\t\t\t\tif(value[I] instanceof cssSyntax.IdentifierToken) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(value[I].value == \"span\") {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif(!value[++I]) {console.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (span is not a valid line name, more tokens expected)\"); this.buggy = true; return; }\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tspecifiedStart.type = LOCATE_SPAN;\r\n\t\t\t\t\t\tspecifiedStart.name = undefined;\r\n\t\t\t\t\t\tspecifiedStart.index = undefined;\r\n\t\t\t\t\t\tgatherNameIndexPair.call(this, specifiedStart);\r\n\t\t\t\t\t\tif(this.buggy) { return; }\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\t\t} else if(value[I].value == \"auto\") {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tspecifiedStart.type = LOCATE_AUTO;\r\n\t\t\t\t\t\tspecifiedStart.name = undefined;\r\n\t\t\t\t\t\tspecifiedStart.index = undefined;\r\n\t\t\t\t\t\tI++; break;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// grid-column: start-line...\r\n\t\t\t\t\t\tspecifiedStart.type = LOCATE_LINE;\r\n\t\t\t\t\t\tspecifiedStart.name = undefined;\r\n\t\t\t\t\t\tspecifiedStart.index = undefined;\r\n\t\t\t\t\t\tgatherNameIndexPair.call(this, specifiedStart);\r\n\t\t\t\t\t\tif(this.buggy) { return; }\r\n\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(value[I] instanceof cssSyntax.DelimToken && value[I].value == \"/\") {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// this is wrong\r\n\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (no token to analyze before the slash token)\");\r\n\t\t\t\t\tthis.buggy = true;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\tspecifiedStart.type = LOCATE_LINE;\r\n\t\t\t\t\tgatherNameIndexPair.call(this, specifiedStart);\r\n\t\t\t\t\tif(this.buggy) { return; }\r\n\t\t\t\t\t\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// test whether there is a second part\r\n\t\t\tif(value[I]) {\r\n\t\t\t\t\r\n\t\t\t\tif(value[I] instanceof cssSyntax.DelimToken && value[I].value == \"/\") {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// second part will start now\r\n\t\t\t\t\tif(!value[++I]) {\r\n\t\t\t\t\t\t// unexpected lack token at the start of the second part\r\n\t\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (expected at least one more token after the slash token)\");\r\n\t\t\t\t\t\tthis.buggy = true; \r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t\t// unexpected token at the end of the first part\r\n\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (expected slash / or end of declaration)\");\r\n\t\t\t\t\tthis.buggy = true; \r\n\t\t\t\t\treturn;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// end of declaration\r\n\t\t\t\tif(specifiedStart.type == LOCATE_LINE && specifiedStart.name != undefined && specifiedStart.index == undefined) {\r\n\t\t\t\t\t// a value consisting of a custom ident is duplicated to the other side\r\n\t\t\t\t\tspecifiedEnd.type = LOCATE_LINE;\r\n\t\t\t\t\tspecifiedEnd.name = specifiedStart.name;\r\n\t\t\t\t\tspecifiedEnd.index = undefined;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// the default value (auto) is a 1-line span in all other cases\r\n\t\t\t\t\tspecifiedEnd.type = LOCATE_AUTO;\r\n\t\t\t\t\tspecifiedEnd.name = undefined;\r\n\t\t\t\t\tspecifiedEnd.index = undefined;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// second part (after the \"/\" token)\r\n\t\t\tgridColumnEnd: while(value[I]) {\r\n\t\t\t\t\r\n\t\t\t\tif(value[I] instanceof cssSyntax.IdentifierToken) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(value[I].value == \"span\") {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif(!value[++I]) {console.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (span is not a valid line name, more tokens expected)\"); this.buggy = true; return; }\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tspecifiedEnd.type = LOCATE_SPAN;\r\n\t\t\t\t\t\tspecifiedEnd.name = undefined;\r\n\t\t\t\t\t\tspecifiedEnd.index = undefined;\r\n\t\t\t\t\t\tgatherNameIndexPair.call(this, specifiedEnd);\r\n\t\t\t\t\t\tif(this.buggy) { return; }\r\n\t\t\t\t\t\r\n\t\t\t\t\t} else if(value[I].value == \"auto\") {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tspecifiedEnd.type = LOCATE_AUTO;\r\n\t\t\t\t\t\tspecifiedEnd.name = undefined;\r\n\t\t\t\t\t\tspecifiedEnd.index = undefined;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// grid-column: start-line...\r\n\t\t\t\t\t\tspecifiedEnd.type = LOCATE_LINE;\r\n\t\t\t\t\t\tspecifiedEnd.name = undefined;\r\n\t\t\t\t\t\tspecifiedEnd.name = undefined;\r\n\t\t\t\t\t\tspecifiedEnd.index = undefined;\r\n\t\t\t\t\t\tgatherNameIndexPair.call(this, specifiedEnd);\r\n\t\t\t\t\t\tif(this.buggy) { return; }\r\n\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(value[I] instanceof cssSyntax.DelimToken && value[I].value == \"/\") {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// this is wrong\r\n\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (no token to analyze before the slash token)\");\r\n\t\t\t\t\tthis.buggy = true;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\tspecifiedEnd.type = LOCATE_LINE;\r\n\t\t\t\t\tgatherNameIndexPair.call(this, specifiedEnd);\r\n\t\t\t\t\tif(this.buggy) { return; }\r\n\t\t\t\t\t\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tbreak;\t\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(value[I]) {\r\n\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-column/row: \"+value.toCSSString()+\" (tokens after end)\");\r\n\t\t\t\tthis.buggy = true; \r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// If the <integer> is omitted, it defaults to �1�.\r\n\t\t\t//if(specifiedStart.name && specifiedStart.index == undefined) { specifiedStart.index = 1; }\r\n\t\t\t//if(specifiedEnd.name && specifiedEnd.index == undefined) { specifiedEnd.index = 1; }\r\n\t\t\t\r\n\t\t\t// If both �grid-row/column-start� and �grid-row/column-end� specify a span, the end span is ignored. \r\n\t\t\tif(specifiedEnd.type == LOCATE_SPAN && specifiedStart.type == LOCATE_SPAN) { specifiedEnd.type = LOCATE_AUTO; specifiedEnd.index = undefined; specifiedEnd.name = undefined; }\r\n\t\t\t\r\n\t\t\treturn [specifiedStart, specifiedEnd];\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\r\n\t};\t\r\n\r\n\tfunction GridLayout(element) {\r\n\t\r\n\t\t// items\r\n\t\tthis.element = element; this.element.gridLayout = this;\r\n\t\tthis.items = []; // array of GridItem\r\n\r\n\t\t// reset\r\n\t\tthis.reset();\r\n\t\t\r\n\t\t// other fields\r\n\t\tthis.isLayoutScheduled = false;\r\n\t\t\r\n\t}\r\n\t\r\n\tGridLayout.prototype = {\r\n\t\r\n\t\treset: function() {\r\n\t\t\t\r\n\t\t\t// computed\r\n\t\t\tthis.xLines = []; // array of array of names\r\n\t\t\tthis.xSizes = []; // array of numbers (in pixels)\r\n\t\t\t\r\n\t\t\tthis.yLines = [];\r\n\t\t\tthis.ySizes = [];\r\n\r\n\t\t\tthis.growX = false;\r\n\t\t\tthis.growY = true;\r\n\t\t\tthis.growDense = false;\r\n\t\t\t\r\n\t\t\tthis.rcMatrix = []; // array of array of (whatever is not undefined, probably \"true\")\r\n\t\t\t\r\n\t\t\t// specified\r\n\t\t\tthis.specifiedXLines = [];\r\n\t\t\tthis.specifiedXSizes = [];\r\n\t\t\t\r\n\t\t\tthis.specifiedYLines = [];\r\n\t\t\tthis.specifiedYSizes = [];\r\n\t\t\t\r\n\t\t\tthis.defaultXSize = new GridTrackBreadth();\r\n\t\t\tthis.defaultYSize = new GridTrackBreadth();\r\n\r\n\t\t},\r\n\t\r\n\t\tR: function R(x,y) { \r\n\t\t\tif(this.growY) {\r\n\t\t\t\t// we grow by adding rows (normal behavior)\r\n\t\t\t\treturn y;\r\n\t\t\t} else {\r\n\t\t\t\t// we grow by adding columns (inversed behavior)\r\n\t\t\t\treturn x;\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\tC: function C(x,y) { \r\n\t\t\tif(this.growY) {\r\n\t\t\t\t// we grow by adding rows (normal behavior)\r\n\t\t\t\treturn x;\r\n\t\t\t} else {\r\n\t\t\t\t// we grow by adding columns (inversed behavior)\r\n\t\t\t\treturn y;\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\tdispose: function() {\r\n\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i];\r\n\t\t\t\titem.dispose();\r\n\t\t\t}\r\n\t\t\tthis.element.gridLayout = undefined;\r\n\t\t},\r\n\t\t\r\n\t\tupdateFromElement: function() {\r\n\t\t\t\r\n\t\t\t// delete old items\r\n\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i];\r\n\t\t\t\titem.dispose();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// add new items\r\n\t\t\tthis.items.length = 0;\r\n\t\t\tvar currentItem = this.element.firstElementChild;\r\n\t\t\twhile(currentItem) {\r\n\t\t\t\t\r\n\t\t\t\t// add a new grid item for the element\r\n\t\t\t\tvar newGridItem = new GridItem(currentItem, this);\r\n\t\t\t\tnewGridItem.updateFromElement();\r\n\t\t\t\tthis.items.push(newGridItem);\r\n\t\t\t\t\r\n\t\t\t\t// move to the next element\r\n\t\t\t\tcurrentItem = currentItem.nextElementSibling;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// reset the style\r\n\t\t\tthis.reset();\r\n\t\t\t\r\n\t\t\t// update its own style\r\n\t\t\tvar style = usedStyleOf(this.element); var cssText = '';\r\n\t\t\tif(cssText=style[\"grid-template\"])         { this.parseGridTemplate(cssText);    }\r\n\t\t\tif(cssText=style[\"grid-template-rows\"])    { this.parseRowsTemplate(cssText);    }\r\n\t\t\tif(cssText=style[\"grid-template-columns\"]) { this.parseColumnsTemplate(cssText); }\r\n\t\t\tif(cssText=style[\"grid-template-areas\"])   { this.parseAreasTemplate(cssText);   }\r\n\t\t\tif(cssText=style[\"grid-auto-rows\"]) { this.parseAutoRowsBreadth(cssText); }\r\n\t\t\tif(cssText=style[\"grid-auto-columns\"]) { this.parseAutoColumnsBreadth(cssText); }\r\n\t\t\tif(cssText=style[\"grid-auto-flow\"]) { // FIXME: should be in a function\r\n\t\t\t\t\r\n\t\t\t\t// FIXME: not a real parse...\r\n\t\t\t\tvar tokens = cssText.trim().toLowerCase().split(/\\s+/g);\r\n\t\t\t\t\r\n\t\t\t\t// direction\r\n\t\t\t\tif(tokens.indexOf('row')>=0) {\r\n\t\t\t\t\tthis.growX = false;\r\n\t\t\t\t\tthis.growY = true;\r\n\t\t\t\t} else if(tokens.indexOf('column')>=0) {\r\n\t\t\t\t\tthis.growX = true;\r\n\t\t\t\t\tthis.growY = false;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// algorithm\r\n\t\t\t\t// FIXME: should also support 'stack' (wtf)\r\n\t\t\t\tif(tokens.indexOf('dense')>=0) {\r\n\t\t\t\t\tthis.growDense = true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.growDense = false;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tresetItems: function() {\r\n\t\t\tfor(var i = this.items.length; i--;) {\r\n\t\t\t\tvar item = this.items[i]; \r\n\t\t\t\titem.xStart = item.xEnd = item.yStart = item.yEnd = -1;\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\tresetLinesToSpecified: function() {\r\n\t\t\tthis.xLines = this.specifiedXLines.slice(0);\r\n\t\t\tthis.xSizes = this.specifiedXSizes.slice(0);\r\n\t\t\tthis.yLines = this.specifiedYLines.slice(0);\r\n\t\t\tthis.ySizes = this.specifiedYSizes.slice(0);\r\n\t\t},\r\n\t\t\r\n\t\tparseTrackBreadthToken: function(cssToken) {\r\n\t\t\t\r\n\t\t\t// try to match a pattern\r\n\t\t\tif(cssToken instanceof cssSyntax.IdentifierToken) {\r\n\t\t\t\t\r\n\t\t\t\tif(cssToken.value == \"auto\") {\r\n\t\t\t\t\treturn { type: TRACK_BREADTH_AUTO, value:\"auto\" };\r\n\t\t\t\t} else if(cssToken.value == \"min-content\") {\r\n\t\t\t\t\treturn { type: TRACK_BREADTH_MIN_CONTENT, value:\"min-content\" };\r\n\t\t\t\t} else if(cssToken.value == \"max-content\") {\r\n\t\t\t\t\treturn { type: TRACK_BREADTH_MAX_CONTENT, value:\"max-content\" };\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else if(cssToken instanceof cssSyntax.DimensionToken) {\r\n\t\t\t\t\r\n\t\t\t\tif(cssToken.unit == \"fr\") {\r\n\t\t\t\t\treturn { type: TRACK_BREADTH_FRACTION, value:cssToken.num };\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn { type: TRACK_BREADTH_LENGTH, value:cssUnits.convertToPixels(cssToken.toCSSString(), this.element) };\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else if(cssToken instanceof cssSyntax.PercentageToken) {\r\n\t\t\t\t\r\n\t\t\t\treturn { type: TRACK_BREADTH_PERCENTAGE, value:cssToken.value };\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// TODO: recognize \"calc()\", too\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn null;\r\n\t\t},\r\n\t\t\r\n\t\tparseTrackBreadth: function(value, I) {\r\n\t\t\r\n\t\t\t// TODO: try catch on null parsed token\r\n\t\t\tvar buggy = false;\r\n\t\t\t\r\n\t\t\tvar currentTrackBreadth = new GridTrackBreadth();\r\n\t\t\tvar parseTrackBreadthToken = function() {\r\n\t\t\t\t\r\n\t\t\t\t// try to match a pattern\r\n\t\t\t\tvar result = this.parseTrackBreadthToken(value[I]);\r\n\t\t\t\tif(result) { I++; return result; }\r\n\t\t\t\t\r\n\t\t\t\t// no pattern matched, so the declaration is invalid:\r\n\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-template-rows/columns: \"+value.toCSSString()+\" (unrecognized track breadth)\");\r\n\t\t\t\tbuggy = true;\r\n\t\t\t\treturn;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(value[I] instanceof cssSyntax.Func && value[I].name==\"minmax\") {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t// we need to parse two subvalues\r\n\t\t\t\tvar value_backup = value;\r\n\t\t\t\tvar I_backup = I;\r\n\t\t\t\t\r\n\t\t\t\t// check we have exactly two arguments\r\n\t\t\t\tif(value_backup[I_backup].value.length != 2) { \r\n\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-template-rows/columns: \"+value_backup.toCSSString()+\" (invalid number of arguments to the minmax function)\");\r\n\t\t\t\t\tbuggy = true;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// here's the first one:\r\n\t\t\t\tvalue = value_backup[I_backup].value[0].value.filter(function(t) { return !(t instanceof cssSyntax.WhitespaceToken) }); I = 0;\t\t\t\t\r\n\t\t\t\tvar data = parseTrackBreadthToken.call(this);\r\n\t\t\t\tcurrentTrackBreadth.minType = data.type;\r\n\t\t\t\tcurrentTrackBreadth.minValue = data.value;\r\n\t\t\t\t\r\n\t\t\t\t// here's the second one:\r\n\t\t\t\tvalue = value_backup[I_backup].value[1].value.filter(function(t) { return !(t instanceof cssSyntax.WhitespaceToken) }); I = 0;\t\t\t\t\r\n\t\t\t\tvar data = parseTrackBreadthToken.call(this);\r\n\t\t\t\tcurrentTrackBreadth.maxType  = data.type;\r\n\t\t\t\tcurrentTrackBreadth.maxValue = data.value;\r\n\t\t\t\t\r\n\t\t\t\t// restore context\r\n\t\t\t\tvalue = value_backup;\r\n\t\t\t\tI = I_backup+1;\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\r\n\t\t\t\t// we need to parse only one value\r\n\t\t\t\tvar data = parseTrackBreadthToken.call(this);\r\n\t\t\t\tcurrentTrackBreadth.minType  = currentTrackBreadth.maxType  = data.type;\r\n\t\t\t\tcurrentTrackBreadth.minValue = currentTrackBreadth.maxValue = data.value;\r\n\r\n\t\t\t}\r\n\t\t\t\t\r\n\t\t\treturn { result: currentTrackBreadth, I:I };\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tparseAutoRowsBreadth: function(cssText) {\r\n\t\t\r\n\t\t\t// TODO: check that no tokens are left when the parsing is done (+columns)\r\n\t\t\t\r\n\t\t\t// parse value into tokens:\r\n\t\t\tvar unfiltred_value = cssSyntax.parseCSSValue(cssText);\r\n\t\t\tvar value = unfiltred_value.filter(function(o) { return !(o instanceof cssSyntax.WhitespaceToken); });\r\n\t\t\tvalue.toCSSString = function() { return unfiltred_value.toCSSString(); }\r\n\t\t\t\r\n\t\t\t// parse tokens into data:\r\n\t\t\tvar data = this.parseTrackBreadth(value, 0);\r\n\t\t\tif(data.result) { this.defaultYSize = data.result; } else { throw \"TODO: better error message\"; }\r\n\t\t\treturn;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tparseAutoColumnsBreadth: function(cssText) {\r\n\t\t\t\r\n\t\t\t// parse value into tokens:\r\n\t\t\tvar unfiltred_value = cssSyntax.parseCSSValue(cssText);\r\n\t\t\tvar value = unfiltred_value.filter(function(o) { return !(o instanceof cssSyntax.WhitespaceToken); });\r\n\t\t\tvalue.toCSSString = function() { return unfiltred_value.toCSSString(); }\r\n\t\t\t\r\n\t\t\t// parse tokens into data:\r\n\t\t\tvar data = this.parseTrackBreadth(value, 0);\r\n\t\t\tif(data.result) { this.defaultXSize = data.result; } else { throw \"TODO: better error message\"; }\r\n\t\t\treturn;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tparseGridTemplate: function(cssText) { // TODO: I used some lazy heuristics here\r\n\t\t\tvar buggy = false; \r\n\t\t\r\n\t\t\t// step 1: columns are defined before the slash, if any\r\n\t\t\tvar cssText = cssText.replace(/\\/\\*(.*?)\\*\\//g,\"\");\r\n\t\t\tvar cssTextSections = cssText.split(\"/\");\r\n\t\t\tif(cssTextSections.length == 2) {\r\n\t\t\t\tif(this.parseColumnsTemplate(cssTextSections[0])) { return buggy=true; }\r\n\t\t\t\tcssText = cssTextSections[1];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// check that the syntax makes sense\r\n\t\t\telse if(cssTextSections.length >= 3) { \r\n\t\t\t\treturn buggy=true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// check if we can find any string\r\n\t\t\tif(/\"|'/.test(cssText)) {\r\n\t\t\t\r\n\t\t\t\t// extract strings from the value\r\n\t\t\t\tvar strings = [];\r\n\t\t\t\tcssText = cssText.replace(/\\s*(\"(?:.*?)\"|'(?:.*?)')\\s*([-_a-zA-Z0-9]*)\\s*/g,function(data,str,size) { strings.push(str); return ' '+(size||\"auto\")+' '; });\r\n\t\t\t\t\r\n\t\t\t\t// remove duplicate line name blocks\r\n\t\t\t\tcssText = cssText.replace(/\\)\\s*\\(/g,\" \");\r\n\t\t\t\t\r\n\t\t\t\t// parse rows now\r\n\t\t\t\tif(this.parseRowsTemplate(cssText)) { return buggy=true; }\r\n\t\t\t\t\r\n\t\t\t\t// parse areas now\r\n\t\t\t\tif(this.parseAreasTemplate(strings.join(' '))) { return buggy=true; }\r\n\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// parse rows now\r\n\t\t\t\tif(this.parseRowsTemplate(cssText)) { return buggy=true; }\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn buggy;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tparseAreasTemplate: function(cssText) {\r\n\t\t\t\r\n\t\t\t// parse value into tokens:\r\n\t\t\tvar unfiltred_value = cssSyntax.parseCSSValue(cssText);\r\n\t\t\tvar value = unfiltred_value.filter(function(o) { return !(o instanceof cssSyntax.WhitespaceToken); });\r\n\t\t\tvalue.toCSSString = function() { return unfiltred_value.toCSSString(); }\r\n\t\t\t\r\n\t\t\t// parse tokens into data:\r\n\t\t\tvar I = 0;\r\n\t\t\tvar buggy = false;\r\n\t\t\tvar regexp = /^([-_a-zA-Z0-9]+|\\.)\\s*/;\r\n\t\t\tvar grid = [], areas = Object.create(null);\r\n\t\t\twhile(value[I]) {\r\n\t\t\t\t\r\n\t\t\t\tvar str = ''+value[I++].value;\r\n\t\t\t\t\r\n\t\t\t\tvar columns = [];\r\n\t\t\t\twhile(str!=='') {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// extract next token\r\n\t\t\t\t\tvar data = regexp.exec(str); if(!data || data.length != 2) { return buggy=true; }\r\n\t\t\t\t\tstr = str.substr(data[0].length); var cell = data[1];\r\n\t\t\t\t\t\r\n\t\t\t\t\t// update cell max pos (ignore empty cells)\r\n\t\t\t\t\tif(cell!='.') {\r\n\t\t\t\t\t\tif(!areas[cell]) { areas[cell] = { xStart:columns.length, xEnd:columns.length+1, yStart: I-1, yEnd: I }; }\r\n\t\t\t\t\t\tif(areas[cell].xStart > columns.length) { return buggy=true; } \r\n\t\t\t\t\t\tif(areas[cell].yStart > I-1) { return buggy=true; }\r\n\t\t\t\t\t\tareas[cell].xEnd = Math.max(areas[cell].xEnd, columns.length+1);\r\n\t\t\t\t\t\tareas[cell].yEnd = Math.max(areas[cell].yEnd, I);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// add the cell to this row\r\n\t\t\t\t\tcolumns.push(data[1]);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tgrid.push(columns);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// validate areas\r\n\t\t\tfor(var a in areas) {\r\n\t\t\t\tvar area = areas[a];\r\n\t\t\t\tfor(var y = area.yStart; y<area.yEnd; y++) {\r\n\t\t\t\t\tfor(var x = area.xStart; x<area.xEnd; x++) {\r\n\t\t\t\t\t\tif(grid[y][x] != a) { return buggy=true; }\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// add autogenerated line names\r\n\t\t\tfor(var a in areas) {\r\n\t\t\t\tvar area = areas[a];\r\n\t\t\t\t\r\n\t\t\t\t// make sure we have enough y lines for the areas to fit:\r\n\t\t\t\twhile(this.specifiedYLines.length<=area.yEnd) {\r\n\t\t\t\t\tthis.specifiedYLines.push([]);\r\n\t\t\t\t\tthis.specifiedYSizes.push(this.defaultYSize);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// add the y line name\r\n\t\t\t\tthis.specifiedYLines[area.yStart].push(a+\"-start\");\r\n\t\t\t\tthis.specifiedYLines[area.yEnd].push(a+\"-end\");\r\n\t\t\t\t\r\n\t\t\t\t// make sure we have enough x lines for the areas to fit:\r\n\t\t\t\twhile(this.specifiedXLines.length<=area.xEnd) {\r\n\t\t\t\t\tthis.specifiedXLines.push([]);\r\n\t\t\t\t\tthis.specifiedXSizes.push(this.defaultXSize);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// add the x line name\r\n\t\t\t\tthis.specifiedXLines[area.xStart].push(a+\"-start\");\r\n\t\t\t\tthis.specifiedXLines[area.xEnd].push(a+\"-end\");\r\n\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\t},\r\n\t\t\r\n\t\tparseTrackDefinitions: function(lineNames, trackBreadths, cssText) {\r\n\t\t\t\r\n\t\t\t// replace the repeat() function by its full representation\r\n\t\t\tcssText = cssText.replace(/repeat\\(\\s*([0-9]+)\\s*\\,((?:\\([^()]*\\)|[^()])+)\\)/gi, function(s, n, v) {\r\n\t\t\t\tvar result = ' ';\r\n\t\t\t\tfor(var i = parseInt(n); i--;) { \r\n\t\t\t\t\tresult += v + ' ';\r\n\t\t\t\t}\r\n\t\t\t\treturn result;\r\n\t\t\t});\r\n\t\t\t'TODO: improve the repeat support';\r\n\t\t\t\r\n\t\t\t// merge duplicate name-definitions\r\n\t\t\tcssText = cssText.replace(/\\)\\s*\\(/g, ' ');\r\n\t\t\t'TODO: improve the duplicate name-definitions support';\r\n\t\t\t\r\n\t\t\t// parse value into tokens:\r\n\t\t\tvar unfiltred_value = cssSyntax.parseCSSValue(cssText);\r\n\t\t\tvar value = unfiltred_value.filter(function(o) { return !(o instanceof cssSyntax.WhitespaceToken); });\r\n\t\t\tvalue.toCSSString = function() { return unfiltred_value.toCSSString(); }\r\n\t\t\t\r\n\t\t\t// parse tokens into data:\r\n\t\t\tvar I = 0;\r\n\t\t\tvar buggy = false;\r\n\t\t\t\r\n\t\t\tvar parseLineNames = function() {\r\n\t\t\t\t\r\n\t\t\t\tvar currentLineNames = []; // array of string\r\n\t\t\t\t\r\n\t\t\t\tif(value[I] instanceof cssSyntax.SimpleBlock && value[I].name == \"(\") {\r\n\t\t\t\t\tvar tokens = value[I].value;\r\n\t\t\t\t\tfor(var J=tokens.length; J--;) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (tokens[J] instanceof cssSyntax.IdentifierToken) {\r\n\t\t\t\t\t\t\tcurrentLineNames.push(tokens[J].value);\r\n\t\t\t\t\t\t} else if (tokens[J] instanceof cssSyntax.WhitespaceToken) {\r\n\t\t\t\t\t\t\t// ignore\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// unrecognized token, so the declaration is invalid:\r\n\t\t\t\t\t\t\tconsole.error(\"INVALID DECLARATION: grid-template-rows/columns: \"+value.toCSSString()+\" (unrecognized line name)\");\r\n\t\t\t\t\t\t\tbuggy = true;\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tI++;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tlineNames.push(currentLineNames); \r\n\t\t\t\tcurrentLineNames = [];\r\n\t\t\t\t\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tvar parseTrackBreadth = function() {\r\n\t\t\t\t\r\n\t\t\t\tvar data = this.parseTrackBreadth(value, I);\r\n\t\t\t\ttrackBreadths.push(data.result);\r\n\t\t\t\tI = data.I;\r\n\t\t\t\t\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tparseLineNames(); \r\n\t\t\twhile(value[I]) {\r\n\t\t\t\tparseTrackBreadth.call(this); if(buggy) { break; }\r\n\t\t\t\tparseLineNames(); if(buggy) { break; }\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tparseColumnsTemplate: function(cssText) {\r\n\t\t\treturn this.parseTrackDefinitions(this.specifiedXLines, this.specifiedXSizes, cssText);\r\n\t\t},\r\n\t\t\r\n\t\tparseRowsTemplate: function(cssText) {\r\n\t\t\treturn this.parseTrackDefinitions(this.specifiedYLines, this.specifiedYSizes, cssText);\r\n\t\t},\r\n\t\t\r\n\t\tparseTracksTemplate: function(columnsTemplate, rowsTemplate, areasTemplate) {\r\n\t\t\tif(rowsTemplate   ) this.parseRowsTemplate(rowsTemplate);\r\n\t\t\tif(columnsTemplate) this.parseColumnsTemplate(columnsTemplate);\r\n\t\t\tif(areasTemplate  ) this.parseAreasTemplate(areasTemplate);\r\n\t\t},\r\n\t\t\r\n\t\tbuildExplicitMatrix: function() {\r\n\t\t\t\r\n\t\t\t// reset\r\n\t\t\tthis.resetLinesToSpecified();\r\n\t\t\tthis.rcMatrix = [];\r\n\t\t\t\r\n\t\t\t// simple autogrow\r\n\t\t\tif(this.growY) {\r\n\t\t\t\tthis.ensureRows(this.ySizes.length);\r\n\t\t\t\tthis.ensureColumns(this.xSizes.length);\r\n\t\t\t} else {\r\n\t\t\t\tthis.ensureColumns(this.xSizes.length);\r\n\t\t\t\tthis.ensureRows(this.ySizes.length);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}, \r\n\t\t\r\n\t\tbuildImplicitMatrix: function() { /* see http://dev.w3.org/csswg/css-grid/#auto-placement-algo */\r\n\t\t\r\n\t\t\t// start by building the explicit matrix\r\n\t\t\tthis.buildExplicitMatrix();\r\n\t\t\t\r\n\t\t\t// [1] position non-auto items\r\n\t\t\tthis.positionNonAutoItems();\r\n\t\t\t\r\n\t\t\t// [2] position auto-in-column-only items\r\n\t\t\tthis.positionAutoInColumnOnlyItems();\r\n\t\t\t\r\n\t\t\t// [3] make room for implicit tracks\r\n\t\t\tthis.autoGrow();\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tensureRows: function(yEnd) {\r\n\t\t\t\r\n\t\t\tif(this.growY) {\r\n\t\t\t\t\r\n\t\t\t\t// add rows as necessary\r\n\t\t\t\twhile(this.ySizes.length<yEnd) {\r\n\t\t\t\t\tthis.ySizes.push(this.defaultYSize);\r\n\t\t\t\t}\r\n\t\t\t\twhile(this.rcMatrix.length<yEnd) {\r\n\t\t\t\t\tthis.rcMatrix.push([]);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// add rows as necessary\r\n\t\t\t\twhile(this.ySizes.length<yEnd) {\r\n\t\t\t\t\tthis.ySizes.push(this.defaultYSize);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// walk through columns\r\n\t\t\t\tfor(var x = this.rcMatrix.length; x--;) {\r\n\t\t\t\t\r\n\t\t\t\t\t// add rows as necessary\r\n\t\t\t\t\tif(this.rcMatrix[x].length < yEnd) {\r\n\t\t\t\t\t\tthis.rcMatrix[x].length = yEnd;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tensureColumns: function(xEnd) {\r\n\t\t\t\r\n\t\t\tif(this.growY) {\r\n\t\t\t\r\n\t\t\t\t// add columns as necessary\r\n\t\t\t\twhile(this.xSizes.length<xEnd) {\r\n\t\t\t\t\tthis.xSizes.push(this.defaultXSize);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// walk through rows\r\n\t\t\t\tfor(var y = this.rcMatrix.length; y--;) {\r\n\t\t\t\t\r\n\t\t\t\t\t// add columns as necessary\r\n\t\t\t\t\tif(this.rcMatrix[y].length < xEnd) {\r\n\t\t\t\t\t\tthis.rcMatrix[y].length = xEnd;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// add columns as necessary\r\n\t\t\t\twhile(this.xSizes.length<xEnd) {\r\n\t\t\t\t\tthis.xSizes.push(this.defaultXSize);\r\n\t\t\t\t}\r\n\t\t\t\twhile(this.rcMatrix.length<xEnd) {\r\n\t\t\t\t\tthis.rcMatrix.push([]);\r\n\t\t\t\t}\r\n\t\t\t\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\tmarkAsOccupied: function(item) {\r\n\t\t\t\r\n\t\t\tvar xStart = item.xStart;\r\n\t\t\tvar yStart = item.yStart;\r\n\t\t\tvar xEnd = item.xEnd;\r\n\t\t\tvar yEnd = item.yEnd;\r\n\t\t\r\n\t\t\t// let's check the rcMatrix mode we're in:\r\n\t\t\tif(this.growY) {\r\n\t\t\t\t\r\n\t\t\t\t// add rows as necessary\r\n\t\t\t\tthis.ensureRows(yEnd);\r\n\t\t\t\t\r\n\t\t\t\t// walk through rows\r\n\t\t\t\tfor(var y = yStart; y<yEnd; y++) {\r\n\t\t\t\t\r\n\t\t\t\t\t// add columns as necessary\r\n\t\t\t\t\tif(this.rcMatrix[y].length < xEnd-1) {\r\n\t\t\t\t\t\tthis.rcMatrix[y].length = xEnd-1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// walk through columns\r\n\t\t\t\t\tfor(var x = xStart; x<xEnd; x++) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// the cell is occupied\r\n\t\t\t\t\t\tthis.rcMatrix[y][x] = item;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// add columns as necessary\r\n\t\t\t\tthis.ensureColumns(xEnd);\r\n\t\t\t\t\r\n\t\t\t\t// walk through rows\r\n\t\t\t\tfor(var x = xStart; x<xEnd; x++) {\r\n\t\t\t\t\r\n\t\t\t\t\t// add rows as necessary\r\n\t\t\t\t\tif(this.rcMatrix[x].length < yEnd-1) {\r\n\t\t\t\t\t\tthis.rcMatrix[x].length = yEnd-1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// walk through rows\r\n\t\t\t\t\tfor(var y = yStart; y<yEnd; y++) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// the cell is occupied\r\n\t\t\t\t\t\tthis.rcMatrix[x][y] = item;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\t},\r\n\t\t\r\n\t\tpositionNonAutoItems: function() {\r\n\t\t\t\r\n\t\t\tfor(var i=0, l=this.items.length; i<l; i++) {\r\n\t\t\t\tvar item = this.items[i];\r\n\t\t\t\t\r\n\t\t\t\t// if the element has a specific column associated to it\r\n\t\t\t\tif(item.specifiedXStart.type == LOCATE_LINE) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if the element has a specified row associated to it\r\n\t\t\t\t\tif(item.specifiedYStart.type == LOCATE_LINE) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find the start position (x axis)\r\n\t\t\t\t\t\tvar xStart = this.findXStart(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find the start position (y axis)\r\n\t\t\t\t\t\tvar yStart = this.findYStart(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find the end position (x axis)\r\n\t\t\t\t\t\tvar xEnd = this.findXEnd(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find the end position (y axis)\r\n\t\t\t\t\t\tvar yEnd = this.findYEnd(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// we're done! this is so cool dude!\r\n\t\t\t\t\t\titem.xStart = xStart;\r\n\t\t\t\t\t\titem.yStart = yStart;\r\n\t\t\t\t\t\titem.xEnd = xEnd;\r\n\t\t\t\t\t\titem.yEnd = yEnd;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// we should fill the explicit matrix now!\r\n\t\t\t\t\t\tthis.markAsOccupied(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tpositionAutoInColumnOnlyItems: function() {\r\n\t\t\t\r\n\t\t\tif(this.growY) {\r\n\t\t\t\t\r\n\t\t\t\tfor(var i=0, l=this.items.length; i<l; i++) {\r\n\t\t\t\t\tvar item = this.items[i];\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if the element has a specified row associated to it, but is not positioned yet\r\n\t\t\t\t\tif(item.specifiedYStart.type == LOCATE_LINE && (item.yStart==-1)) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find the start position (y axis)\r\n\t\t\t\t\t\tvar yStart = this.findYStart(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find the end position (y axis)\r\n\t\t\t\t\t\tvar yEnd = this.findYEnd(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// assumption: X is either AUTO + SPAN or AUTO + AUTO\r\n\t\t\t\t\t\tvar spanX = 1;\r\n\t\t\t\t\t\tif(item.specifiedXEnd.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\t\tif(item.specifiedXEnd.name === undefined) {\r\n\t\t\t\t\t\t\t\t// The span is defined as this value\r\n\t\t\t\t\t\t\t\tspanX = item.specifiedXEnd.index;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\r\n\t\t\t\t\t\t\t\tspanX = 1; console.error('[CSS-GRID] UNSUPPORTED: grid-row/column: auto / span [0-9]+ [A-Z]+');\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// add rows as necessary\r\n\t\t\t\t\t\tthis.ensureRows(yEnd);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// walk through columns to find a suitable position\r\n\t\t\t\t\t\tIncrementalColumnAttempts: for(var sx = 0;;sx++) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tfor(var x = sx+spanX-1; x>=sx; x--) {\r\n\t\t\t\t\t\t\t\tfor(var y = yStart; y<yEnd; y++) {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// if the cell is occupied\r\n\t\t\t\t\t\t\t\t\tif(this.rcMatrix[y][x]) {\r\n\t\t\t\t\t\t\t\t\t\tcontinue IncrementalColumnAttempts;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar xStart = sx;\r\n\t\t\t\t\t\tvar xEnd = sx+spanX;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// we're done! this is so cool dude!\r\n\t\t\t\t\t\titem.xStart = xStart;\r\n\t\t\t\t\t\titem.yStart = yStart;\r\n\t\t\t\t\t\titem.xEnd = xEnd;\r\n\t\t\t\t\t\titem.yEnd = yEnd;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// we should fill the explicit matrix now!\r\n\t\t\t\t\t\tthis.markAsOccupied(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\tfor(var i=0, l=this.items.length; i<l; i++) {\r\n\t\t\t\t\tvar item = this.items[i];\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if the element has a specified column associated to it, but is not positioned yet\r\n\t\t\t\t\tif(item.specifiedXStart.type == LOCATE_LINE && (item.xStart==-1)) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find the start position (x axis)\r\n\t\t\t\t\t\tvar xStart = this.findXStart(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find the end position (x axis)\r\n\t\t\t\t\t\tvar xEnd = this.findXEnd(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// assumption: Y is either AUTO + SPAN or AUTO + AUTO\r\n\t\t\t\t\t\tvar spanY = 1;\r\n\t\t\t\t\t\tif(item.specifiedYEnd.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\t\tif(item.specifiedYEnd.name === undefined) {\r\n\t\t\t\t\t\t\t\t// The span is defined as this value\r\n\t\t\t\t\t\t\t\tspanY = item.specifiedYEnd.index;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\r\n\t\t\t\t\t\t\t\tspanY = 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// add rows as necessary\r\n\t\t\t\t\t\tthis.ensureColumns(xEnd);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// walk through columns to find a suitable position\r\n\t\t\t\t\t\tIncrementalRowAttempts: for(var sy = 0;;sy++) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tfor(var y = sy+spanY-1; y>=sy; y--) {\r\n\t\t\t\t\t\t\t\tfor(var x = xStart; x<xEnd; x++) {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// if the cell is occupied\r\n\t\t\t\t\t\t\t\t\tif(this.rcMatrix[x][y]) {\r\n\t\t\t\t\t\t\t\t\t\tcontinue IncrementalRowAttempts;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar yStart = sy;\r\n\t\t\t\t\t\tvar yEnd = sy+spanY;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// we're done! this is so cool dude!\r\n\t\t\t\t\t\titem.xStart = xStart;\r\n\t\t\t\t\t\titem.yStart = yStart;\r\n\t\t\t\t\t\titem.xEnd = xEnd;\r\n\t\t\t\t\t\titem.yEnd = yEnd;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// we should fill the explicit matrix now!\r\n\t\t\t\t\t\tthis.markAsOccupied(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\t\r\n\t\tautoGrow: function() {\r\n\t\t\t\r\n\t\t\t// helpers\r\n\t\t\tvar growX = function(index) {\r\n\t\t\t\twhile(index >= this.xLines.length) {\r\n\t\t\t\t\tthis.xLines.push(['*']);\r\n\t\t\t\t\tthis.xSizes.push(this.defaultXSize);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar growY = function(index) {\r\n\t\t\t\twhile(index >= this.yLines.length) {\r\n\t\t\t\t\tthis.yLines.push(['*']);\r\n\t\t\t\t\tthis.ySizes.push(this.defaultYSize);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// reset the lines to the specified ones if necessary\r\n\t\t\tthis.resetLinesToSpecified(); // TODO: why?\r\n\t\t\t\r\n\t\t\t// ensure there's at least one cell\r\n\t\t\tgrowX.call(this,1); growY.call(this,1);\r\n\t\t\t\r\n\t\t\t// check if an item is explicitly positioned outside the explicit grid, and expand it if needed\r\n\t\t\tfor(var i = this.items.length; i--;) {\r\n\t\t\t\t\r\n\t\t\t\tvar item = this.items[i];\r\n\t\t\t\t\r\n\t\t\t\t// CONSIDER: items already positioned\r\n\t\t\t\tif(item.xEnd > 0) { growX.call(this,item.xEnd); }\r\n\t\t\t\tif(item.yEnd > 0) { growY.call(this,item.yEnd); }\r\n\t\t\t\tif(item.xEnd > 0 && item.yEnd > 0) { continue; }\r\n\t\t\t\t\r\n\t\t\t\t// CONSIDER: elements with a known location\r\n\t\t\t\t\r\n\t\t\t\t// (x axis):\r\n\t\t\t\tif(item.specifiedXEnd.type == LOCATE_LINE || item.specifiedXStart.type == LOCATE_LINE) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar xStart = this.findXStart(item);\r\n\t\t\t\t\tvar xEnd = this.findXEnd(item);\r\n\t\t\t\t\tgrowX.call(this,xEnd);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// (y axis):\r\n\t\t\t\tif(item.specifiedYEnd.type == LOCATE_LINE || item.specifiedYStart.type == LOCATE_LINE) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar yStart = this.findYStart(item);\r\n\t\t\t\t\tvar yEnd = this.findYEnd(item);\r\n\t\t\t\t\tif(yEnd <= yStart) { yEnd = yStart+1; }\r\n\t\t\t\t\tgrowY.call(this,yEnd);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// CONSIDER: known spans\r\n\t\t\t\t// // NOTE: I don't support \"grid-row/column-start: span X\";\r\n\t\t\t\tif(item.specifiedXEnd.type == LOCATE_SPAN && item.specifiedXEnd.name===undefined) {\r\n\t\t\t\t\tgrowX.call(this,item.specifiedXEnd.index);\r\n\t\t\t\t}\r\n\t\t\t\tif(item.specifiedYEnd.type == LOCATE_SPAN && item.specifiedYEnd.name===undefined) {\r\n\t\t\t\t\tgrowY.call(this,item.specifiedYEnd.index);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// grow the grid matrix:\r\n\t\t\tif(this.growY) {\r\n\t\t\t\twhile(this.ySizes.length>this.rcMatrix.length) {\r\n\t\t\t\t\tthis.rcMatrix.push([]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(var r=this.rcMatrix.length; r--;) {\r\n\t\t\t\t\tthis.rcMatrix[r].length = this.xSizes.length;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\twhile(this.xSizes.length>this.rcMatrix.length) {\r\n\t\t\t\t\tthis.rcMatrix.push([]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(var r=this.rcMatrix.length; r--;) {\r\n\t\t\t\t\tthis.rcMatrix[r].length = this.ySizes.length;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tscheduleRelayout: function() {\r\n\t\t\tvar This = this;\r\n\t\t\tif(!This.isLayoutScheduled) {\r\n\t\t\t\tThis.isLayoutScheduled = true;\r\n\t\t\t\trequestAnimationFrame(function() {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tThis.revokePolyfilledStyle();\r\n\t\t\t\t\t\tThis.updateFromElement();\r\n\t\t\t\t\t\tThis.performLayout();\r\n\t\t\t\t\t\tThis.generatePolyfilledStyle();\r\n\t\t\t\t\t} finally {\r\n\t\t\t\t\t\tThis.isLayoutScheduled = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\tperformLayout: function() {\r\n\t\t\r\n\t\t\t// process non-automatic items\r\n\t\t\tthis.buildImplicitMatrix();\r\n\r\n\t\t\t// position the remaining grid items. \r\n\t\t\tvar cursor = { x: 0, y: 0 };\r\n\r\n\t\t\tif(this.growY) {\r\n\t\t\t\t\r\n\t\t\t\t//For each grid item that hasn�t been positioned by the previous steps, in order-modified document order:\r\n\t\t\t\tfor(var i=0; i<this.items.length; i++) {\r\n\t\t\t\t\tvar item = this.items[i]; if(item.xEnd!=-1 && item.yEnd!=-1) { continue; }\r\n\t\t\t\t\t\r\n\t\t\t\t\t// reset the cursor if the algorithm is set to 'dense'\r\n\t\t\t\t\tif(this.growDense) { cursor = { x: 0, y: 0 }; }\r\n\t\t\t\t\t\r\n\t\t\t\t\t//If the item has a definite column position: \r\n\t\t\t\t\tif(item.specifiedXStart.type == LOCATE_LINE) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// 1. Set the column position of the cursor to be equal to the inline-start index of the grid item. \r\n\t\t\t\t\t\tvar xStart = this.findXStart(item); if(cursor.x > xStart) { cursor.y++; } cursor.x = xStart;\r\n\t\t\t\t\t\tvar xEnd = this.findXEnd(item); if(xStart>=xEnd) { xEnd=xStart+1}\r\n\t\t\t\t\t\titem.xStart=xStart; item.xEnd=xEnd;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// assumption: Y is either AUTO + SPAN or AUTO + AUTO\r\n\t\t\t\t\t\tvar spanY = 1;\r\n\t\t\t\t\t\tif(item.specifiedYEnd.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\t\tif(item.specifiedYEnd.name === undefined) {\r\n\t\t\t\t\t\t\t\t// The span is defined as this value\r\n\t\t\t\t\t\t\t\tspanY = item.specifiedYEnd.index;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\r\n\t\t\t\t\t\t\t\tspanY = 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// 2. Increment the auto-placement cursor�s row position until a value is found where the grid item does not overlap any occupied grid cells (creating new rows in the implicit grid as necessary).\r\n\t\t\t\t\t\tIncrementalRowAttempts: while(true) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// make room for the currently attempted position\r\n\t\t\t\t\t\t\tthis.ensureRows(cursor.y+spanY);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// check the non-overlap condition\r\n\t\t\t\t\t\t\tfor(var y = cursor.y+spanY-1; y>=cursor.y; y--) {\r\n\t\t\t\t\t\t\t\tfor(var x = xStart; x<xEnd; x++) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// if the cell is occupied\r\n\t\t\t\t\t\t\t\t\tif(this.rcMatrix[y][x]) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// move to the next row\r\n\t\t\t\t\t\t\t\t\t\tcursor.y=y+1; continue IncrementalRowAttempts;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// settle the position\r\n\t\t\t\t\t\titem.xStart = xStart;\r\n\t\t\t\t\t\titem.xEnd = xEnd;\r\n\t\t\t\t\t\titem.yStart = cursor.y;\r\n\t\t\t\t\t\titem.yEnd = cursor.y+spanY;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tthis.markAsOccupied(item);\t\t\t\t\t\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else { // If the item has an automatic grid position in both axes: \r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// assumption: X is either AUTO + SPAN or AUTO + AUTO\r\n\t\t\t\t\t\tvar spanX = 1;\r\n\t\t\t\t\t\tif(item.specifiedXEnd.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\t\tif(item.specifiedXEnd.name === undefined) {\r\n\t\t\t\t\t\t\t\t// The span is defined as this value\r\n\t\t\t\t\t\t\t\tspanX = item.specifiedXEnd.index;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\r\n\t\t\t\t\t\t\t\tspanX = 1; console.error('[CSS-GRID] UNSUPPORTED: grid-row/column: auto / span [0-9]+ [A-Z]+');\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// assumption: Y is either AUTO + SPAN or AUTO + AUTO\r\n\t\t\t\t\t\tvar spanY = 1;\r\n\t\t\t\t\t\tif(item.specifiedYEnd.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\t\tif(item.specifiedYEnd.name === undefined) {\r\n\t\t\t\t\t\t\t\t// The span is defined as this value\r\n\t\t\t\t\t\t\t\tspanY = item.specifiedYEnd.index;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\r\n\t\t\t\t\t\t\t\tspanY = 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Increment the auto-placement cursor�s row/column position (creating new rows in the implicit grid as necessary)\r\n\t\t\t\t\t\tvar nextStep = function() {\r\n\t\t\t\t\t\t\tcursor.x++; if(cursor.x+spanX>this.rcMatrix[0].length) { cursor.y++; this.ensureRows(cursor.y + spanY); cursor.x=0; }\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// 1. Increment the column position of the auto-placement cursor until this item�s grid area does not overlap any occupied grid cells\r\n\t\t\t\t\t\tIncrementalYXPositionAttempts: while(true) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// make room for the currently attempted position\r\n\t\t\t\t\t\t\tthis.ensureRows(cursor.y+spanY);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// check the non-overlap condition\r\n\t\t\t\t\t\t\tfor(var y = cursor.y+spanY-1; y>=cursor.y; y--) {\r\n\t\t\t\t\t\t\t\tfor(var x = cursor.x+spanX-1; x>=cursor.x; x--) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// if the cell is occupied\r\n\t\t\t\t\t\t\t\t\tif(this.rcMatrix[y][x]) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// move to the next row/column\r\n\t\t\t\t\t\t\t\t\t\tnextStep.call(this); continue IncrementalYXPositionAttempts;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// settle the position\r\n\t\t\t\t\t\titem.xStart = cursor.x;\r\n\t\t\t\t\t\titem.xEnd = cursor.x+spanX;\r\n\t\t\t\t\t\titem.yStart = cursor.y;\r\n\t\t\t\t\t\titem.yEnd = cursor.y+spanY;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tthis.markAsOccupied(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t//For each grid item that hasn�t been positioned by the previous steps, in order-modified document order:\r\n\t\t\t\tfor(var i=0; i<this.items.length; i++) {\r\n\t\t\t\t\tvar item = this.items[i]; if(item.xEnd!=-1 && item.yEnd!=-1) { continue; }\r\n\t\t\t\t\t\r\n\t\t\t\t\t// reset the cursor if the algorithm is set to 'dense'\r\n\t\t\t\t\tif(this.growDense) { cursor = { x: 0, y: 0 }; }\r\n\t\t\t\t\t\r\n\t\t\t\t\t//If the item has a definite row position: \r\n\t\t\t\t\tif(item.specifiedYStart.type == LOCATE_LINE) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// 1. Set the column position of the cursor to be equal to the inline-start index of the grid item. \r\n\t\t\t\t\t\tvar yStart = this.findYStart(item); if(cursor.y > yStart) { cursor.x++; } cursor.y = yStart;\r\n\t\t\t\t\t\tvar yEnd = this.findYEnd(item); if(yStart>=yEnd) { yEnd=yStart+1}\r\n\t\t\t\t\t\titem.yStart=yStart; item.yEnd=yEnd;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// assumption: X is either AUTO + SPAN or AUTO + AUTO\r\n\t\t\t\t\t\tvar spanX = 1;\r\n\t\t\t\t\t\tif(item.specifiedXEnd.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\t\tif(item.specifiedXEnd.name === undefined) {\r\n\t\t\t\t\t\t\t\t// The span is defined as this value\r\n\t\t\t\t\t\t\t\tspanX = item.specifiedXEnd.index;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\r\n\t\t\t\t\t\t\t\tspanX = 1; console.error('[CSS-GRID] UNSUPPORTED: grid-row/column: auto / span [0-9]+ [A-Z]+');\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// 2. Increment the auto-placement cursor�s row position until a value is found where the grid item does not overlap any occupied grid cells (creating new rows in the implicit grid as necessary).\r\n\t\t\t\t\t\tIncrementalColumnAttempts: while(true) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// make room for the currently attempted position\r\n\t\t\t\t\t\t\tthis.ensureColumns(cursor.x+spanX);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// check the non-overlap condition\r\n\t\t\t\t\t\t\tfor(var x = cursor.x+spanX-1; x>=cursor.x; x--) {\r\n\t\t\t\t\t\t\t\tfor(var y = yStart; y<yEnd; y++) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// if the cell is occupied\r\n\t\t\t\t\t\t\t\t\tif(this.rcMatrix[x][y]) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// move to the next row\r\n\t\t\t\t\t\t\t\t\t\tcursor.x=x+1; continue IncrementalColumnAttempts;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// settle the position\r\n\t\t\t\t\t\titem.yStart = yStart;\r\n\t\t\t\t\t\titem.yEnd = yEnd;\r\n\t\t\t\t\t\titem.xStart = cursor.x;\r\n\t\t\t\t\t\titem.yEnd = cursor.x+spanX;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tthis.markAsOccupied(item);\t\t\t\t\t\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else { // If the item has an automatic grid position in both axes: \r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// assumption: Y is either AUTO + SPAN or AUTO + AUTO\r\n\t\t\t\t\t\tvar spanY = 1;\r\n\t\t\t\t\t\tif(item.specifiedYEnd.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\t\tif(item.specifiedYEnd.name === undefined) {\r\n\t\t\t\t\t\t\t\t// The span is defined as this value\r\n\t\t\t\t\t\t\t\tspanY = item.specifiedYEnd.index;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\r\n\t\t\t\t\t\t\t\tspanY = 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// assumption: X is either AUTO + SPAN or AUTO + AUTO\r\n\t\t\t\t\t\tvar spanX = 1;\r\n\t\t\t\t\t\tif(item.specifiedXEnd.type == LOCATE_SPAN) {\r\n\t\t\t\t\t\t\tif(item.specifiedXEnd.name === undefined) {\r\n\t\t\t\t\t\t\t\t// The span is defined as this value\r\n\t\t\t\t\t\t\t\tspanX = item.specifiedXEnd.index;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// If the grid item has an automatic position and a grid span for a named line in a given dimension, instead treat the grid span as one.\r\n\t\t\t\t\t\t\t\tspanX = 1; console.error('[CSS-GRID] UNSUPPORTED: grid-row/column: auto / span [0-9]+ [A-Z]+');\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Increment the auto-placement cursor�s row/column position (creating new rows in the implicit grid as necessary)\r\n\t\t\t\t\t\tvar nextStep = function() {\r\n\t\t\t\t\t\t\tcursor.y++; if(cursor.y+spanY>this.rcMatrix[0].length) { cursor.x++; this.ensureRows(cursor.x + spanX); cursor.y=0; }\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// 1. Increment the column position of the auto-placement cursor until this item�s grid area does not overlap any occupied grid cells\r\n\t\t\t\t\t\tIncrementalXYPositionAttempts: while(true) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// make room for the currently attempted position\r\n\t\t\t\t\t\t\tthis.ensureColumns(cursor.x+spanX);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// check the non-overlap condition\r\n\t\t\t\t\t\t\tfor(var x = cursor.x+spanX-1; x>=cursor.x; x--) {\r\n\t\t\t\t\t\t\t\tfor(var y = cursor.y+spanY-1; y>=cursor.y; y--) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// if the cell is occupied\r\n\t\t\t\t\t\t\t\t\tif(this.rcMatrix[x][y]) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// move to the next row/column\r\n\t\t\t\t\t\t\t\t\t\tnextStep.call(this); continue IncrementalXYPositionAttempts;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// settle the position\r\n\t\t\t\t\t\titem.xStart = cursor.x;\r\n\t\t\t\t\t\titem.xEnd = cursor.x+spanX;\r\n\t\t\t\t\t\titem.yStart = cursor.y;\r\n\t\t\t\t\t\titem.yEnd = cursor.y+spanY;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tthis.markAsOccupied(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\tthis.computeAbsoluteTrackBreadths();\r\n\r\n\t\t\t\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tcomputeAbsoluteTrackBreadths: function() {\r\n\t\t\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t// hide child elements, to get free width/height\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\tvar runtimeStyle = createRuntimeStyle('no-children', this.element);\r\n\t\t\truntimeStyle.set(this.element, {\r\n\t\t\t\t\"border\"       : \"none\",\r\n\t\t\t\t\"padding\"      : \"0px\",\r\n\t\t\t\t\"min-height\"   : \"0px\",\r\n\t\t\t});\r\n\t\t\tfor(var i = this.items.length; i--;) {\r\n\t\t\t\truntimeStyle.set(this.items[i],{\"display\":\"none\"});\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t// hide child elements, to get free width/height\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\tvar LIMIT_IS_INFINITE = 1;\t\t\r\n\t\t\tvar infinity = 9999999.0;\r\n\t\t\tvar fullWidth = this.element.offsetWidth;\r\n\t\t\tvar fullHeight = this.element.offsetHeight;\r\n\t\t\t\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t// show child elements again\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\truntimeStyle.revoke();\r\n\t\t\t\r\n\t\t\t// \r\n\t\t\t// 10.3  Initialize Track Sizes\r\n\t\t\t// \r\n\t\t\tvar initializeFromConstraints = function(v) {\r\n\t\t\t\t\r\n\t\t\t\tvar base = 0, limit = infinity;\r\n\t\t\t\tswitch(v.minType) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// For fixed track sizes, resolve to an absolute length and use that size. \r\n\t\t\t\t\tcase TRACK_BREADTH_LENGTH:      base = v.minValue; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_PERCENTAGE:  base = v.minValue*fullSize/100; break;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tswitch(v.maxType) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// For fixed track sizes, resolve to an absolute length and use that size. \r\n\t\t\t\t\tcase TRACK_BREADTH_LENGTH:      limit = v.minValue; break;\r\n\t\t\t\t\tcase TRACK_BREADTH_PERCENTAGE:  limit = v.minValue*fullSize/100; break;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// For flexible track sizes, use the track�s initial base size as its initial growth limit.  \r\n\t\t\t\t\tcase TRACK_BREADTH_FRACTION:    limit = base; break;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// For intrinsic track sizes, use an initial growth limit of infinity. \r\n\t\t\t\t\tdefault:                        limit = infinity; break;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn { base:base, limit:limit, breadth:0, flags:((limit==infinity)?LIMIT_IS_INFINITE:0)|0 };\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// Equal distribution algorithm\r\n\t\t\t//\r\n\t\t\tvar distributeEquallyAmongTracks = function distributeEquallyAmongTracks(xSizes, kind, tracks, spaceToDistribute, enforceLimit) {\r\n\t\t\t\t// Distribute space to base sizes\r\n\t\t\t\tvar trackAmount = tracks.length;\r\n\t\t\t\tvar spacePerTrack = spaceToDistribute/trackAmount;\r\n\t\t\t\tif(kind=='base') {\r\n\t\t\t\t\r\n\t\t\t\t\t// if we enforce the limit, grow up to the most limitating track\r\n\t\t\t\t\tif(enforceLimit) {\r\n\t\t\t\t\t\tfor(var t = tracks.length; t--;) { var cx = tracks[t].x;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// find the lowest acceptable increase for all tracks\r\n\t\t\t\t\t\t\tvar newBase = xSizes[cx].base + spacePerTrack;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// if limits are enfo\r\n\t\t\t\t\t\t\tif(enforceLimit && (xSizes[cx].flags & LIMIT_IS_INFINITE == 0) && newBase > xSizes[cx].limit) {\r\n\t\t\t\t\t\t\t\tspacePerTrack -= newBase - xSizes[cx].limit;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tfor(var t = tracks.length; t--;) { var cx = tracks[t].x;\r\n\t\t\t\t\t\txSizes[cx].base += spacePerTrack;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(kind == 'limit') {\r\n\t\t\t\t\r\n\t\t\t\t\t// Update the tracks' affected sizes by folding in the calculated increase so that the next round of space distribution will account for the increase.\r\n\t\t\t\t\tfor(var t = tracks.length; t--;) { var cx = tracks[t].x;\r\n\t\t\t\t\t\t// If the growth limit is infinite...\r\n\t\t\t\t\t\tif(xSizes[cx].flags & LIMIT_IS_INFINITE) {\r\n\t\t\t\t\t\t\t// set it to the track�s base size plus the calculated increase\r\n\t\t\t\t\t\t\tif(xSizes[cx].limit == infinity) {\r\n\t\t\t\t\t\t\t\txSizes[cx].limit = xSizes[cx].base + spacePerTrack;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\txSizes[cx].limit += spacePerTrack; // TODO: THERE IS A BUG HERE ?\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// otherwise just increase the limit\r\n\t\t\t\t\t\t\txSizes[cx].limit += spacePerTrack;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t\r\n\t\t\t// \r\n\t\t\t// 10.4  Resolve Content-Based Track Sizing Functions\r\n\t\t\t// \r\n\t\t\tvar computeTrackBreadth = function(xSizes, specifiedSizes, getMinWidthOf, getMaxWidthOf, getXStartOf, getXEndOf) {\r\n\t\t\t\t\r\n\t\t\t\t// For each track\r\n\t\t\t\tvar items_done = 0; // items already consumed for this algorithm\r\n\t\t\t\tfor(var x = specifiedSizes.length; x--;) {\r\n\t\t\t\t\r\n\t\t\t\t\tvar dontCountMaxItems = false;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// If the track has a �min-content� min track sizing function\r\n\t\t\t\t\tif(specifiedSizes[x].minType == TRACK_BREADTH_MIN_CONTENT || specifiedSizes[x].minType == TRACK_BREADTH_AUTO) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Consider the items in it with a span of 1: \r\n\t\t\t\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i]; var item_xStart = getXStartOf(item); var item_xEnd = getXEndOf(item);\r\n\t\t\t\t\t\t\tif(item_xStart>x || item_xEnd<=x || item_xEnd-item_xStart != 1) continue;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Set its base size to the maximum of the items� min-content contributions. \r\n\t\t\t\t\t\t\txSizes[x].base = Math.max(xSizes[x].base, getMinWidthOf(item)); items_done++; dontCountMaxItems=true;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// If the track has a �max-content� min track sizing function\r\n\t\t\t\t\telse if(specifiedSizes[x].minType == TRACK_BREADTH_MAX_CONTENT) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Consider the items in it with a span of 1: \r\n\t\t\t\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i]; var item_xStart = getXStartOf(item); var item_xEnd = getXEndOf(item);\r\n\t\t\t\t\t\t\tif(item_xStart>x || item_xEnd<=x || item_xEnd-item_xStart != 1) continue;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Set its base size to the maximum of the items� max-content contributions. \r\n\t\t\t\t\t\t\txSizes[x].base = Math.max(xSizes[x].base, getMaxWidthOf(item)); items_done++; dontCountMaxItems=true;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// If the track has a �min-content� max track sizing function\r\n\t\t\t\t\tif(specifiedSizes[x].maxType == TRACK_BREADTH_MIN_CONTENT) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Consider the items in it with a span of 1: \r\n\t\t\t\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i]; var item_xStart = getXStartOf(item); var item_xEnd = getXEndOf(item);\r\n\t\t\t\t\t\t\tif(item_xStart>x || item_xEnd<=x || item_xEnd-item_xStart != 1) continue;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Set its growth limit to the maximum of the items� min-content contributions. \r\n\t\t\t\t\t\t\tif(xSizes[x].limit == infinity) { xSizes[x].limit = getMinWidthOf(item); }\r\n\t\t\t\t\t\t\telse { xSizes[x].limit = Math.max(xSizes[x].limit, getMinWidthOf(item)); }\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif(!dontCountMaxItems) { items_done++; }\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} \r\n\t\t\t\t\t\r\n\t\t\t\t\t// If the track has a �max-content� max track sizing function\r\n\t\t\t\t\telse if(specifiedSizes[x].maxType == TRACK_BREADTH_MAX_CONTENT || specifiedSizes[x].minType == TRACK_BREADTH_AUTO) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Consider the items in it with a span of 1: \r\n\t\t\t\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i]; var item_xStart = getXStartOf(item); var item_xEnd = getXEndOf(item);\r\n\t\t\t\t\t\t\tif(item_xStart>x || item_xEnd<=x || item_xEnd-item_xStart != 1) continue;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Set its growth limit to the maximum of the items� max-content contributions. \r\n\t\t\t\t\t\t\tif(xSizes[x].limit == infinity) { xSizes[x].limit = getMaxWidthOf(item); }\r\n\t\t\t\t\t\t\telse { xSizes[x].limit = Math.max(xSizes[x].limit, getMaxWidthOf(item)); }\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif(!dontCountMaxItems) { items_done++; }\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// update infinity flag\r\n\t\t\t\t\tif(xSizes[x].limit != infinity) {\r\n\t\t\t\t\t\txSizes[x].flags = xSizes[x].flags & ~LIMIT_IS_INFINITE;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// Next, consider the items with a span of 2 that do not span a track with a flexible sizing function: \r\n\t\t\t\t// Repeat incrementally for items with greater spans until all items have been considered.\r\n\t\t\t\tfor(var span = 2; items_done < this.items.length && span <= specifiedSizes.length; span++) {\r\n\t\t\t\t\tItemLoop: for(var i = this.items.length; i--;) { var item = this.items[i]; var item_xStart = getXStartOf(item); var item_xEnd = getXEndOf(item);\r\n\t\t\t\t\t\tif(item_xEnd-item_xStart != span) continue ItemLoop;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// gather some pieces of data about the tracks\r\n\t\t\t\t\t\tvar full_base = 0; var full_limit = 0;\r\n\t\t\t\t\t\tfor(var cx = item_xStart; cx<item_xEnd; cx++) { \r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// 1. we want to make sure none is flexible\r\n\t\t\t\t\t\t\tif(specifiedSizes[cx].maxType == TRACK_BREADTH_FRACTION) continue ItemLoop;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// 2. compute aggregated sizes\r\n\t\t\t\t\t\t\tfull_base += xSizes[cx].base;\r\n\t\t\t\t\t\t\tfull_limit += xSizes[cx].limit;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(full_limit > infinity) full_limit=infinity;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar distributeFreeSpace = function(requiredSpace, kind /*'base'|'limit'*/, target /*'min-content'|'max-content'*/) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\twhile (true) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// compute the required extra space\r\n\t\t\t\t\t\t\t\tvar spaceToDistribute = requiredSpace;\r\n\t\t\t\t\t\t\t\tfor(var cx = item_xStart; cx<item_xEnd; cx++) {\r\n\t\t\t\t\t\t\t\t\tspaceToDistribute -= xSizes[cx][kind];\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// if no space to distribute, just lock auto columns:\r\n\t\t\t\t\t\t\t\tif(spaceToDistribute<=0) {\r\n\t\t\t\t\t\t\t\t\tfor(var cx = item_xStart; cx<item_xEnd; cx++) {\r\n\t\t\t\t\t\t\t\t\t\tif(xSizes[cx].limit == infinity) {\r\n\t\t\t\t\t\t\t\t\t\t\txSizes[cx].limit = xSizes[cx].base;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// sort rows by growth limit\r\n\t\t\t\t\t\t\t\tvar rows_and_limits = [];\r\n\t\t\t\t\t\t\t\tfor(var cx = item_xStart; cx<item_xEnd; cx++) {\r\n\t\t\t\t\t\t\t\t\trows_and_limits.push({ \r\n\t\t\t\t\t\t\t\t\t\tx:cx, \r\n\t\t\t\t\t\t\t\t\t\tbase:xSizes[cx].base,\r\n\t\t\t\t\t\t\t\t\t\tlimit:xSizes[cx].limit,\r\n\t\t\t\t\t\t\t\t\t\tminIsMinContent: specifiedSizes[cx].minType == TRACK_BREADTH_MIN_CONTENT || specifiedSizes[cx].minType == TRACK_BREADTH_AUTO,\r\n\t\t\t\t\t\t\t\t\t\tminIsMaxContent: specifiedSizes[cx].minType == TRACK_BREADTH_MAX_CONTENT,\r\n\t\t\t\t\t\t\t\t\t\tmaxIsMinContent: specifiedSizes[cx].maxType == TRACK_BREADTH_MIN_CONTENT,\r\n\t\t\t\t\t\t\t\t\t\tmaxIsMaxContent: specifiedSizes[cx].maxType == TRACK_BREADTH_MAX_CONTENT || specifiedSizes[cx].maxType == TRACK_BREADTH_AUTO\r\n\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\trows_and_limits.sort(function(a,b) { return a.limit-b.limit; });\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// remove non-affected tracks\r\n\t\t\t\t\t\t\t\trows_and_limits = rows_and_limits.filter(function(b) {\r\n\t\t\t\t\t\t\t\t\tif(kind=='base') {\r\n\t\t\t\t\t\t\t\t\t\tif(target=='min-content') {\r\n\t\t\t\t\t\t\t\t\t\t\treturn b.minIsMinContent||b.minIsMaxContent;\r\n\t\t\t\t\t\t\t\t\t\t} else if(target=='max-content') {\r\n\t\t\t\t\t\t\t\t\t\t\treturn b.minIsMaxContent;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t} else if (kind == 'limit') {\r\n\t\t\t\t\t\t\t\t\t\tif(target=='min-content') {\r\n\t\t\t\t\t\t\t\t\t\t\treturn b.maxIsMinContent||b.maxIsMaxContent;\r\n\t\t\t\t\t\t\t\t\t\t} else if(target=='max-content') {\r\n\t\t\t\t\t\t\t\t\t\t\treturn b.maxIsMaxContent;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// check that there is at least one affected track\r\n\t\t\t\t\t\t\t\tif(rows_and_limits.length == 0) { return; }\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// apply the algorithm\r\n\t\t\t\t\t\t\t\tif(kind=='base') {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// Distribute space up to growth limits\r\n\t\t\t\t\t\t\t\t\tvar tracks = rows_and_limits.filter(function(b) { return b.base<b.limit; }, 0);\r\n\t\t\t\t\t\t\t\t\tvar trackAmount = tracks.length;\r\n\t\t\t\t\t\t\t\t\tif(trackAmount > 0) {\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, kind, tracks, spaceToDistribute, /*enforceLimit:*/true);\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// Distribute space beyond growth limits\r\n\t\t\t\t\t\t\t\t\t\t// If space remains after all tracks are frozen, unfreeze and continue to distribute space to� \r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// - when handling �min-content� base sizes: \r\n\t\t\t\t\t\t\t\t\t\tif(target=='min-content') {\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t// any affected track that happens to also have an intrinsic max track sizing function; \r\n\t\t\t\t\t\t\t\t\t\t\tvar tracks = rows_and_limits.filter(function(b) { return b.maxIsMinContent||b.maxIsMaxContent; }, 0);\r\n\t\t\t\t\t\t\t\t\t\t\tvar trackAmount = tracks.length;\r\n\t\t\t\t\t\t\t\t\t\t\tif(trackAmount>=1) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t// (such tracks exist:)\r\n\t\t\t\t\t\t\t\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, kind, tracks, spaceToDistribute, /*enforceLimit:*/false);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t// if there are no such tracks, then all affected tracks. \r\n\t\t\t\t\t\t\t\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, kind, rows_and_limits, spaceToDistribute, /*enforceLimit:*/false);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// - when handling �max-content� base sizes: \r\n\t\t\t\t\t\t\t\t\t\telse if(target=='max-content') {\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t// any affected track that happens to also have a �max-content� max track sizing function;\r\n\t\t\t\t\t\t\t\t\t\t\tvar tracks = rows_and_limits.filter(function(b) { return b.maxIsMaxContent; }, 0);\r\n\t\t\t\t\t\t\t\t\t\t\tvar trackAmount = tracks.length;\r\n\t\t\t\t\t\t\t\t\t\t\tif(trackAmount>=1) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t// (such tracks exist:)\r\n\t\t\t\t\t\t\t\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, kind, tracks, spaceToDistribute, /*enforceLimit:*/false);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t// if there are no such tracks, then all affected tracks. \r\n\t\t\t\t\t\t\t\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, kind, rows_and_limits, spaceToDistribute, /*enforceLimit:*/false);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\telse if (kind == 'limit') {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// distribute among all tracks\r\n\t\t\t\t\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, kind, rows_and_limits, spaceToDistribute);\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar updateInfiniteLimitFlag = function() {\r\n\t\t\t\t\t\t\tfor(var x = xSizes.length; x--;) {\r\n\t\t\t\t\t\t\t\tif(xSizes[x].limit != infinity) {\r\n\t\t\t\t\t\t\t\t\txSizes[x].flags = xSizes[x].flags & ~LIMIT_IS_INFINITE;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t// 1. For intrinsic minimums: First increase the base size of tracks with a min track sizing function of �min-content� or �max-content� by distributing extra space as needed to account for these items' min-content contributions. \r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\tdistributeFreeSpace(getMinWidthOf(item), 'base', 'min-content');\r\n\t\t\t\t\t\tupdateInfiniteLimitFlag();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t// 2. For max-content minimums: Next continue to increase the base size of tracks with a min track sizing function of �max-content� by distributing extra space as needed to account for these items' max-content contributions. \r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\tdistributeFreeSpace(getMaxWidthOf(item), 'base', 'max-content');\r\n\t\t\t\t\t\tupdateInfiniteLimitFlag();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t// 3. For intrinsic maximums: Third increase the growth limit of tracks with a max track sizing function of �min-content� or �max-content� by distributing extra space as needed to account for these items' min-content contributions. \r\n\t\t\t\t\t\t// Mark any tracks whose growth limit changed from infinite to finite in this step as infinitely growable for the next step. \r\n\t\t\t\t\t\t// (aka do not update infinity flag)\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\tdistributeFreeSpace(getMinWidthOf(item), 'limit', 'min-content');\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t// 4. For max-content maximums: Lastly continue to increase the growth limit of tracks with a max track sizing function of �max-content� by distributing extra space as needed to account for these items' max-content contributions. \r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\tdistributeFreeSpace(getMaxWidthOf(item), 'limit', 'max-content');\r\n\t\t\t\t\t\tupdateInfiniteLimitFlag();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\titems_done++;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar computeTrackBreadthIncrease = function(xSizes, specifiedSizes, fullSize, getMinWidthOf, getMaxWidthOf, getXStartOf, getXEndOf) {\r\n\t\t\t\t\r\n\t\t\t\t// sort rows by growth limit\r\n\t\t\t\tvar rows_and_limits = xSizes.map(function(item, cx) { \r\n\t\t\t\t\treturn { \r\n\t\t\t\t\t\tx:cx, \r\n\t\t\t\t\t\tbase:xSizes[cx].base,\r\n\t\t\t\t\t\tlimit:xSizes[cx].limit,\r\n\t\t\t\t\t\tminIsMinContent: specifiedSizes[cx].minType == TRACK_BREADTH_MIN_CONTENT || specifiedSizes[cx].minType == TRACK_BREADTH_AUTO,\r\n\t\t\t\t\t\tminIsMaxContent: specifiedSizes[cx].minType == TRACK_BREADTH_MAX_CONTENT,\r\n\t\t\t\t\t\tmaxIsMinContent: specifiedSizes[cx].maxType == TRACK_BREADTH_MIN_CONTENT,\r\n\t\t\t\t\t\tmaxIsMaxContent: specifiedSizes[cx].maxType == TRACK_BREADTH_MAX_CONTENT || specifiedSizes[cx].maxType == TRACK_BREADTH_AUTO\r\n\t\t\t\t\t};\r\n\t\t\t\t});\r\n\t\t\t\trows_and_limits.sort(function(a,b) { return a.limit-b.limit; });\r\n\t\t\t\t\r\n\t\t\t\twhile(true) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// compute size to distribute\r\n\t\t\t\t\tvar spaceToDistribute = fullSize;\r\n\t\t\t\t\tfor(var cx = xSizes.length; cx--;) {\r\n\t\t\t\t\t\tspaceToDistribute -= xSizes[cx].base;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// check that there is some space to distribute\r\n\t\t\t\t\tif(spaceToDistribute <= 0) { return; }\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Distribute space up to growth limits\r\n\t\t\t\t\tvar tracks = rows_and_limits = rows_and_limits.filter(function(b) { return ((b.minIsMinContent||b.minIsMaxContent) && b.base<b.limit); }, 0);\r\n\t\t\t\t\tvar trackAmount = tracks.length; if(trackAmount <= 0) { return; }\r\n\t\t\t\t\tdistributeEquallyAmongTracks(xSizes, 'base', tracks, spaceToDistribute, /*enforceLimit:*/true);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar computeFlexibleTrackBreadth = function(xSizes, specifiedSizes, fullSize, getMinWidthOf, getMaxWidthOf, getXStartOf, getXEndOf) {\r\n\t\t\t\t\r\n\t\t\t\t// If the free space is an indefinite length: \r\n\t\t\t\tif(fullSize==0) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t//The used flex fraction is the maximum of: \r\n\t\t\t\t\tvar currentFraction = 0;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// � Each flexible track�s base size divided by its flex factor. \r\n\t\t\t\t\t'TODO: I believe this is completely useless, but CSSWG will not change it.';\r\n\t\t\t\t\t\r\n\t\t\t\t\t// � The result of finding the size of an fr for each grid item that crosses a flexible track, using all the grid tracks that the item crosses and a space to fill of the item�s max-content contribution. \r\n\t\t\t\t\tfor(var i = this.items.length; i--;) { var item = this.items[i]; var item_xStart = getXStartOf(item); var item_xEnd = getXEndOf(item);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// gather some pieces of data about the tracks\r\n\t\t\t\t\t\tvar spaceToDistribute = getMaxWidthOf(item); var flexFactorSum = 0;\r\n\t\t\t\t\t\tfor(var cx = item_xStart; cx<item_xEnd; cx++) { \r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif(specifiedSizes[cx].maxType == TRACK_BREADTH_FRACTION) {\r\n\t\t\t\t\t\t\t\t// compute how much flexible tracks are required\r\n\t\t\t\t\t\t\t\tflexFactorSum += specifiedSizes[cx].maxValue;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// deduce non-flexible tracks from the space to distribute\r\n\t\t\t\t\t\t\t\tspaceToDistribute -= xSizes[cx].base;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// compute the minimum flex fraction for this item\r\n\t\t\t\t\t\tif(spaceToDistribute > 0 && flexFactorSum > 0) {\r\n\t\t\t\t\t\t\tcurrentFraction = Math.max(currentFraction, spaceToDistribute / flexFactorSum)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// for each flexible track\r\n\t\t\t\t\tfor(var x = xSizes.length; x--;) {\r\n\t\t\t\t\t\tif(specifiedSizes[x].maxType == TRACK_BREADTH_FRACTION) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Compute the product of the hypothetical flex fraction and the track�s flex factor\r\n\t\t\t\t\t\t\tvar trackSize = currentFraction * specifiedSizes[x].maxValue;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// If that size is less than the track�s base size:\r\n\t\t\t\t\t\t\tif(xSizes[x].base < trackSize) {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// set its base size to that product.\r\n\t\t\t\t\t\t\t\txSizes[x].breadth = trackSize;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\txSizes[x].breadth = xSizes[x].base;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\txSizes[x].breadth = xSizes[x].base;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t\t// compute the leftover space\r\n\t\t\t\t\tvar spaceToDistribute = fullSize;\r\n\t\t\t\t\tvar tracks = []; var fractionSum = 0;\r\n\t\t\t\t\tfor(var x = xSizes.length; x--;) {\r\n\t\t\t\t\t\tif(specifiedSizes[x].maxType == TRACK_BREADTH_FRACTION) {\r\n\t\t\t\t\t\t\ttracks.push(x); fractionSum += specifiedSizes[x].maxValue;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tspaceToDistribute -= (xSizes[x].breadth = xSizes[x].base);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// while there are flexible tracks to size\r\n\t\t\t\t\twhile(tracks.length>0) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Let the hypothetical flex fraction be the leftover space divided by the sum of the flex factors of the flexible tracks.\r\n\t\t\t\t\t\tvar currentFraction = spaceToDistribute / fractionSum; var restart = false;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// for each flexible track\r\n\t\t\t\t\t\tfor(var i = tracks.length; i--;) { var x = tracks[i];\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Compute the product of the hypothetical flex fraction and the track�s flex factor\r\n\t\t\t\t\t\t\tvar trackSize = currentFraction * specifiedSizes[x].maxValue;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// If that size is less than the track�s base size:\r\n\t\t\t\t\t\t\tif(xSizes[x].base < trackSize) {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// set its base size to that product.\r\n\t\t\t\t\t\t\t\txSizes[x].breadth = trackSize;\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// mark as non-flexible\r\n\t\t\t\t\t\t\t\txSizes[x].breadth = xSizes[x].base;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// remove from computation\r\n\t\t\t\t\t\t\t\tfractionSum -= specifiedSizes[x].maxValue;\r\n\t\t\t\t\t\t\t\ttracks.splice(i,1);\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// restart\r\n\t\t\t\t\t\t\t\trestart=true;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif(!restart) { tracks.length = 0; }\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar computeFinalTrackBreadth = function(xSizes, this_xSizes, fullWidth, getMinWidthOf, getMaxWidthOf, getXStartOf, getXEndOf) {\r\n\t\t\t\t\r\n\t\t\t\t// compute base and limit\r\n\t\t\t\tcomputeTrackBreadth.call(\r\n\t\t\t\t\tthis,\r\n\t\t\t\t\txSizes,\r\n\t\t\t\t\tthis_xSizes,\r\n\t\t\t\t\tgetMinWidthOf,\r\n\t\t\t\t\tgetMaxWidthOf,\r\n\t\t\t\t\tgetXStartOf,\r\n\t\t\t\t\tgetXEndOf\r\n\t\t\t\t);\r\n\t\t\t\t\r\n\t\t\t\t// ResolveContentBasedTrackSizingFunctions (step 4)\r\n\t\t\t\tfor(var x = this_xSizes.length; x--;) {\r\n\t\t\t\t\tif(xSizes[x].limit == infinity) { xSizes[x].limit = xSizes[x].base; }\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// grow tracks up to their max\r\n\t\t\t\tcomputeTrackBreadthIncrease.call(\r\n\t\t\t\t\tthis,\r\n\t\t\t\t\txSizes,\r\n\t\t\t\t\tthis_xSizes,\r\n\t\t\t\t\tfullWidth,\r\n\t\t\t\t\tgetMinWidthOf,\r\n\t\t\t\t\tgetMaxWidthOf,\r\n\t\t\t\t\tgetXStartOf,\r\n\t\t\t\t\tgetXEndOf\r\n\t\t\t\t);\r\n\t\t\t\t\r\n\t\t\t\t// handle flexible things\r\n\t\t\t\tcomputeFlexibleTrackBreadth.call(\r\n\t\t\t\t\tthis,\r\n\t\t\t\t\txSizes,\r\n\t\t\t\t\tthis_xSizes,\r\n\t\t\t\t\tfullWidth,\r\n\t\t\t\t\tgetMinWidthOf,\r\n\t\t\t\t\tgetMaxWidthOf,\r\n\t\t\t\t\tgetXStartOf,\r\n\t\t\t\t\tgetXEndOf\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t// compute breadth of columns\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\tvar mode = 'x';\r\n\t\t\tvar fullSize = fullWidth;\r\n\t\t\tvar xSizes = this.xSizes.map(initializeFromConstraints);\r\n\t\t\t\r\n\t\t\tvar getMinWidthOf = function(item) { return item.minWidth+item.hMargins; };\r\n\t\t\tvar getMaxWidthOf = function(item) { return item.maxWidth+item.hMargins; };\r\n\t\t\tvar getXStartOf = function(item) { return item.xStart; }; \r\n\t\t\tvar getXEndOf = function(item) { return item.xEnd; };\r\n\t\t\t\r\n\t\t\t// compute base and limit\r\n\t\t\tcomputeFinalTrackBreadth.call(\r\n\t\t\t\tthis,\r\n\t\t\t\txSizes,\r\n\t\t\t\tthis.xSizes,\r\n\t\t\t\tfullWidth,\r\n\t\t\t\tgetMinWidthOf,\r\n\t\t\t\tgetMaxWidthOf,\r\n\t\t\t\tgetXStartOf,\r\n\t\t\t\tgetXEndOf\r\n\t\t\t);\r\n\t\t\t\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t// position each element absolutely, and set width to compute height\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\tvar usedStyle = usedStyleOf(this.element);\r\n\t\t\tvar runtimeStyle = createRuntimeStyle('temp-position', this.element);\r\n\t\t\t\r\n\t\t\tif(usedStyle.getPropertyValue('position')=='static') { \r\n\t\t\t\truntimeStyle.set(this.element, {\"position\":\"relative\"});\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis.items.forEach(function(item) {\r\n\t\t\t\t\r\n\t\t\t\t// firstly, compute the total breadth of the spanned tracks\r\n\t\t\t\tvar totalBreadth = 0;\r\n\t\t\t\tfor(var cx = item.xStart; cx<item.xEnd; cx++) {\r\n\t\t\t\t\ttotalBreadth += xSizes[cx].breadth;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// secondly, adapt to the alignment properties\r\n\t\t\t\t\"TODO: alignment\";\r\n\t\t\t\t\r\n\t\t\t\t// finally, set the style\r\n\t\t\t\truntimeStyle.set(item.element, {\r\n\t\t\t\t\t\"position\"   : \"absolute\",\r\n\t\t\t\t\t\"width\"      : \"\"+totalBreadth+\"px\",\r\n\t\t\t\t\t\"box-sizing\" : \"border-box\"\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t// compute breadth of rows\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\tvar mode = 'y';\r\n\t\t\tvar fullSize = fullHeight;\r\n\t\t\tvar ySizes = this.ySizes.map(initializeFromConstraints);\r\n\t\t\t\r\n\t\t\tvar getMinHeightOf = function(item) { return item.element.offsetHeight+item.vMargins; };\r\n\t\t\tvar getMaxHeightOf = function(item) { return item.element.offsetHeight+item.vMargins; };\r\n\t\t\tvar getYStartOf = function(item) { return item.yStart; };\r\n\t\t\tvar getYEndOf = function(item) { return item.yEnd; };\r\n\t\t\t\r\n\t\t\tcomputeFinalTrackBreadth.call(\r\n\t\t\t\tthis,\r\n\t\t\t\tySizes,\r\n\t\t\t\tthis.ySizes,\r\n\t\t\t\tfullHeight,\r\n\t\t\t\tgetMinHeightOf,\r\n\t\t\t\tgetMaxHeightOf,\r\n\t\t\t\tgetYStartOf,\r\n\t\t\t\tgetYEndOf\r\n\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t// release the override style of elements\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\truntimeStyle.revoke();\r\n\t\t\t\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t// save the results\r\n\t\t\t////\r\n\t\t\tthis.finalXSizes = xSizes;\r\n\t\t\tthis.finalYSizes = ySizes;\r\n\t\t\t\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t// log the results\r\n\t\t\t///////////////////////////////////////////////////////////\r\n\t\t\t/*console.log({\r\n\t\t\t\tx: xSizes,\r\n\t\t\t\txBreadths: xSizes.map(function(e) { return e.breadth; }),\r\n\t\t\t\ty: ySizes,\r\n\t\t\t\tyBreadths: ySizes.map(function(e) { return e.breadth; }),\r\n\t\t\t});*/\r\n\t\t\r\n\t\t},\r\n\t\t\r\n\t\tgenerateMSGridStyle: function() {\r\n\t\t\t\r\n\t\t\tthis.element.style.setProperty(\"display\",\"-ms-grid\");\r\n\t\t\tthis.element.style.setProperty(\"-ms-grid-rows\",this.ySizes.join(' '));\r\n\t\t\tthis.element.style.setProperty(\"-ms-grid-columns\",this.xSizes.join(' '));\r\n\t\t\t\r\n\t\t\tfor(var i=this.items.length; i--;) { var item = this.items[i]; \r\n\t\t\t\t\r\n\t\t\t\titem.element.style.setProperty(\"-ms-grid-row\", item.yStart+1);\r\n\t\t\t\titem.element.style.setProperty(\"-ms-grid-column\", item.xStart+1);\r\n\t\t\t\titem.element.style.setProperty(\"-ms-grid-row-span\", item.yEnd-item.yStart);\r\n\t\t\t\titem.element.style.setProperty(\"-ms-grid-column-span\", item.xEnd-item.xStart);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tgeneratePolyfilledStyle: function() {\r\n\t\t\r\n\t\t\tvar usedStyle = usedStyleOf(this.element);\r\n\t\t\tvar runtimeStyle = createRuntimeStyle(\"css-grid\", this.element);\r\n\t\t\r\n\t\t\tvar xSizes = this.finalXSizes;\r\n\t\t\tvar ySizes = this.finalYSizes;\r\n\t\t\t\r\n\t\t\tvar grid_width = 0;\r\n\t\t\tfor(var x = 0; x<xSizes.length; x++) {\r\n\t\t\t\tgrid_width += xSizes[x].breadth;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar grid_height = 0;\r\n\t\t\tfor(var y = 0; y<ySizes.length; y++) {\r\n\t\t\t\tgrid_height += ySizes[y].breadth;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar runtimeStyleData = {};\r\n\t\t\tif([\"block\",\"inline-block\"].indexOf(usedStyle.getPropertyValue(\"display\")) == -1) {\r\n\t\t\t\truntimeStyleData[\"display\"] = \"block\";\r\n\t\t\t}\r\n\t\t\tif(usedStyle.getPropertyValue('position')=='static') {\r\n\t\t\t\truntimeStyleData[\"position\"] = \"relative\";\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\truntimeStyle.set(this.element, runtimeStyleData);\r\n\t\t\t\r\n\r\n\t\t\t// set the position and sizing of each elements\r\n\t\t\tvar width = grid_width; var height = grid_height;\r\n\t\t\tvar items_widths = []; var items_heights = []; \r\n\t\t\titems_widths.length = items_heights.length = this.items.length;\r\n\t\t\tfor(var i=this.items.length; i--;) { var item = this.items[i]; \r\n\t\t\t\t\r\n\t\t\t\tvar left = 0;\r\n\t\t\t\tfor(var x = 0; x<item.xStart; x++) {\r\n\t\t\t\t\tleft += xSizes[x].breadth;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvar width = 0;\r\n\t\t\t\tfor(var x = item.xStart; x<item.xEnd; x++) {\r\n\t\t\t\t\twidth += xSizes[x].breadth;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvar top = 0;\r\n\t\t\t\tfor(var y = 0; y<item.yStart; y++) {\r\n\t\t\t\t\ttop += ySizes[y].breadth;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvar height = 0;\r\n\t\t\t\tfor(var y = item.yStart; y<item.yEnd; y++) {\r\n\t\t\t\t\theight += ySizes[y].breadth;\r\n\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\truntimeStyle.set(item.element, {\r\n\t\t\t\t\t\"position\"    : \"absolute\",\r\n\t\t\t\t\t\"box-sizing\"  : \"border-box\",\r\n\t\t\t\t\t\"top\"         : \"\"+top +\"px\",\r\n\t\t\t\t\t\"left\"        : \"\"+left+'px'\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\titems_widths[i] = width-item.hMargins;\r\n\t\t\t\titems_heights[i] = height-item.vMargins;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// if horizontal stretch\r\n\t\t\tif(true) { // TODO: horizontal stretch\r\n\t\t\t\tfor(var i=this.items.length; i--;) { var item = this.items[i]; var width = items_widths[i];\r\n\t\t\t\t\tif(item.minWidth <= width) { // TODO: fix that...\r\n\t\t\t\t\t\truntimeStyle.set(item.element, {\"width\": width +'px'});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// if vertical stretch\r\n\t\t\tif(true) { // TODO: vertical stretch\r\n\t\t\t\tfor(var i=this.items.length; i--;) { var item = this.items[i]; var height = items_heights[i];\r\n\t\t\t\t\tif(item.element.offsetHeight <= height) {\r\n\t\t\t\t\t\truntimeStyle.set(item.element, {\"height\": height+'px'});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// make sure the final size is right:\r\n\t\t\tvar runtimeStyleData = {};\r\n\t\t\t//if([\"absolute\",\"fixed\"].indexOf(usedStyle.getPropertyValue(\"position\")) >= 0) { runtimeStyleData[\"width\"] = grid_width+'px'; }\r\n\t\t\tif([\"auto\",\"0px\"].indexOf(usedStyle.getPropertyValue(\"width\")) >= 0) { runtimeStyleData[\"width\"] = grid_width+'px'; }\r\n\t\t\tif([\"auto\",\"0px\"].indexOf(usedStyle.getPropertyValue(\"height\")) >= 0) { runtimeStyleData[\"height\"] = grid_height+'px'; }\r\n\t\t\truntimeStyle.set(this.element, runtimeStyleData);\r\n\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\trevokePolyfilledStyle: function() {\r\n\t\t\t\r\n\t\t\tcreateRuntimeStyle('css-grid', this.element).revoke();\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tfindXStart: function(item) {\r\n\t\t\r\n\t\t\t//////////////////////////////////////////////////////////////////////////////\r\n\t\t\t// TODO: this doesn't reflect the spec after the changes made at my request //\r\n\t\t\t//////////////////////////////////////////////////////////////////////////////\r\n\t\t\t\r\n\t\t\tvar xStart = -1;\r\n\t\t\tif(item.specifiedXStart.type !== LOCATE_LINE) return 0;\r\n\t\t\t\r\n\t\t\tif(item.specifiedXStart.name) {\r\n\t\t\t\t\r\n\t\t\t\t//\r\n\t\t\t\t// <integer>? <custom-ident>\r\n\t\t\t\t//\r\n\t\t\t\t\r\n\t\t\t\tif(item.specifiedXStart.index === undefined) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// First attempts to match the grid area�s edge to a named grid area\r\n\t\t\t\t\txStart = this.findXLine(item.specifiedXStart.name+\"-start\", 0, 0, /*dontFallback*/true);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tif(xStart==-1) {\r\n\t\t\t\t\r\n\t\t\t\t\t// Otherwise, contributes the first named line with the specified name to the grid item�s placement. \r\n\t\t\t\t\txStart = this.findXLine(item.specifiedXStart.name, 0, (item.specifiedXStart.index||1)-1);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t//\r\n\t\t\t\t// <integer>\r\n\t\t\t\t//\r\n\t\t\t\txStart = (item.specifiedXStart.index||1)-1;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// correct impossible values\r\n\t\t\tif(xStart < 0) { xStart=0; }\r\n\t\t\t\r\n\t\t\t// return the final result\r\n\t\t\treturn item.xStart = xStart;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tfindYStart: function(item) {\r\n\t\t\t\r\n\t\t\tvar yStart = -1;\r\n\t\t\tif(item.specifiedYStart.type !== LOCATE_LINE) return 0;\r\n\r\n\t\t\tif(item.specifiedYStart.name) {\r\n\t\t\t\t\r\n\t\t\t\t//\r\n\t\t\t\t// <interger>? <custom-ident>\r\n\t\t\t\t//\r\n\t\t\t\t\r\n\t\t\t\tif(item.specifiedYStart.index === undefined) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// First attempts to match the grid area�s edge to a named grid area\r\n\t\t\t\t\tyStart = this.findYLine(item.specifiedYStart.name+\"-start\", 0, 0, /*dontFallback*/true);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tif(yStart == -1) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Otherwise, contributes the first named line with the specified name to the grid item�s placement. \r\n\t\t\t\t\tyStart = this.findYLine(item.specifiedYStart.name, 0,(item.specifiedYStart.index||1)-1);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t//\r\n\t\t\t\t// <integer>\r\n\t\t\t\t//\r\n\t\t\t\tyStart = (item.specifiedYStart.index||1)-1;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// correct impossible values\r\n\t\t\tif(yStart < 0) { yStart=0; }\r\n\t\t\t\r\n\t\t\t// return the final result\r\n\t\t\treturn item.yStart = yStart;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tfindXEnd: function(item) {\r\n\t\t\t\r\n\t\t\tvar xEnd = -1;\r\n\t\t\tvar xStart = item.xStart;\r\n\t\t\tswitch(item.specifiedXEnd.type) {\r\n\t\t\t\t\r\n\t\t\t\tcase LOCATE_LINE:\r\n\t\t\t\t\tif(item.specifiedXEnd.name) {\r\n\t\t\t\t\t\tif(item.specifiedXEnd.index === undefined) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// First attempts to match the grid area�s edge to a named grid area\r\n\t\t\t\t\t\t\txEnd = this.findXLine(item.specifiedXEnd.name+\"-end\", 0, 0, /*dontFallback*/true);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(xEnd == -1) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Otherwise, contributes the first named line with the specified name to the grid item�s placement. \r\n\t\t\t\t\t\t\txEnd = this.findXLine(item.specifiedXEnd.name, 0, (item.specifiedXEnd.index||1)-1);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\txEnd = (item.specifiedXEnd.index||1)-1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\tcase LOCATE_SPAN:\r\n\t\t\t\t\tif(item.specifiedXEnd.name) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// Set the corresponding edge N lines apart from its opposite edge. \r\n\t\t\t\t\t\txEnd = this.findXLine(item.specifiedXEnd.name, xStart+1, (item.specifiedXEnd.index||1)-1);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Set the corresponding edge N lines apart from its opposite edge. \r\n\t\t\t\t\t\txEnd = xStart+((item.specifiedXEnd.index|0)||1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\tcase LOCATE_AUTO:\r\n\t\t\t\t\t// I don't support subgrids, so this is always true:\r\n\t\t\t\t\txEnd = xStart+1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(xEnd <= xStart) { xEnd = xStart+1; }\r\n\t\t\treturn item.xEnd = xEnd;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tfindYEnd: function(item) {\r\n\t\t\t\r\n\t\t\tvar yEnd = -1;\r\n\t\t\tvar yStart = item.yStart;\r\n\t\t\tswitch(item.specifiedYEnd.type) {\r\n\t\t\t\t\r\n\t\t\t\tcase LOCATE_LINE:\r\n\t\t\t\t\tif(item.specifiedYEnd.name) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t// <integer>? <identifier>\r\n\t\t\t\t\t\t// \r\n\t\t\t\t\t\tif(item.specifiedYEnd.index === undefined) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// First attempts to match the grid area�s edge to a named grid area\r\n\t\t\t\t\t\t\tyEnd = this.findYLine(item.specifiedYEnd.name+\"-end\", 0, 0, /*dontFallback*/true);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(yEnd == -1) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Otherwise, contributes the first named line with the specified name to the grid item�s placement. \r\n\t\t\t\t\t\t\tyEnd = this.findYLine(item.specifiedYEnd.name, 0, (item.specifiedYEnd.index||1)-1);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t// <integer>\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\tyEnd = (item.specifiedYEnd.index||1)-1;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\tcase LOCATE_SPAN:\r\n\t\t\t\t\tif(item.specifiedYEnd.name) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// Set the corresponding edge N lines apart from its opposite edge. \r\n\t\t\t\t\t\tyEnd = this.findYLine(item.specifiedYEnd.name, yStart+1, (item.specifiedYEnd.index||1)-1);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// TODO: I'm having the wrong behavior here, I sent a mail to csswg to get the spec changed\r\n\t\t\t\t\t\t// \"The spec is more what you'd call 'guidelines' than actual rules\"\r\n\t\t\t\t\t\tif(yEnd==-1) { yEnd = 0; }\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Set the corresponding edge N lines apart from its opposite edge. \r\n\t\t\t\t\t\tyEnd = yStart+((item.specifiedYEnd.index|0)||1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\tcase LOCATE_AUTO:\r\n\t\t\t\t\t// I don't support subgrids, so this is always true:\r\n\t\t\t\t\tyEnd = yStart+1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// correct impossible end values\r\n\t\t\tif(yEnd <= yStart) { yEnd = yStart+1; }\r\n\t\t\t\r\n\t\t\t// return the final result\r\n\t\t\treturn item.yEnd = yEnd;\r\n\r\n\t\t},\r\n\t\t\r\n\t\tfindXLine: function(name, startIndex, skipCount, dontFallback) {\r\n\t\t\r\n\t\t\tstartIndex=startIndex|0;\r\n\t\t\tskipCount=skipCount|0;\r\n\t\t\t\r\n\t\t\t// special case for cases where the name isn't provided\r\n\t\t\tif(!name) {\r\n\t\t\t\tif(startIndex+skipCount < this.xLines.length) {\r\n\t\t\t\t\treturn startIndex+skipCount;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn this.xLines.length;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// find the 1+skipCount'th line to match the right name\r\n\t\t\tvar last = -1;\r\n\t\t\tfor(var i = startIndex; i<this.xLines.length; i++) {\r\n\t\t\t\tif(this.xLines[i].indexOf(name) >= 0 || (!dontFallback && this.xLines[i].indexOf('*') >= 0)) { \r\n\t\t\t\t\tif(skipCount>0) { last=i; skipCount--; }\r\n\t\t\t\t\telse { return i; }\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// if we still have lines to find, we know that lines of the implicit grid match all names\r\n\t\t\tif(!dontFallback) { console.warn('[CSS-GRID] Missing '+(skipCount+1)+' lines named \"'+name+'\" after line '+startIndex+'.'); last = this.xLines.length+skipCount+1; this.ensureRows(last); }\r\n\t\t\treturn last;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tfindYLine: function(name, startIndex, skipCount, dontFallback) {\r\n\r\n\t\t\tstartIndex=startIndex|0;\r\n\t\t\tskipCount=skipCount|0;\r\n\t\t\t\r\n\t\t\t// special case for cases where the name isn't provided\r\n\t\t\tif(!name) {\r\n\t\t\t\tif(startIndex+skipCount < this.yLines.length) {\r\n\t\t\t\t\treturn startIndex+skipCount;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn this.yLines.length;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// find the 1+skipCount'th line to match the right name\r\n\t\t\tvar last = -1;\r\n\t\t\tfor(var i = startIndex; i<this.yLines.length; i++) {\r\n\t\t\t\tif(this.yLines[i].indexOf(name) >= 0 || (!dontFallback && this.yLines[i].indexOf('*') >= 0)) { \r\n\t\t\t\t\tif(skipCount>0) { last=i; skipCount--; }\r\n\t\t\t\t\telse { return i; }\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// if we still have lines to find, we know that lines of the implicit grid match all names\r\n\t\t\tif(!dontFallback) { console.warn('[CSS-GRID] Missing '+(skipCount+1)+' lines named \"'+name+'\" after line '+startIndex+'.'); last = this.yLines.length+skipCount+1; this.ensureColumns(last); }\r\n\t\t\treturn last;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t}\r\n\t\r\n\tvar cssGrid = {\r\n\t\t\r\n\t\tLOCATE_LINE   :  LOCATE_LINE,\r\n\t\tLOCATE_SPAN   :  LOCATE_SPAN,\r\n\t\tLOCATE_AREA   :  LOCATE_AREA,\r\n\t\tLOCATE_AUTO   :  LOCATE_AUTO,\r\n\t\t\r\n\t\tALIGN_START   :  ALIGN_START,\r\n\t\tALIGN_CENTER  :  ALIGN_CENTER,\r\n\t\tALIGN_END     :  ALIGN_END,\r\n\t\tALIGN_FIT     :  ALIGN_FIT,  \r\n\t\t\r\n\t\tTRACK_BREADTH_AUTO        : TRACK_BREADTH_AUTO,\r\n\t\tTRACK_BREADTH_LENGTH      : TRACK_BREADTH_LENGTH,\r\n\t\tTRACK_BREADTH_FRACTION    : TRACK_BREADTH_FRACTION,\r\n\t\tTRACK_BREADTH_PERCENTAGE  : TRACK_BREADTH_PERCENTAGE,\r\n\t\tTRACK_BREADTH_MIN_CONTENT : TRACK_BREADTH_MIN_CONTENT,\r\n\t\tTRACK_BREADTH_MAX_CONTENT : TRACK_BREADTH_MAX_CONTENT,\r\n\r\n\t\tGridLayout: GridLayout, \r\n\t\tGridItem: GridItem, \r\n\t\tGridItemPosition: GridItemPosition,\r\n\t\tGridTrackBreadth: GridTrackBreadth,\r\n\t\t\r\n\t};\r\n\treturn cssGrid;\r\n\t\r\n})(window, document)\nrequire.define('src/css-grid/lib/grid-layout.js');","// TODO: document the \"no_auto_css_grid\" flag?\r\n// TOOD: document the \"no_ms_grid_implementation\" flag?\r\n\r\n!(function(window, document) { \"use strict\";\r\n\r\n\trequire('src/core/polyfill-dom-console.js');\r\n\tvar cssCascade = require('src/core/css-cascade.js');\r\n\tvar cssGrid = require('src/css-grid/lib/grid-layout.js');\r\n\t\r\n\tvar enabled = false;\r\n\tvar enablePolyfill = function() { if(enabled) { return; } else { enabled = true; }\r\n\r\n\t\t//\r\n\t\t// [0] define css properties\r\n\t\t// those properties can now be set using Element.myStyle.xyz if they weren't already\r\n\t\t//\r\n\t\t\r\n\t\tvar gridProperties = ['grid','grid-template','grid-template-rows','grid-template-columns','grid-template-areas','grid-areas','grid-auto-flow'];\r\n\t\tvar gridItemProperties = ['grid-area','grid-row','grid-column','grid-row-start','grid-row-end','grid-column-start','grid-column-end'];\r\n\t\tfor(var i=gridProperties.length; i--;)     { cssCascade.polyfillStyleInterface(gridProperties[i]); }\r\n\t\tfor(var i=gridItemProperties.length; i--;) { cssCascade.polyfillStyleInterface(gridItemProperties[i]); }\r\n\t\t\r\n\t\t// \r\n\t\t// [1] when any update happens:\r\n\t\t// construct new content and region flow pairs\r\n\t\t// restart the region layout algorithm for the modified pairs\r\n\t\t// \r\n\t\t\r\n\t\tcssCascade.startMonitoringProperties(\r\n\t\t\tgridProperties, \r\n\t\t\t{\r\n\t\t\t\tonupdate: function onupdate(element, rule) {\r\n\r\n\t\t\t\t\t// log some message in the console for debug\r\n\t\t\t\t\tcssConsole.dir({message:\"onupdate\",element:element,selector:rule.selector.toCSSString(),rule:rule});\r\n\t\t\t\t\t\r\n\t\t\t\t\t// check if the element already has a grid or grid-item layout\r\n\t\t\t\t\tif(element.gridModel) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// the layout must be recomputed\r\n\t\t\t\t\t\telement.gridModel.scheduleRelayout();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// setup a new grid model, and schedule a relayout\r\n\t\t\t\t\t\telement.gridLayout = new cssGrid.GridLayout(element);\r\n\t\t\t\t\t\telement.gridLayout.scheduleRelayout();\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// TODO: watch DOM for updates in the element?\r\n\t\t\t\t\t\tif(\"MutationObserver\" in window) {\r\n\t\t\t\t\t\t\tvar observer = new MutationObserver(function(e) {\r\n\t\t\t\t\t\t\t\telement.gridLayout.scheduleRelayout();\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\tvar target = document.documentElement;\r\n\t\t\t\t\t\t\tvar config = { \r\n\t\t\t\t\t\t\t\tsubtree: true, \r\n\t\t\t\t\t\t\t\tattributes: false, \r\n\t\t\t\t\t\t\t\tchildList: true, \r\n\t\t\t\t\t\t\t\tcharacterData: true\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\tobserver.observe(target, config);\r\n\t\t\t\t\t\t} else if(\"MutationEvent\" in window) {\r\n\t\t\t\t\t\t\telement.addEventListener('DOMSubtreeModified', function() {\r\n\t\t\t\t\t\t\t\tif(!element.gridLayout.isLayoutScheduled) { element.gridLayout.scheduleRelayout(); }\r\n\t\t\t\t\t\t\t}, true);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// TODO: watch resize events for relayout?\r\n\t\t\t\t\t\tvar lastWidth = element.offsetWidth;\r\n\t\t\t\t\t\tvar lastHeight = element.offsetHeight;\r\n\t\t\t\t\t\tvar updateOnResize = function() {\r\n\t\t\t\t\t\t\tif(lastWidth != element.offsetWidth || lastHeight != element.offsetHeight) {\r\n\t\t\t\t\t\t\t\t// update last known size\r\n\t\t\t\t\t\t\t\tlastWidth = element.offsetWidth;\r\n\t\t\t\t\t\t\t\tlastHeight = element.offsetHeight;\r\n\t\t\t\t\t\t\t\t// relayout (and prevent double-dispatch)\r\n\t\t\t\t\t\t\t\tif(observer) { observer.takeRecords(); observer.disconnect(element); }\r\n\t\t\t\t\t\t\t\telement.gridLayout.scheduleRelayout();\r\n\t\t\t\t\t\t\t\tif(observer) { observer.takeRecords(); observer.observe(element, config); }\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\trequestAnimationFrame(updateOnResize);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trequestAnimationFrame(updateOnResize);\r\n\t\t\t\t\t\t// TODO: watch the load event for relayout?\r\n\t\t\t\t\t\twindow.addEventListener('load', updateOnResize);\r\n\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\tcssCascade.startMonitoringProperties(\r\n\t\t\tgridItemProperties, \r\n\t\t\t{\r\n\t\t\t\tonupdate: function onupdate(element, rule) {\r\n\r\n\t\t\t\t\t// log some message in the console for debug\r\n\t\t\t\t\tcssConsole.dir({message:\"onupdate\",element:element,selector:rule.selector.toCSSString(),rule:rule});\r\n\t\t\t\t\t\r\n\t\t\t\t\t// check if the element already has a grid or grid-item layout\r\n\t\t\t\t\tif(element.parentGridLayout) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// the parent layout must be recomputed\r\n\t\t\t\t\t\telement.parentGridLayout.scheduleRelayout();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t}\r\n\r\n\t// expose the enabler\r\n\tcssGrid.enablePolyfill = enablePolyfill;\r\n\t\r\n\t// enable the polyfill automatically\r\n\ttry {\r\n\t\tif(!(\"no_auto_css_grid\" in window)) { enablePolyfill(); }\r\n\t} catch (ex) {\r\n\t\tsetImmediate(function() { throw ex; });\r\n\t}\r\n\t\r\n\t// return the module\r\n\treturn cssGrid;\r\n\t\r\n})(window, document);\nrequire.define('src/css-grid/polyfill.js');","//require('core:dom-matchMedia-polyfill');\r\n//require('core:dom-classList-polyfill');\r\nrequire('src/css-grid/polyfill.js');\nrequire.define('src/requirements.js');"]}